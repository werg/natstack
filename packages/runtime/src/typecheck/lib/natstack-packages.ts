/**
 * Bundled @natstack/* package type definitions for the type checker.
 *
 * AUTO-GENERATED by scripts/bundle-natstack-types.ts
 * Do not edit manually.
 *
 * Run: pnpm run bundle-types to regenerate
 */

export interface NatstackPackageTypes {
  /** Map of file paths to their contents */
  files: Record<string, string>;
  /** Map of subpath exports (e.g., '/broker') to their entry .d.ts file */
  subpaths: Record<string, string>;
}

export const NATSTACK_PACKAGE_TYPES: Record<string, NatstackPackageTypes> = 
{
  "@natstack/ai": {
    "files": {
      "StreamTextSession.d.ts": "/**\n * StreamTextSession - Class-based stream management for AI text generation.\n *\n * Refactored from the 430-line streamText function for better:\n * - Testability (each method can be unit tested)\n * - Maintainability (clear separation of concerns)\n * - Error handling (centralized error management)\n */\nimport type { StreamEvent, StreamTextOptions, StreamTextResult } from \"./index.js\";\n/**\n * Manages a single AI text stream session with tool execution and callbacks.\n */\nexport declare class StreamTextSession {\n    readonly streamId: string;\n    private readonly options;\n    private readonly onCancel;\n    private ended;\n    private streamError;\n    private readonly eventQueue;\n    private readonly waiters;\n    private fullText;\n    private readonly allToolCalls;\n    private readonly allToolResults;\n    private finalFinishReason;\n    private finalUsage;\n    private finalTotalSteps;\n    private currentStepText;\n    private currentStepToolCalls;\n    private currentStepToolResults;\n    private resolveTextCallbacks;\n    private resolveToolCallsCallbacks;\n    private resolveToolResultsCallbacks;\n    private resolveFinishReasonCallbacks;\n    private resolveUsageCallbacks;\n    private resolveTotalStepsCallbacks;\n    private iteratorCreated;\n    private unsubscribers;\n    constructor(streamId: string, options: StreamTextOptions, onCancel: () => void);\n    /**\n     * Process an incoming stream event.\n     */\n    processEvent(event: StreamEvent): Promise<void>;\n    private handleTextDelta;\n    private handleToolCall;\n    private handleToolResult;\n    private handleStepFinish;\n    private handleFinish;\n    private handleError;\n    /**\n     * Cleanup and resolve all promises.\n     */\n    cleanup(): void;\n    /**\n     * Cancel the stream.\n     */\n    cancel(): void;\n    /**\n     * Register an unsubscriber to be called on cleanup.\n     */\n    addUnsubscriber(unsub: () => void): void;\n    /**\n     * Create an async iterator for the stream.\n     *\n     * IMPORTANT: Only ONE iterator should be created per session.\n     * Multiple concurrent iterators will compete for events and cause data loss.\n     *\n     * @throws Error if an iterator was already created\n     */\n    createIterator(): AsyncIterator<StreamEvent>;\n    /**\n     * Create a text-only stream iterator.\n     */\n    createTextStreamIterator(): AsyncIterator<string>;\n    /**\n     * Build the StreamTextResult object.\n     */\n    toResult(): StreamTextResult;\n}\n//# sourceMappingURL=StreamTextSession.d.ts.map",
      "client.d.ts": "import type { AIRoleRecord, StreamEvent, StreamTextOptions } from \"./types.js\";\nexport type AiClient = {\n    listRoles(): Promise<AIRoleRecord>;\n    streamText(options: StreamTextOptions): AsyncIterable<StreamEvent>;\n    generateText(options: StreamTextOptions): Promise<string>;\n    clearRoleCache(): void;\n};\nexport declare const ai: AiClient;\n//# sourceMappingURL=client.d.ts.map",
      "index.d.ts": "/**\n * @natstack/ai\n *\n * AI client and types for NatStack.\n *\n * This package provides a ready-to-use AI client that works in both\n * panels and workers, built on top of @natstack/runtime's RPC layer.\n */\nexport { ai } from \"./client.js\";\nexport type * from \"./types.js\";\nimport type { ToolDefinition } from \"./types.js\";\nexport interface ToolInput<TParams = Record<string, unknown>> {\n    description?: string;\n    parameters: TParams;\n    execute: (args: Record<string, unknown>, signal?: AbortSignal) => Promise<unknown>;\n}\nexport declare function tool<TParams>(input: ToolInput<TParams>): ToolDefinition;\n//# sourceMappingURL=index.d.ts.map",
      "types.d.ts": "/**\n * Shared types for AI provider IPC communication.\n */\n/**\n * Information about a model assigned to a role.\n * Panels access models by role (e.g., \"fast\", \"smart\"), not by provider-specific IDs.\n */\nexport interface AIModelInfo {\n    /** Underlying model ID this role resolves to */\n    modelId: string;\n    /** Provider identifier (e.g., \"anthropic\", \"openai\") */\n    provider: string;\n    /** Human-readable display name of the model */\n    displayName: string;\n    /** Optional description */\n    description?: string;\n}\n/**\n * Record mapping role names to their configured models.\n *\n * Standard roles (smart, fast, cheap, coding) are always present with defaults applied:\n * - smart <-> coding (both prefer fast if not configured)\n * - cheap <-> fast (both prefer smart if not configured)\n *\n * Additional custom roles can be added as needed.\n */\nexport type AIRoleRecord = {\n    smart: AIModelInfo;\n    fast: AIModelInfo;\n    cheap: AIModelInfo;\n    coding: AIModelInfo;\n} & Record<string, AIModelInfo>;\n/** Tool definition for function calling */\nexport interface AIToolDefinition {\n    type: \"function\";\n    name: string;\n    description?: string;\n    parameters: Record<string, unknown>;\n}\n/**\n * Message role types for the streamText API.\n */\nexport type MessageRole = \"system\" | \"user\" | \"assistant\" | \"tool\";\n/**\n * Content part types for messages.\n * FilePart data accepts Uint8Array for convenience but will be base64-encoded for IPC.\n */\nexport type TextPart = {\n    type: \"text\";\n    text: string;\n};\nexport type FilePart = {\n    type: \"file\";\n    mimeType: string;\n    data: string | Uint8Array;\n};\nexport type ToolCallPart = {\n    type: \"tool-call\";\n    toolCallId: string;\n    toolName: string;\n    args: unknown;\n};\nexport type ToolResultPart = {\n    type: \"tool-result\";\n    toolCallId: string;\n    toolName: string;\n    result: unknown;\n    isError?: boolean;\n};\n/**\n * Message types for the streamText API.\n */\nexport type SystemMessage = {\n    role: \"system\";\n    content: string;\n};\nexport type UserMessage = {\n    role: \"user\";\n    content: string | Array<TextPart | FilePart>;\n};\nexport type AssistantMessage = {\n    role: \"assistant\";\n    content: string | Array<TextPart | ToolCallPart>;\n};\nexport type ToolMessage = {\n    role: \"tool\";\n    content: ToolResultPart[];\n};\nexport type Message = SystemMessage | UserMessage | AssistantMessage | ToolMessage;\n/**\n * Tool definition with execute callback.\n *\n * When `execute` is omitted, the tool call event is emitted but execution\n * is left to the caller (useful for human-in-the-loop approval flows).\n */\nexport interface ToolDefinition {\n    description?: string;\n    parameters: Record<string, unknown>;\n    execute?: (args: Record<string, unknown>, signal?: AbortSignal) => Promise<unknown>;\n}\n/**\n * Callback types for streamText (Vercel AI SDK compatible)\n */\nexport type OnChunkCallback = (chunk: StreamEvent) => void | Promise<void>;\nexport type OnFinishCallback = (result: StreamTextFinishResult) => void | Promise<void>;\nexport type OnStepFinishCallback = (step: StepFinishResult) => void | Promise<void>;\nexport type OnErrorCallback = (error: Error) => void | Promise<void>;\nexport interface StepFinishResult {\n    stepNumber: number;\n    finishReason: \"stop\" | \"tool-calls\" | \"length\" | \"error\";\n    text: string;\n    toolCalls: Array<{\n        toolCallId: string;\n        toolName: string;\n        args: unknown;\n    }>;\n    toolResults: Array<{\n        toolCallId: string;\n        toolName: string;\n        result: unknown;\n        isError?: boolean;\n    }>;\n}\nexport interface StreamTextFinishResult {\n    text: string;\n    toolCalls: Array<{\n        toolCallId: string;\n        toolName: string;\n        args: unknown;\n    }>;\n    toolResults: Array<{\n        toolCallId: string;\n        toolName: string;\n        result: unknown;\n        isError?: boolean;\n    }>;\n    totalSteps: number;\n    usage?: {\n        promptTokens: number;\n        completionTokens: number;\n    };\n    finishReason: \"stop\" | \"tool-calls\" | \"length\" | \"error\";\n}\n/**\n * Options for streamText.\n */\nexport interface StreamTextOptions {\n    /** Model role name (e.g., \"fast\", \"smart\") or full model ID (e.g., \"claude-code:sonnet\") */\n    model: string;\n    /** Messages to send */\n    messages: Message[];\n    /** Tools with execute callbacks */\n    tools?: Record<string, ToolDefinition>;\n    /** Maximum agent loop iterations (default: 10) */\n    maxSteps?: number;\n    /** Abort signal for cancellation */\n    abortSignal?: AbortSignal;\n    /** Maximum output tokens */\n    maxOutputTokens?: number;\n    /** Temperature (0-1) */\n    temperature?: number;\n    /** System prompt (alternative to system message) */\n    system?: string;\n    /** Enable thinking/reasoning with optional budget */\n    thinking?: {\n        type: \"enabled\" | \"disabled\";\n        budgetTokens?: number;\n    };\n    /** Called for each stream chunk */\n    onChunk?: OnChunkCallback;\n    /** Called when the stream finishes */\n    onFinish?: OnFinishCallback;\n    /** Called when each step finishes */\n    onStepFinish?: OnStepFinishCallback;\n    /** Called when an error occurs */\n    onError?: OnErrorCallback;\n    /** Called for each reasoning delta (optional callback for thinking content) */\n    onReasoningDelta?: (delta: string) => void | Promise<void>;\n}\n/**\n * Stream event types returned by streamText.\n */\nexport type StreamEvent = {\n    type: \"text-delta\";\n    text: string;\n} | {\n    type: \"reasoning-start\";\n} | {\n    type: \"reasoning-delta\";\n    text: string;\n} | {\n    type: \"reasoning-end\";\n} | {\n    type: \"tool-call\";\n    toolCallId: string;\n    toolName: string;\n    args: unknown;\n} | {\n    type: \"tool-result\";\n    toolCallId: string;\n    toolName: string;\n    result: unknown;\n    isError?: boolean;\n} | {\n    type: \"step-finish\";\n    stepNumber: number;\n    finishReason: \"stop\" | \"tool-calls\" | \"length\" | \"error\";\n} | {\n    type: \"finish\";\n    totalSteps: number;\n    usage?: {\n        promptTokens: number;\n        completionTokens: number;\n    };\n} | {\n    type: \"error\";\n    error: Error;\n};\n/**\n * Tool execution result (internal format for IPC).\n */\nexport interface ToolExecutionResult {\n    content: Array<{\n        type: \"text\";\n        text: string;\n    }>;\n    isError?: boolean;\n    data?: unknown;\n}\n/**\n * Result object returned by streamText.\n * Provides multiple ways to consume the stream (Vercel AI SDK compatible).\n */\nexport interface StreamTextResult extends AsyncIterable<StreamEvent> {\n    /** Full stream of all events */\n    readonly fullStream: AsyncIterable<StreamEvent>;\n    /** Stream of text deltas only */\n    readonly textStream: AsyncIterable<string>;\n    /** Promise that resolves to the full generated text */\n    readonly text: Promise<string>;\n    /** Promise that resolves to all tool calls made */\n    readonly toolCalls: Promise<Array<{\n        toolCallId: string;\n        toolName: string;\n        args: unknown;\n    }>>;\n    /** Promise that resolves to all tool results */\n    readonly toolResults: Promise<Array<{\n        toolCallId: string;\n        toolName: string;\n        result: unknown;\n        isError?: boolean;\n    }>>;\n    /** Promise that resolves to the finish reason */\n    readonly finishReason: Promise<\"stop\" | \"tool-calls\" | \"length\" | \"error\">;\n    /** Promise that resolves to token usage */\n    readonly usage: Promise<{\n        promptTokens: number;\n        completionTokens: number;\n    } | undefined>;\n    /** Promise that resolves to total steps */\n    readonly totalSteps: Promise<number>;\n}\n//# sourceMappingURL=types.d.ts.map"
    },
    "subpaths": {}
  },
  "@natstack/eval": {
    "files": {
      "asyncTracking.d.ts": "/**\n * Unified async tracking API for both panels and workers.\n *\n * When running in a NatStack panel or worker, this uses the built-in\n * __natstackAsyncTracking__ global which wraps Promise and other async APIs.\n *\n * When running in other environments (tests, Node.js CLI), it provides\n * a fallback implementation that doesn't actually track async operations\n * but maintains the same API contract.\n */\n/**\n * Async tracking context returned by start().\n */\nexport interface TrackingContext {\n    id: number;\n    promises: Set<Promise<unknown>>;\n    pauseCount: number;\n}\n/**\n * Options for creating a tracking context.\n */\nexport interface TrackingContextOptions {\n    /** Auto-cleanup after this many milliseconds (0 = disabled) */\n    maxTimeout?: number;\n}\n/**\n * The async tracking API interface.\n * This is implemented by the runtime banner and accessed via globalThis.__natstackAsyncTracking__.\n */\nexport interface AsyncTrackingAPI {\n    /** Create a new tracking context and set it as current */\n    start: (options?: TrackingContextOptions) => TrackingContext;\n    /** Enter an existing tracking context (set as current) */\n    enter: (ctx: TrackingContext) => void;\n    /** Exit the current tracking context */\n    exit: () => void;\n    /** Stop and destroy a context, cleaning up all references */\n    stop: (ctx?: TrackingContext) => void;\n    /** Pause tracking in a context (nested pause supported) */\n    pause: (ctx?: TrackingContext) => void;\n    /** Resume tracking in a context */\n    resume: (ctx?: TrackingContext) => void;\n    /** Mark a promise as ignored (never tracked in any context) */\n    ignore: <T>(promise: T) => T;\n    /** Wait for all promises in a context to settle */\n    waitAll: (timeoutMs: number, ctx?: TrackingContext) => Promise<void>;\n    /** Get pending promise count for a context */\n    pending: (ctx?: TrackingContext) => number;\n    /** Get all active context IDs (for debugging) */\n    activeContexts: () => number[];\n}\n/**\n * Get the async tracking API from the global scope.\n * Returns undefined if not available (not running in NatStack panel/worker).\n */\nexport declare function getAsyncTracking(): AsyncTrackingAPI | undefined;\n/**\n * Check if async tracking is available in the current environment.\n */\nexport declare function hasAsyncTracking(): boolean;\n/**\n * Create a fallback async tracking API for testing or non-NatStack environments.\n * This implementation maintains the same API but doesn't actually track async operations.\n * Promises must be awaited manually.\n */\nexport declare function createFallbackAsyncTracking(): AsyncTrackingAPI;\n/**\n * Get the async tracking API, using the native implementation if available,\n * otherwise falling back to a no-op implementation.\n *\n * This allows code to use async tracking unconditionally without checking\n * for availability, but the caller should be aware that in fallback mode\n * async operations won't actually be tracked.\n */\nexport declare function getAsyncTrackingOrFallback(): AsyncTrackingAPI;\n//# sourceMappingURL=asyncTracking.d.ts.map",
      "consoleCapture.d.ts": "export interface ConsoleEntry {\n    level: \"log\" | \"warn\" | \"error\" | \"info\" | \"debug\";\n    args: unknown[];\n    timestamp: number;\n}\nexport interface ConsoleCapture {\n    /** Proxy console object to pass to executed code */\n    proxy: Console;\n    /** Get all captured entries */\n    getEntries(): ConsoleEntry[];\n    /** Subscribe to new entries (for streaming) */\n    onEntry(callback: (entry: ConsoleEntry) => void): () => void;\n}\nexport declare function createConsoleCapture(): ConsoleCapture;\n/**\n * Format a single console entry for streaming.\n */\nexport declare function formatConsoleEntry(entry: ConsoleEntry): string;\n/**\n * Format all console entries for final display.\n */\nexport declare function formatConsoleOutput(entries: ConsoleEntry[]): string;\n//# sourceMappingURL=consoleCapture.d.ts.map",
      "execute.d.ts": "/**\n * Execute CJS code with scope injection.\n */\nexport interface ExecuteOptions {\n    /** Additional bindings to inject into scope */\n    bindings?: Record<string, unknown>;\n    /** Console proxy for capturing output */\n    console?: Console;\n    /** Custom require function. If not provided, uses globalThis.__natstackRequire__ */\n    require?: (id: string) => unknown;\n}\nexport interface ExecuteResult {\n    /** The exports object (module.exports) */\n    exports: Record<string, unknown>;\n    /** The return value of the last expression (if any) */\n    returnValue: unknown;\n}\n/**\n * Get the default require function from the global scope.\n * Returns undefined if not available.\n */\nexport declare function getDefaultRequire(): ((id: string) => unknown) | undefined;\n/**\n * Get the async require function from the global scope.\n * Returns undefined if not available.\n */\nexport declare function getAsyncRequire(): ((id: string) => Promise<unknown>) | undefined;\n/**\n * Get the preload modules function from the global scope.\n * Returns undefined if not available.\n */\nexport declare function getPreloadModules(): ((ids: string[]) => Promise<unknown[]>) | undefined;\n/**\n * Result of validating module requires.\n */\nexport interface ValidateRequiresResult {\n    valid: boolean;\n    /** Missing module specifier (if invalid) */\n    missingModule?: string;\n    /** Error message (if invalid) */\n    error?: string;\n}\n/**\n * Validate that all required modules are available before execution.\n * This allows early failure with a descriptive error instead of runtime crashes.\n *\n * @param requires - Array of module specifiers to validate\n * @param requireFn - Optional custom require function (defaults to __natstackRequire__)\n * @returns Validation result with error details if invalid\n */\nexport declare function validateRequires(requires: string[], requireFn?: (id: string) => unknown): ValidateRequiresResult;\n/**\n * Result of preloading module requires.\n */\nexport interface PreloadRequiresResult {\n    success: boolean;\n    /** Module that failed to load (if unsuccessful) */\n    failedModule?: string;\n    /** Error message (if unsuccessful) */\n    error?: string;\n}\n/**\n * Preload all required modules asynchronously before execution.\n * Uses __natstackRequireAsync__ to load modules from CDN if not pre-bundled.\n *\n * @param requires - Array of module specifiers to preload\n * @returns Promise that resolves when all modules are loaded\n */\nexport declare function preloadRequires(requires: string[]): Promise<PreloadRequiresResult>;\nexport declare function execute(code: string, options?: ExecuteOptions): ExecuteResult;\n/**\n * Execute and extract the default export.\n * Useful for extracting components or other default-exported values.\n *\n * @returns The default export, or throws if none found\n */\nexport declare function executeDefault<T = unknown>(code: string, options?: ExecuteOptions): T;\n//# sourceMappingURL=execute.d.ts.map",
      "index.d.ts": "export { transformCode } from \"./transform.js\";\nexport type { TransformOptions, TransformResult } from \"./transform.js\";\nexport { execute, executeDefault, validateRequires, preloadRequires, getDefaultRequire, getAsyncRequire, getPreloadModules, } from \"./execute.js\";\nexport type { ExecuteOptions, ExecuteResult, ValidateRequiresResult, PreloadRequiresResult } from \"./execute.js\";\nexport { createConsoleCapture, formatConsoleEntry, formatConsoleOutput, } from \"./consoleCapture.js\";\nexport type { ConsoleCapture, ConsoleEntry } from \"./consoleCapture.js\";\nexport { getAsyncTracking, hasAsyncTracking, getAsyncTrackingOrFallback, createFallbackAsyncTracking, } from \"./asyncTracking.js\";\nexport type { TrackingContext, TrackingContextOptions, AsyncTrackingAPI, } from \"./asyncTracking.js\";\n//# sourceMappingURL=index.d.ts.map",
      "transform.d.ts": "export interface TransformOptions {\n    /** Source syntax: typescript, jsx, or tsx */\n    syntax: \"typescript\" | \"jsx\" | \"tsx\";\n}\nexport interface TransformResult {\n    code: string;\n    /** Module specifiers found in require() calls */\n    requires: string[];\n}\n/**\n * Transform TypeScript/TSX/JSX to CommonJS JavaScript using Sucrase.\n */\nexport declare function transformCode(source: string, options: TransformOptions): TransformResult;\n//# sourceMappingURL=transform.d.ts.map"
    },
    "subpaths": {}
  },
  "@natstack/git": {
    "files": {
      "bootstrap.d.ts": "import { type FsPromisesLike } from \"./client.js\";\nimport type { RepoArgSpec } from \"./types.js\";\n/**\n * Configuration for panel bootstrap\n */\nexport interface BootstrapConfig {\n    /** Git server URL */\n    serverUrl: string;\n    /** Auth token for git operations */\n    token: string;\n    /** Panel's source repo path (e.g., \"panels/my-panel\") */\n    sourceRepo: string;\n    /** Optional branch override for the source repo */\n    branch?: string;\n    /** Optional commit pin for the source repo */\n    commit?: string;\n    /** Optional tag pin for the source repo */\n    tag?: string;\n    /** Resolved repo args (name -> spec) provided by parent at createChild time */\n    repoArgs?: Record<string, RepoArgSpec>;\n    /** Path in OPFS for panel source (default: \"/src\") */\n    sourcePath?: string;\n    /** Path in OPFS for repo args (default: \"/args\") */\n    argsPath?: string;\n    /** Author info for commits */\n    author?: {\n        name: string;\n        email: string;\n    };\n}\n/**\n * Result of bootstrap operation\n */\nexport interface BootstrapResult {\n    /** Whether bootstrap succeeded */\n    success: boolean;\n    /** Path to panel source in OPFS */\n    sourcePath: string;\n    /** Current commit SHA of panel source (for cache key generation) */\n    sourceCommit?: string;\n    /** Map of repo arg name -> path in OPFS */\n    argPaths: Record<string, string>;\n    /** Map of repo arg name -> commit SHA (for cache key generation) */\n    argCommits: Record<string, string>;\n    /** Actions taken (cloned, pulled, unchanged) */\n    actions: {\n        source: \"cloned\" | \"pulled\" | \"unchanged\" | \"error\";\n        args: Record<string, \"cloned\" | \"updated\" | \"unchanged\" | \"error\">;\n    };\n    /** Error message if failed */\n    error?: string;\n}\n/**\n * Bootstrap a panel by cloning/pulling its source and repo args into OPFS.\n *\n * Usage:\n * ```typescript\n * import { bootstrap } from \"@natstack/git\";\n * import { fs } from \"@zenfs/core\";\n *\n * const config = await window.__natstackPanelBridge.git.getConfig();\n * const result = await bootstrap(fs, config);\n *\n * if (result.success) {\n *   // Panel source is now at result.sourcePath\n *   // Repo args are at result.argPaths\n * }\n * ```\n */\nexport declare function bootstrap(fs: FsPromisesLike, config: BootstrapConfig): Promise<BootstrapResult>;\nexport type { RepoArgSpec, NormalizedRepoArg } from \"./types.js\";\n//# sourceMappingURL=bootstrap.d.ts.map",
      "client.d.ts": "import type { GitClientOptions, CloneOptions, PullOptions, PushOptions, CommitOptions, RepoStatus, StashEntry, FileDiff, StageHunksOptions, BranchInfo, CreateBranchOptions, RemoteStatus, BlameLine, FileHistoryEntry, ConflictInfo, ConflictResolution } from \"./types.js\";\nexport declare class GitAuthError extends Error {\n    statusCode?: number;\n    constructor(message: string, statusCode?: number);\n}\n/**\n * Minimal fs/promises interface expected by GitClient.\n * Compatible with Node's fs/promises and @natstack/runtime's RuntimeFs.\n */\nexport interface FsPromisesLike {\n    readFile(path: string, encoding?: BufferEncoding): Promise<Uint8Array | string>;\n    writeFile(path: string, data: Uint8Array | string): Promise<void>;\n    unlink(path: string): Promise<void>;\n    readdir(path: string): Promise<string[]>;\n    mkdir(path: string, options?: {\n        recursive?: boolean;\n    }): Promise<string | undefined>;\n    rmdir(path: string): Promise<void>;\n    stat(path: string): Promise<{\n        isDirectory(): boolean;\n        isFile(): boolean;\n    }>;\n}\n/**\n * Git client for panel OPFS operations\n *\n * Wraps isomorphic-git with:\n * - Bearer token authentication for NatStack git server\n * - ZenFS filesystem integration (automatically adapts fs/promises)\n * - Simplified API for common operations\n *\n * @example\n * ```typescript\n * import { promises as fsPromises } from \"fs\";\n * const git = new GitClient(fsPromises, { serverUrl, token });\n * ```\n */\nexport declare class GitClient {\n    private fs;\n    private fsPromises;\n    private http;\n    private serverUrl;\n    private author;\n    constructor(fs: FsPromisesLike, options: GitClientOptions);\n    /**\n     * Resolve a repo path to a full URL\n     * - Absolute URLs pass through unchanged\n     * - Relative paths are resolved against the git server\n     */\n    resolveUrl(repoPath: string): string;\n    /**\n     * Clone a repository\n     */\n    clone(options: CloneOptions): Promise<void>;\n    /**\n     * Pull latest changes from remote\n     */\n    pull(options: PullOptions): Promise<void>;\n    /**\n     * Fetch without merging\n     */\n    fetch(options: {\n        dir: string;\n        remote?: string;\n        ref?: string;\n    }): Promise<void>;\n    /**\n     * Push changes to remote\n     */\n    push(options: PushOptions): Promise<void>;\n    /**\n     * Stage a file for commit\n     * Handles deleted files by using git.remove() instead of git.add()\n     */\n    add(dir: string, filepath: string): Promise<void>;\n    /**\n     * Stage all changes\n     */\n    addAll(dir: string): Promise<void>;\n    /**\n     * Create a commit\n     */\n    commit(options: CommitOptions): Promise<string>;\n    /**\n     * Get repository status\n     */\n    status(dir: string): Promise<RepoStatus>;\n    /**\n     * Checkout a ref (branch, tag, or commit)\n     */\n    checkout(dir: string, ref: string): Promise<void>;\n    /**\n     * Get the current commit hash\n     */\n    getCurrentCommit(dir: string): Promise<string | null>;\n    /**\n     * Get the current branch name\n     */\n    getCurrentBranch(dir: string): Promise<string | null>;\n    /**\n     * Check if a directory is a git repository\n     */\n    isRepo(dir: string): Promise<boolean>;\n    /**\n     * Initialize a new repository\n     */\n    init(dir: string, defaultBranch?: string): Promise<void>;\n    /**\n     * Add a remote\n     */\n    addRemote(dir: string, name: string, url: string): Promise<void>;\n    /**\n     * List remotes\n     */\n    listRemotes(dir: string): Promise<Array<{\n        remote: string;\n        url: string;\n    }>>;\n    /**\n     * List local or remote branches\n     */\n    listBranches(dir: string, options?: {\n        remote?: boolean;\n    }): Promise<BranchInfo[]>;\n    /**\n     * Create a branch\n     */\n    createBranch(options: CreateBranchOptions): Promise<void>;\n    /**\n     * Delete a branch\n     */\n    deleteBranch(dir: string, name: string): Promise<void>;\n    private getUpstreamConfig;\n    /**\n     * Get ahead/behind counts against upstream\n     */\n    getBranchTracking(dir: string, branch: string): Promise<{\n        ahead: number;\n        behind: number;\n    } | null>;\n    /**\n     * Get remote status for current branch\n     */\n    getRemoteStatus(dir: string): Promise<RemoteStatus | null>;\n    /**\n     * Get log of commits\n     */\n    log(dir: string, options?: {\n        depth?: number;\n        ref?: string;\n    }): Promise<Array<{\n        oid: string;\n        message: string;\n        author: {\n            name: string;\n            email: string;\n            timestamp: number;\n        };\n    }>>;\n    /**\n     * Blame a file (line-by-line attribution)\n     */\n    blame(dir: string, filepath: string, ref?: string): Promise<BlameLine[]>;\n    /**\n     * Get commit history for a file\n     */\n    getFileHistory(dir: string, filepath: string, options?: {\n        depth?: number;\n    }): Promise<FileHistoryEntry[]>;\n    /**\n     * Read file content from a git ref (commit, HEAD, branch, tag)\n     */\n    private readFromRef;\n    /**\n     * Read file content from the git index (staging area)\n     */\n    private readFromIndex;\n    /**\n     * Read file content from the working tree (filesystem)\n     */\n    private readFromWorkingTree;\n    /**\n     * Build a FileDiff from old and new content results\n     */\n    private buildDiff;\n    /**\n     * Get file content at a specific ref (for diff \"old\" side)\n     * @deprecated Use readFromRef internally; kept for backwards compatibility\n     */\n    show(dir: string, filepath: string, ref?: string): Promise<string>;\n    /**\n     * Get diff for a file (unstaged changes - working tree vs index/HEAD)\n     */\n    getWorkingDiff(dir: string, filepath: string): Promise<FileDiff>;\n    /**\n     * Get diff for a staged file (index vs HEAD)\n     */\n    getStagedDiff(dir: string, filepath: string): Promise<FileDiff>;\n    /**\n     * Unstage a file (git reset HEAD <file>)\n     */\n    unstage(dir: string, filepath: string): Promise<void>;\n    /**\n     * Stage selected hunks/lines for a file\n     */\n    stageHunks(options: StageHunksOptions): Promise<void>;\n    /**\n     * Unstage selected hunks/lines for a file\n     */\n    unstageHunks(options: StageHunksOptions): Promise<void>;\n    /**\n     * Discard working tree changes (git checkout -- <file>)\n     * For files with staged changes: restores from index (staged version)\n     * For files without staged changes: restores from HEAD\n     * For untracked/new files: deletes the file and unstages if staged\n     */\n    discardChanges(dir: string, filepath: string): Promise<void>;\n    /**\n     * List conflicted files with parsed markers\n     */\n    getConflicts(dir: string): Promise<ConflictInfo[]>;\n    /**\n     * Resolve a conflict by writing the resolved content and staging it\n     */\n    resolveConflict(dir: string, resolution: ConflictResolution): Promise<void>;\n    /**\n     * Get additions/deletions count for status display\n     */\n    getFileStats(dir: string, filepath: string, staged: boolean): Promise<{\n        additions: number;\n        deletions: number;\n    }>;\n    /**\n     * Create a stash using isomorphic-git.\n     * Note: isomorphic-git only stashes tracked files (untracked files are not stashed).\n     */\n    stash(dir: string, options?: {\n        message?: string;\n        includeUntracked?: boolean;\n    }): Promise<void>;\n    /**\n     * List stashes using isomorphic-git.\n     */\n    stashList(dir: string): Promise<StashEntry[]>;\n    /**\n     * Apply a stash without dropping it.\n     */\n    stashApply(dir: string, index?: number): Promise<void>;\n    /**\n     * Pop a stash (apply + drop).\n     */\n    stashPop(dir: string, index?: number): Promise<void>;\n    /**\n     * Drop a stash entry.\n     */\n    stashDrop(dir: string, index?: number): Promise<void>;\n    /**\n     * Get list of files changed in a specific commit\n     */\n    getCommitFiles(dir: string, sha: string): Promise<Array<{\n        path: string;\n        status: \"added\" | \"modified\" | \"deleted\";\n    }>>;\n    /**\n     * Get diff for a file in a commit compared to its parent\n     */\n    getCommitDiff(dir: string, sha: string, filepath: string): Promise<FileDiff>;\n}\n//# sourceMappingURL=client.d.ts.map",
      "index.d.ts": "/**\n * @natstack/git - Git operations for NatStack panels\n *\n * Provides git clone/pull/push operations using isomorphic-git,\n * designed to work with ZenFS OPFS backend in browser panels.\n *\n * Usage:\n * ```typescript\n * import { GitClient } from \"@natstack/git\";\n * import { promises as fsPromises } from \"fs\"; // ZenFS-shimmed in panels\n *\n * // Create git client - pass fs/promises directly\n * const git = new GitClient(fsPromises, {\n *   serverUrl: \"http://localhost:63524\",\n *   token: \"your-token\",\n * });\n *\n * // Clone a repository\n * await git.clone({\n *   url: \"panels/my-panel\",\n *   dir: \"/src\",\n *   ref: \"main\",\n * });\n *\n * // Make changes and push\n * await git.addAll(\"/src\");\n * await git.commit({ dir: \"/src\", message: \"Update\" });\n * await git.push({ dir: \"/src\" });\n * ```\n */\nexport { GitClient, GitAuthError, type FsPromisesLike } from \"./client.js\";\nexport { bootstrap } from \"./bootstrap.js\";\nexport type { RepoArgSpec, NormalizedRepoArg, GitClientOptions, CloneOptions, PullOptions, PushOptions, CommitOptions, FileStatus, RepoStatus, StashEntry, FileDiff, Hunk, DiffLine, HunkSelection, StageHunksOptions, BranchInfo, CreateBranchOptions, RemoteStatus, GitProgress, BlameLine, FileHistoryEntry, BinaryDiffInfo, ImageDiff, ConflictInfo, ConflictMarker, ConflictResolution, } from \"./types.js\";\nexport type { BootstrapConfig, BootstrapResult } from \"./bootstrap.js\";\n//# sourceMappingURL=index.d.ts.map",
      "types.d.ts": "/**\n * Repo argument specification for createChild.\n * Can be a shorthand string or full object.\n *\n * Shorthand formats:\n * - \"panels/shared\" - defaults to main/master branch\n * - \"panels/shared#develop\" - specific branch\n * - \"panels/shared@v1.0.0\" - specific tag\n * - \"panels/shared@abc123\" - specific commit (7+ hex chars)\n */\nexport type RepoArgSpec = string | {\n    /** Git repository path relative to workspace (e.g., \"panels/shared\") */\n    repo: string;\n    /** Branch, tag, or commit hash to checkout */\n    ref?: string;\n};\n/**\n * Normalized repo arg after parsing shorthand\n */\nexport interface NormalizedRepoArg {\n    /** Name/key of this repo arg */\n    name: string;\n    /** Repository path */\n    repo: string;\n    /** Ref to checkout (branch, tag, or commit) */\n    ref?: string;\n    /** Resolved absolute URL for cloning */\n    resolvedUrl: string;\n    /** Path in OPFS where this will be cloned (/args/<name>) */\n    localPath: string;\n}\n/**\n * Options for git operations\n */\nexport interface GitClientOptions {\n    /** Git server base URL (e.g., http://localhost:63524) */\n    serverUrl: string;\n    /** Bearer token for authentication */\n    token: string;\n    /** Author info for commits */\n    author?: {\n        name: string;\n        email: string;\n    };\n}\n/**\n * Clone options\n */\nexport interface CloneOptions {\n    /** Repository URL */\n    url: string;\n    /** Local directory path in OPFS */\n    dir: string;\n    /** Branch/tag/commit to checkout */\n    ref?: string;\n    /** Clone only the specified branch (default: true) */\n    singleBranch?: boolean;\n    /** Shallow clone depth (default: 1 for faster clones) */\n    depth?: number;\n}\n/**\n * Pull options\n */\nexport interface PullOptions {\n    /** Local directory path */\n    dir: string;\n    /** Remote name (default: 'origin') */\n    remote?: string;\n    /** Branch to pull (default: current branch) */\n    ref?: string;\n    /** Author info for merge commit if needed */\n    author?: {\n        name: string;\n        email: string;\n    };\n    /** Progress callback */\n    onProgress?: (progress: GitProgress) => void;\n}\n/**\n * Push options\n */\nexport interface PushOptions {\n    /** Local directory path */\n    dir: string;\n    /** Remote name (default: 'origin') */\n    remote?: string;\n    /** Branch to push (default: current branch) */\n    ref?: string;\n    /** Force push (use with caution) */\n    force?: boolean;\n    /** Progress callback */\n    onProgress?: (progress: GitProgress) => void;\n}\n/**\n * Commit options\n */\nexport interface CommitOptions {\n    /** Local directory path */\n    dir: string;\n    /** Commit message */\n    message: string;\n    /** Author info (uses client default if not provided) */\n    author?: {\n        name: string;\n        email: string;\n    };\n}\n/**\n * Status result for a file\n */\nexport interface FileStatus {\n    /** File path relative to repo root */\n    path: string;\n    /** Overall status (union of index + working tree state) */\n    status: 'unmodified' | 'modified' | 'added' | 'deleted' | 'untracked' | 'ignored';\n    /** Whether there are staged (index) changes for this path */\n    staged: boolean;\n    /** Whether there are unstaged (working tree) changes for this path */\n    unstaged: boolean;\n}\n/**\n * Repository status\n */\nexport interface RepoStatus {\n    /** Current branch name */\n    branch: string | null;\n    /** Current commit hash */\n    commit: string | null;\n    /** Whether there are uncommitted changes */\n    dirty: boolean;\n    /** File statuses */\n    files: FileStatus[];\n}\nexport interface StashEntry {\n    /** Stash index (stash@{index}) */\n    index: number;\n    /** Full ref name (e.g., \"stash@{0}\") */\n    ref: string;\n    /** Stash message */\n    message: string;\n    /** Unix timestamp (seconds) if available */\n    timestamp?: number;\n}\n/**\n * File diff information\n */\nexport interface FileDiff {\n    /** File path */\n    path: string;\n    /** Content before changes (from HEAD or index) */\n    oldContent: string;\n    /** Content after changes */\n    newContent: string;\n    /** Diff hunks */\n    hunks: Hunk[];\n    /** Whether file is binary */\n    binary: boolean;\n    /** Binary file metadata when binary is true */\n    binaryInfo?: BinaryDiffInfo;\n    /** Image preview data when binary is true and file is an image */\n    imageDiff?: ImageDiff;\n}\n/**\n * A hunk in a diff\n */\nexport interface Hunk {\n    /** Hunk header (e.g., \"@@ -10,5 +10,7 @@\") */\n    header: string;\n    /** Start line in old file */\n    oldStart: number;\n    /** Number of lines in old file */\n    oldLines: number;\n    /** Start line in new file */\n    newStart: number;\n    /** Number of lines in new file */\n    newLines: number;\n    /** Lines in this hunk */\n    lines: DiffLine[];\n}\n/**\n * A line in a diff\n */\nexport interface DiffLine {\n    /** Line type */\n    type: \"context\" | \"add\" | \"delete\";\n    /** Line content */\n    content: string;\n    /** Line number in old file */\n    oldLineNo?: number;\n    /** Line number in new file */\n    newLineNo?: number;\n}\nexport interface HunkSelection {\n    hunkIndex: number;\n    /** Line indices in the hunk (0-based). Undefined = entire hunk. */\n    lineIndices?: number[];\n}\nexport interface StageHunksOptions {\n    dir: string;\n    filepath: string;\n    hunks: HunkSelection[];\n}\nexport interface BranchInfo {\n    name: string;\n    current: boolean;\n    remote?: string;\n    upstream?: string;\n    ahead?: number;\n    behind?: number;\n}\nexport interface CreateBranchOptions {\n    dir: string;\n    name: string;\n    startPoint?: string;\n    checkout?: boolean;\n}\nexport interface RemoteStatus {\n    ahead: number;\n    behind: number;\n    diverged: boolean;\n    remote: string;\n    remoteBranch: string;\n}\nexport interface GitProgress {\n    phase: string;\n    loaded: number;\n    total: number;\n}\nexport interface BlameLine {\n    lineNumber: number;\n    content: string;\n    commit: string;\n    author: string;\n    email: string;\n    timestamp: number;\n    summary: string;\n}\nexport interface FileHistoryEntry {\n    commit: string;\n    author: {\n        name: string;\n        email: string;\n        timestamp: number;\n    };\n    message: string;\n    diff?: FileDiff;\n}\nexport interface BinaryDiffInfo {\n    oldSize: number;\n    newSize: number;\n    sizeDelta: number;\n    mimeType?: string;\n    isImage: boolean;\n}\nexport interface ImageDiff {\n    oldDataUrl?: string;\n    newDataUrl?: string;\n    oldDimensions?: {\n        width: number;\n        height: number;\n    };\n    newDimensions?: {\n        width: number;\n        height: number;\n    };\n}\nexport interface ConflictInfo {\n    path: string;\n    /** Original file content including conflict markers */\n    original?: string;\n    base: string;\n    ours: string;\n    theirs: string;\n    markers: ConflictMarker[];\n}\nexport interface ConflictMarker {\n    startLine: number;\n    endLine: number;\n    oursStart: number;\n    oursEnd: number;\n    theirsStart: number;\n    theirsEnd: number;\n}\nexport interface ConflictResolution {\n    path: string;\n    content: string;\n}\n//# sourceMappingURL=types.d.ts.map"
    },
    "subpaths": {}
  },
  "@natstack/git-ui": {
    "files": {
      "AuthErrorDialog.d.ts": "export interface AuthErrorDialogProps {\n    open: boolean;\n    onOpenChange: (open: boolean) => void;\n    message?: string;\n}\nexport declare function AuthErrorDialog({ open, onOpenChange, message }: AuthErrorDialogProps): import(\"react/jsx-runtime\").JSX.Element;\n//# sourceMappingURL=AuthErrorDialog.d.ts.map",
      "BlameView.d.ts": "import type { BlameLine } from \"@natstack/git\";\ninterface BlameViewProps {\n    content: string;\n    blame: BlameLine[];\n    theme?: \"light\" | \"dark\";\n}\nexport declare function BlameView({ content, blame, theme }: BlameViewProps): import(\"react/jsx-runtime\").JSX.Element;\nexport {};\n//# sourceMappingURL=BlameView.d.ts.map",
      "BranchSelector.d.ts": "interface BranchSelectorProps {\n    currentBranch?: string | null;\n}\nexport declare function BranchSelector({ currentBranch }: BranchSelectorProps): import(\"react/jsx-runtime\").JSX.Element;\nexport {};\n//# sourceMappingURL=BranchSelector.d.ts.map",
      "CommitForm.d.ts": "export interface CommitFormProps {\n    onCommit: (message: string) => Promise<void>;\n    onCancel?: () => void;\n    disabled?: boolean;\n    loading?: boolean;\n}\n/**\n * Commit message form with textarea and submit button\n */\nexport declare function CommitForm({ onCommit, onCancel, disabled, loading }: CommitFormProps): import(\"react/jsx-runtime\").JSX.Element;\n//# sourceMappingURL=CommitForm.d.ts.map",
      "CommitHistory.d.ts": "import type { CommitEntry } from \"./store\";\nimport type { FileDiff } from \"@natstack/git\";\nimport type { DiffViewOptions } from \"./DiffBlock/types\";\nexport interface CommitHistoryProps {\n    commits: CommitEntry[];\n    loading?: boolean;\n    hasMore?: boolean;\n    onLoadMore?: () => void;\n    getCommitFiles?: (sha: string) => Promise<Array<{\n        path: string;\n        status: \"added\" | \"modified\" | \"deleted\";\n    }>>;\n    getCommitDiff?: (sha: string, path: string, options?: {\n        force?: boolean;\n    }) => Promise<FileDiff | null>;\n    theme?: \"light\" | \"dark\";\n    diffViewOptions?: DiffViewOptions;\n    showDiffControls?: boolean;\n}\n/**\n * List of commit entries with expandable inline diffs\n */\nexport declare function CommitHistory({ commits, loading, hasMore, onLoadMore, getCommitFiles, getCommitDiff, theme, diffViewOptions, showDiffControls, }: CommitHistoryProps): import(\"react/jsx-runtime\").JSX.Element;\n//# sourceMappingURL=CommitHistory.d.ts.map",
      "CompactHeader.d.ts": "export interface CompactHeaderProps {\n    commitMessage: string;\n    onCommitMessageChange: (message: string) => void;\n    onCommit: () => void;\n    onExpand: () => void;\n    hasStaged: boolean;\n    loading: boolean;\n}\nexport declare function CompactHeader({ commitMessage, onCommitMessageChange, onCommit, onExpand, hasStaged, loading, }: CompactHeaderProps): import(\"react/jsx-runtime\").JSX.Element;\n//# sourceMappingURL=CompactHeader.d.ts.map",
      "ConflictMarkerButtons.d.ts": "import type { ConflictMarker } from \"@natstack/git\";\ninterface ConflictMarkerButtonsProps {\n    index: number;\n    marker?: ConflictMarker;\n    onSelect: (choice: \"ours\" | \"theirs\" | \"both\") => void;\n}\nexport declare function ConflictMarkerButtons({ index, marker, onSelect }: ConflictMarkerButtonsProps): import(\"react/jsx-runtime\").JSX.Element;\nexport {};\n//# sourceMappingURL=ConflictMarkerButtons.d.ts.map",
      "ConflictResolutionView.d.ts": "interface ConflictResolutionViewProps {\n    theme?: \"light\" | \"dark\";\n}\nexport declare function ConflictResolutionView({ theme }: ConflictResolutionViewProps): import(\"react/jsx-runtime\").JSX.Element;\nexport {};\n//# sourceMappingURL=ConflictResolutionView.d.ts.map",
      "CreateBranchDialog.d.ts": "import type { BranchInfo } from \"@natstack/git\";\nexport interface CreateBranchDialogProps {\n    open: boolean;\n    onOpenChange: (open: boolean) => void;\n    onCreate: (options: {\n        name: string;\n        startPoint?: string;\n        checkout?: boolean;\n    }) => Promise<void>;\n    branches: BranchInfo[];\n    remoteBranches: BranchInfo[];\n}\nexport declare function CreateBranchDialog({ open, onOpenChange, onCreate, branches, remoteBranches, }: CreateBranchDialogProps): import(\"react/jsx-runtime\").JSX.Element;\n//# sourceMappingURL=CreateBranchDialog.d.ts.map",
      "CreateFileDialog.d.ts": "export interface CreateFileDialogProps {\n    open: boolean;\n    onOpenChange: (open: boolean) => void;\n    parentPath: string | null;\n    onCreate: (name: string, isDirectory: boolean) => Promise<void>;\n    loading?: boolean;\n}\nexport declare function CreateFileDialog({ open, onOpenChange, parentPath, onCreate, loading, }: CreateFileDialogProps): import(\"react/jsx-runtime\").JSX.Element;\n//# sourceMappingURL=CreateFileDialog.d.ts.map",
      "DeleteConfirmDialog.d.ts": "export interface DeleteConfirmDialogProps {\n    open: boolean;\n    onOpenChange: (open: boolean) => void;\n    targetPath: string;\n    isDirectory: boolean;\n    onConfirm: () => Promise<void>;\n    loading?: boolean;\n}\nexport declare function DeleteConfirmDialog({ open, onOpenChange, targetPath, isDirectory, onConfirm, loading, }: DeleteConfirmDialogProps): import(\"react/jsx-runtime\").JSX.Element;\n//# sourceMappingURL=DeleteConfirmDialog.d.ts.map",
      "DiffBlock/BinaryFileDiff.d.ts": "import type { FileDiff } from \"./types\";\ninterface BinaryFileDiffProps {\n    diff: FileDiff;\n}\nexport declare function BinaryFileDiff({ diff }: BinaryFileDiffProps): import(\"react/jsx-runtime\").JSX.Element;\nexport {};\n//# sourceMappingURL=BinaryFileDiff.d.ts.map",
      "DiffBlock/DiffBlock.d.ts": "import type { DiffBlockProps } from \"./types\";\nexport declare function DiffBlock({ files, getDiff, refreshId, title, summary, collapsible, defaultCollapsed, showFileTree, defaultTreeVisible, filter: externalFilter, onFilterChange: externalOnFilterChange, largeDiffThreshold, largeFolderThreshold, onStageFile, onStageHunks, onUnstageFile, onUnstageHunks, onDiscardFile, editable, onSaveEdit, onCopyPath, focusedPath, partiallyStagedFiles, theme, diffType, pendingFiles, showDiffControls, diffViewOptions, onDiffViewOptionsChange, diffKey, onCreateFile, onDeleteFile, }: DiffBlockProps): import(\"react/jsx-runtime\").JSX.Element;\n//# sourceMappingURL=DiffBlock.d.ts.map",
      "DiffBlock/DiffEditorDirect.d.ts": "import type { editor } from \"modern-monaco/editor-core\";\nexport interface DiffEditorDirectProps {\n    original: string;\n    modified: string;\n    language?: string;\n    theme?: \"light\" | \"vs-dark\";\n    options?: editor.IDiffEditorConstructionOptions;\n    onMount?: (editor: editor.IStandaloneDiffEditor) => void;\n    onModifiedChange?: (value: string) => void;\n}\n/**\n * A DiffEditor component that uses Monaco's API directly via modern-monaco.\n *\n * This replaces @monaco-editor/react's DiffEditor to fix a disposal bug\n * where models are disposed before the DiffEditorWidget is reset.\n * See: https://github.com/suren-atoyan/monaco-react/issues/647\n *\n * Key fix: We control disposal order:\n * 1. Dispose event listeners\n * 2. Dispose the editor\n * 3. Dispose models (last)\n */\nexport declare function DiffEditorDirect({ original, modified, language, theme, options, onMount, onModifiedChange, }: DiffEditorDirectProps): import(\"react/jsx-runtime\").JSX.Element;\n//# sourceMappingURL=DiffEditorDirect.d.ts.map",
      "DiffBlock/DiffStack.d.ts": "import type { HunkSelection } from \"@natstack/git\";\nimport type { DiffViewOptions, FileChange, FileDiff as FileDiffType } from \"./types\";\ninterface DiffStackProps {\n    files: FileChange[];\n    getDiff: (path: string, options?: {\n        force?: boolean;\n    }) => Promise<FileDiffType | null>;\n    refreshId?: number;\n    selectedFiles: Set<string>;\n    expandedFiles: Set<string>;\n    onToggleExpand: (path: string) => void;\n    largeDiffThreshold: number;\n    onStageFile?: (path: string) => void;\n    onStageHunks?: (path: string, hunks: HunkSelection[]) => void;\n    onUnstageFile?: (path: string) => void;\n    onUnstageHunks?: (path: string, hunks: HunkSelection[]) => void;\n    onDiscardFile?: (path: string) => void;\n    editable: boolean;\n    onSaveEdit?: (path: string, content: string) => Promise<void>;\n    partiallyStagedFiles?: Set<string>;\n    focusedFile?: string | null;\n    theme?: \"light\" | \"dark\";\n    /** Whether this is staged or working diff (for cache key lookup) */\n    diffType?: \"staged\" | \"working\";\n    /** Optional cache key override */\n    diffKey?: (path: string) => string;\n    /** Whether to show diff view controls */\n    showControls?: boolean;\n    diffViewOptions?: DiffViewOptions;\n    onDiffViewOptionsChange?: (options: DiffViewOptions) => void;\n}\nexport declare function DiffStack({ files, getDiff, refreshId, selectedFiles, expandedFiles, onToggleExpand, largeDiffThreshold, onStageFile, onStageHunks, onUnstageFile, onUnstageHunks, onDiscardFile, editable, onSaveEdit, partiallyStagedFiles, focusedFile, theme, diffType, diffKey, showControls, diffViewOptions, onDiffViewOptionsChange, }: DiffStackProps): import(\"react/jsx-runtime\").JSX.Element;\nexport {};\n//# sourceMappingURL=DiffStack.d.ts.map",
      "DiffBlock/DiffViewControls.d.ts": "import type { DiffViewOptions } from \"./types\";\ninterface DiffViewControlsProps {\n    options: DiffViewOptions;\n    onChange: (next: DiffViewOptions) => void;\n}\nexport declare function DiffViewControls({ options, onChange }: DiffViewControlsProps): import(\"react/jsx-runtime\").JSX.Element;\nexport {};\n//# sourceMappingURL=DiffViewControls.d.ts.map",
      "DiffBlock/FileContentView.d.ts": "import type { FileChange } from \"./types\";\ninterface FileContentViewProps {\n    file: FileChange;\n    content: string;\n    isDeleted?: boolean;\n    theme?: \"light\" | \"dark\";\n    onStageFile?: (path: string) => void;\n    onUnstageFile?: (path: string) => void;\n    onDiscardFile?: (path: string) => void;\n}\nexport declare function FileContentView({ file, content, isDeleted, theme, onStageFile, onUnstageFile, onDiscardFile, }: FileContentViewProps): import(\"react/jsx-runtime\").JSX.Element;\nexport {};\n//# sourceMappingURL=FileContentView.d.ts.map",
      "DiffBlock/FileDiff.d.ts": "import type { DiffViewOptions, FileChange, FileDiff as FileDiffType, HunkSelection } from \"./types\";\ninterface FileDiffProps {\n    file: FileChange;\n    diff: FileDiffType;\n    onStageFile?: (path: string) => void;\n    onStageHunks?: (path: string, hunks: HunkSelection[]) => void;\n    onUnstageFile?: (path: string) => void;\n    onUnstageHunks?: (path: string, hunks: HunkSelection[]) => void;\n    onDiscardFile?: (path: string) => void;\n    editable: boolean;\n    onSaveEdit?: (path: string, content: string) => Promise<void>;\n    partiallyStaged?: boolean;\n    theme?: \"light\" | \"dark\";\n    diffViewOptions?: DiffViewOptions;\n}\nexport declare function FileDiff({ file, diff, onStageFile, onStageHunks, onUnstageFile, onUnstageHunks, onDiscardFile, editable, onSaveEdit, partiallyStaged, theme, diffViewOptions, }: FileDiffProps): import(\"react/jsx-runtime\").JSX.Element;\nexport {};\n//# sourceMappingURL=FileDiff.d.ts.map",
      "DiffBlock/FileDiffHeader.d.ts": "import type { FileChange } from \"./types\";\nexport interface FileDiffHeaderProps {\n    file: FileChange;\n    onStageFile?: (path: string) => void;\n    onUnstageFile?: (path: string) => void;\n    onDiscardFile?: (path: string) => void;\n    stats?: {\n        additions: number;\n        deletions: number;\n    } | null;\n    editable?: boolean;\n    isEditing?: boolean;\n    onToggleEdit?: () => void;\n    onSave?: () => void;\n    hasChanges?: boolean;\n    saving?: boolean;\n    partiallyStaged?: boolean;\n    selectionMode?: boolean;\n    onToggleSelection?: () => void;\n}\nexport declare function FileDiffHeader({ file, onStageFile, onUnstageFile, onDiscardFile, stats, editable, isEditing, onToggleEdit, onSave, hasChanges, saving, partiallyStaged, selectionMode, onToggleSelection, }: FileDiffHeaderProps): import(\"react/jsx-runtime\").JSX.Element;\n//# sourceMappingURL=FileDiffHeader.d.ts.map",
      "DiffBlock/FileSearchBar.d.ts": "import type { FileFilter, FileChange } from \"./types\";\ninterface CompactFileSearchProps {\n    filter: FileFilter;\n    onFilterChange: (next: FileFilter) => void;\n    statusCounts: Record<FileChange[\"status\"], number>;\n}\n/**\n * Compact inline search for file tree header.\n * Always visible, expands to fill available width.\n * Only shows status options that have files, hides filter buttons if only one status.\n */\nexport declare function CompactFileSearch({ filter, onFilterChange, statusCounts, }: CompactFileSearchProps): import(\"react/jsx-runtime\").JSX.Element;\nexport {};\n//# sourceMappingURL=FileSearchBar.d.ts.map",
      "DiffBlock/FileTree.d.ts": "import type { FileChange } from \"./types\";\nexport interface FileTreeContextMenuActions {\n    onStageFile?: (path: string) => void;\n    onUnstageFile?: (path: string) => void;\n    onDiscardFile?: (path: string) => void;\n    onCopyPath?: (path: string) => void;\n    onCreateFile?: (parentPath: string | null) => void;\n    onDeleteFile?: (path: string, isDirectory: boolean) => void;\n}\ninterface FileTreeProps {\n    files: FileChange[];\n    selectedFiles: Set<string>;\n    onSelect: (path: string, event: React.MouseEvent) => void;\n    largeFolderThreshold: number;\n    contextMenuActions?: FileTreeContextMenuActions;\n    /** Path of keyboard-focused file for visual indication */\n    focusedPath?: string | null;\n    /** Set of file paths with pending operations (show loading spinner) */\n    pendingFiles?: Set<string>;\n    /** Highlight matches for search */\n    highlightQuery?: string;\n    /** Set of file paths that are partially staged (show indicator) */\n    partiallyStagedFiles?: Set<string>;\n}\nexport declare function FileTree({ files, selectedFiles, onSelect, largeFolderThreshold, contextMenuActions, focusedPath, pendingFiles, highlightQuery, partiallyStagedFiles, }: FileTreeProps): import(\"react/jsx-runtime\").JSX.Element;\nexport {};\n//# sourceMappingURL=FileTree.d.ts.map",
      "DiffBlock/HunkHeader.d.ts": "import type { Hunk } from \"./types\";\ninterface HunkHeaderProps {\n    hunk: Hunk;\n    selected: boolean;\n    indeterminate: boolean;\n    additions: number;\n    deletions: number;\n    onToggle: () => void;\n    onStage?: () => void;\n    onUnstage?: () => void;\n}\nexport declare function HunkHeader({ hunk, selected, indeterminate, additions, deletions, onToggle, onStage, onUnstage, }: HunkHeaderProps): import(\"react/jsx-runtime\").JSX.Element;\nexport {};\n//# sourceMappingURL=HunkHeader.d.ts.map",
      "DiffBlock/ImageCompare.d.ts": "interface ImageCompareProps {\n    oldDataUrl?: string;\n    newDataUrl?: string;\n    oldLabel?: string;\n    newLabel?: string;\n}\nexport declare function ImageCompare({ oldDataUrl, newDataUrl, oldLabel, newLabel }: ImageCompareProps): import(\"react/jsx-runtime\").JSX.Element;\nexport {};\n//# sourceMappingURL=ImageCompare.d.ts.map",
      "DiffBlock/LargeDiffGuard.d.ts": "import type { FileChange, FileDiff } from \"./types\";\ninterface LargeDiffGuardProps {\n    file: FileChange;\n    diff: FileDiff;\n    onExpand: () => void;\n    onStageFile?: (path: string) => void;\n    onUnstageFile?: (path: string) => void;\n    onDiscardFile?: (path: string) => void;\n}\nexport declare function LargeDiffGuard({ file, diff, onExpand, onStageFile, onUnstageFile, onDiscardFile, }: LargeDiffGuardProps): import(\"react/jsx-runtime\").JSX.Element;\nexport {};\n//# sourceMappingURL=LargeDiffGuard.d.ts.map",
      "DiffBlock/LineSelectionOverlay.d.ts": "import type { Hunk } from \"./types\";\ninterface LineSelectionOverlayProps {\n    hunk: Hunk;\n    hunkIndex: number;\n    selectedLines?: Set<number> | null;\n    onToggleLine: (hunkIndex: number, lineIndex: number) => void;\n}\nexport declare function LineSelectionOverlay({ hunk, hunkIndex, selectedLines, onToggleLine }: LineSelectionOverlayProps): import(\"react/jsx-runtime\").JSX.Element;\nexport {};\n//# sourceMappingURL=LineSelectionOverlay.d.ts.map",
      "DiffBlock/index.d.ts": "export { DiffBlock } from \"./DiffBlock\";\nexport { FileTree, type FileTreeContextMenuActions } from \"./FileTree\";\nexport { DiffStack } from \"./DiffStack\";\nexport { FileDiff } from \"./FileDiff\";\nexport { DiffEditorDirect, type DiffEditorDirectProps } from \"./DiffEditorDirect\";\nexport { FileDiffHeader, type FileDiffHeaderProps } from \"./FileDiffHeader\";\nexport { LargeDiffGuard } from \"./LargeDiffGuard\";\nexport { DiffViewControls } from \"./DiffViewControls\";\nexport { HunkHeader } from \"./HunkHeader\";\nexport { LineSelectionOverlay } from \"./LineSelectionOverlay\";\nexport { BinaryFileDiff } from \"./BinaryFileDiff\";\nexport { ImageCompare } from \"./ImageCompare\";\nexport { CompactFileSearch } from \"./FileSearchBar\";\nexport type { DiffBlockProps, FileChange, FileDiff as FileDiffType, Hunk, DiffLine, DiffViewOptions, FileFilter, } from \"./types\";\n//# sourceMappingURL=index.d.ts.map",
      "DiffBlock/types.d.ts": "import type { ReactNode } from \"react\";\nimport type { HunkSelection, FileDiff } from \"@natstack/git\";\nimport type { UIFileStatus, FileChange } from \"../store/types\";\nexport type { FileDiff, Hunk, DiffLine, HunkSelection } from \"@natstack/git\";\nexport type { UIFileStatus, FileChange } from \"../store/types\";\n/** Status badge labels - single letter abbreviations */\nexport declare const STATUS_LABELS: Record<UIFileStatus, string>;\n/** Semantic colors for file status badges */\nexport declare const STATUS_COLORS: Record<UIFileStatus, \"green\" | \"yellow\" | \"red\" | \"blue\" | \"gray\">;\nexport interface DiffViewOptions {\n    viewMode: \"split\" | \"unified\";\n    wordDiff: boolean;\n    showWhitespace: boolean;\n    contextLines: number;\n}\nexport interface FileFilter {\n    search: string;\n    status: UIFileStatus[] | null;\n}\nexport interface DiffBlockProps {\n    files: FileChange[];\n    getDiff: (path: string, options?: {\n        force?: boolean;\n    }) => Promise<FileDiff | null>;\n    /** Changes when the caller wants visible diffs to re-fetch */\n    refreshId?: number;\n    title?: string;\n    summary?: ReactNode;\n    collapsible?: boolean;\n    defaultCollapsed?: boolean;\n    showFileTree?: boolean;\n    defaultTreeVisible?: boolean;\n    /** External filter state - when provided, internal filter state is ignored */\n    filter?: FileFilter;\n    /** Callback when filter changes (required when filter is provided) */\n    onFilterChange?: (filter: FileFilter) => void;\n    largeDiffThreshold?: number;\n    largeFolderThreshold?: number;\n    onStageFile?: (path: string) => void;\n    onStageHunks?: (path: string, hunks: HunkSelection[]) => void;\n    onUnstageFile?: (path: string) => void;\n    onUnstageHunks?: (path: string, hunks: HunkSelection[]) => void;\n    onDiscardFile?: (path: string) => void;\n    editable?: boolean;\n    onSaveEdit?: (path: string, content: string) => Promise<void>;\n    /** Context menu copy action */\n    onCopyPath?: (path: string) => void;\n    /** Keyboard navigation focus (externally controlled) */\n    focusedPath?: string | null;\n    /** Files that have both staged and unstaged changes */\n    partiallyStagedFiles?: Set<string>;\n    /** Theme for Monaco editor (\"light\" | \"dark\") */\n    theme?: \"light\" | \"dark\";\n    /** Whether this is staged or working diff (for cache key lookup) */\n    diffType?: \"staged\" | \"working\";\n    /** Set of file paths with pending operations (show loading spinner) */\n    pendingFiles?: Set<string>;\n    /** Whether to show diff view controls */\n    showDiffControls?: boolean;\n    /** Shared diff view options (global controls) */\n    diffViewOptions?: DiffViewOptions;\n    /** Optional change handler for diff view options */\n    onDiffViewOptionsChange?: (options: DiffViewOptions) => void;\n    /** Custom diff cache key factory */\n    diffKey?: (path: string) => string;\n    /** Callback to create a new file or directory */\n    onCreateFile?: (parentPath: string | null) => void;\n    /** Callback to delete a file or directory */\n    onDeleteFile?: (path: string, isDirectory: boolean) => void;\n}\n//# sourceMappingURL=types.d.ts.map",
      "DiscardConfirmDialog.d.ts": "export interface DiscardConfirmDialogProps {\n    open: boolean;\n    onOpenChange: (open: boolean) => void;\n    filePath: string;\n    onConfirm: () => void;\n    loading?: boolean;\n}\n/**\n * Confirmation dialog for discarding file changes\n */\nexport declare function DiscardConfirmDialog({ open, onOpenChange, filePath, onConfirm, loading, }: DiscardConfirmDialogProps): import(\"react/jsx-runtime\").JSX.Element;\n//# sourceMappingURL=DiscardConfirmDialog.d.ts.map",
      "ErrorBoundary.d.ts": "import { Component, type ReactNode } from \"react\";\ninterface ErrorBoundaryProps {\n    children: ReactNode;\n    fallback?: ReactNode;\n    onReset?: () => void;\n}\ninterface ErrorBoundaryState {\n    hasError: boolean;\n    error: Error | null;\n}\nexport declare class ErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {\n    constructor(props: ErrorBoundaryProps);\n    static getDerivedStateFromError(error: Error): ErrorBoundaryState;\n    componentDidCatch(error: Error, errorInfo: React.ErrorInfo): void;\n    handleReset: () => void;\n    render(): string | number | bigint | boolean | import(\"react/jsx-runtime\").JSX.Element | Iterable<ReactNode> | Promise<string | number | bigint | boolean | import(\"react\").ReactPortal | import(\"react\").ReactElement<unknown, string | import(\"react\").JSXElementConstructor<any>> | Iterable<ReactNode> | null | undefined> | null | undefined;\n}\nexport {};\n//# sourceMappingURL=ErrorBoundary.d.ts.map",
      "FileHistoryPanel.d.ts": "interface FileHistoryPanelProps {\n    path: string;\n}\nexport declare function FileHistoryPanel({ path }: FileHistoryPanelProps): import(\"react/jsx-runtime\").JSX.Element;\nexport {};\n//# sourceMappingURL=FileHistoryPanel.d.ts.map",
      "FileOverview.d.ts": "import { type RefObject } from \"react\";\nimport type { FileChange } from \"./DiffBlock/types\";\nimport type { GitClient } from \"@natstack/git\";\nexport interface FileOverviewProps {\n    stagedFiles: FileChange[];\n    unstagedFiles: FileChange[];\n    partiallyStagedFiles: Set<string>;\n    onStageFile: (path: string) => void;\n    onUnstageFile: (path: string) => void;\n    onStageAll: () => Promise<void>;\n    onUnstageAll: () => void;\n    onCommit: (message: string) => Promise<void>;\n    hasStaged: boolean;\n    commitLoading?: boolean;\n    commitInputRef?: RefObject<HTMLTextAreaElement | null>;\n    /** Controlled commit message - if provided, component becomes controlled */\n    commitMessage?: string;\n    /** Callback when commit message changes - required if commitMessage is provided */\n    onCommitMessageChange?: (message: string) => void;\n    onSelectFile: (path: string, section: \"staged\" | \"unstaged\") => void;\n    selectedFile?: string | null;\n    selectedSection?: \"staged\" | \"unstaged\";\n    actionLoading?: boolean;\n    /**\n     * Optional callback to generate a commit message using AI.\n     * If provided, enables the \"AI Commit\" button.\n     * @param diff - The staged diff text\n     * @returns The generated commit message\n     */\n    onGenerateCommitMessage?: (diff: string) => Promise<string>;\n    /** Git client needed for getting the diff - required if onGenerateCommitMessage is provided */\n    gitClient?: GitClient;\n    /** Repository directory - required if onGenerateCommitMessage is provided */\n    dir?: string;\n}\nexport declare function FileOverview({ stagedFiles, unstagedFiles, partiallyStagedFiles, onStageFile, onUnstageFile, onStageAll, onUnstageAll, onCommit, hasStaged, commitLoading, commitInputRef, commitMessage: controlledMessage, onCommitMessageChange, onSelectFile, selectedFile, selectedSection, actionLoading, onGenerateCommitMessage, gitClient, dir, }: FileOverviewProps): import(\"react/jsx-runtime\").JSX.Element;\n//# sourceMappingURL=FileOverview.d.ts.map",
      "GitStatusHeader.d.ts": "import type { DiffViewOptions } from \"./DiffBlock\";\nexport interface GitStatusHeaderProps {\n    branch: string | null;\n    onCommit?: () => void;\n    onClose?: () => void;\n    onRefresh?: () => void;\n    onMinimize?: () => void;\n    hasStaged: boolean;\n    loading?: boolean;\n    diffViewOptions?: DiffViewOptions;\n    onDiffViewOptionsChange?: (options: DiffViewOptions) => void;\n}\n/**\n * Header bar with branch name, commit button, refresh button, and close action\n */\nexport declare function GitStatusHeader({ branch, onCommit, onClose, onRefresh, onMinimize, hasStaged, loading, diffViewOptions, onDiffViewOptionsChange, }: GitStatusHeaderProps): import(\"react/jsx-runtime\").JSX.Element;\n//# sourceMappingURL=GitStatusHeader.d.ts.map",
      "GitStatusView.d.ts": "import type { GitClient, FsPromisesLike } from \"@natstack/git\";\nimport type { GitNotification } from \"./store\";\nexport type { GitNotification };\nexport interface GitStatusViewProps {\n    dir: string;\n    fs: FsPromisesLike;\n    gitClient: GitClient;\n    onCommitSuccess?: (sha: string) => void;\n    onClose?: () => void;\n    /** Callback for action notifications (stage, unstage, commit, etc.) */\n    onNotify?: (notification: GitNotification) => void;\n    /** Theme for Monaco editor in diff views */\n    theme?: \"light\" | \"dark\";\n    /**\n     * Optional callback to generate a commit message using AI.\n     * If provided, enables the \"AI Commit\" button that stages all changes\n     * and generates a commit message based on the diff.\n     * @param diff - The staged diff text\n     * @returns The generated commit message\n     */\n    onGenerateCommitMessage?: (diff: string) => Promise<string>;\n}\n/**\n * Main Git status view with accordion sections for unstaged, staged, and history\n */\nexport declare function GitStatusView({ dir, fs, gitClient, onCommitSuccess, onClose, onNotify, theme, onGenerateCommitMessage, }: GitStatusViewProps): import(\"react/jsx-runtime\").JSX.Element;\n//# sourceMappingURL=GitStatusView.d.ts.map",
      "LoadingState.d.ts": "import type { ComponentProps } from \"react\";\nimport { Flex } from \"@radix-ui/themes\";\nexport interface LoadingStateProps {\n    /** Optional message to display */\n    message?: string;\n    /** Size of the spinner (default: \"2\") */\n    size?: \"1\" | \"2\" | \"3\";\n    /** Fill available height (useful for page-level loading) */\n    fullHeight?: boolean;\n    /** Vertical padding when not fullHeight (default: \"4\") */\n    py?: ComponentProps<typeof Flex>[\"py\"];\n}\n/**\n * Centered loading spinner with optional message.\n * Use `fullHeight` for page-level loading states.\n */\nexport declare function LoadingState({ message, size, fullHeight, py, }: LoadingStateProps): import(\"react/jsx-runtime\").JSX.Element;\n//# sourceMappingURL=LoadingState.d.ts.map",
      "MonacoEditor.d.ts": "import { type MonacoNamespace } from \"./modernMonaco.js\";\nimport type { editor } from \"modern-monaco/editor-core\";\nexport interface MonacoEditorProps {\n    /** Initial value for the editor */\n    value: string;\n    /** Language for syntax highlighting */\n    language?: string;\n    /** Editor theme */\n    theme?: \"vs-dark\" | \"light\";\n    /** Read-only mode */\n    readOnly?: boolean;\n    /** Editor height (CSS value or number in pixels) */\n    height?: number | string;\n    /** Additional editor options */\n    options?: editor.IStandaloneEditorConstructionOptions;\n    /** Called when editor content changes */\n    onChange?: (value: string) => void;\n    /** Called when editor is mounted */\n    onMount?: (editor: editor.IStandaloneCodeEditor, monaco: MonacoNamespace) => void;\n}\n/**\n * React component wrapping Monaco editor with modern-monaco.\n *\n * This provides a similar API to @monaco-editor/react for easy migration.\n */\nexport declare function MonacoEditor({ value, language, theme, readOnly, height, options, onChange, onMount, }: MonacoEditorProps): import(\"react/jsx-runtime\").JSX.Element;\n//# sourceMappingURL=MonacoEditor.d.ts.map",
      "MonacoErrorBoundary.d.ts": "import { Component, type ReactNode } from \"react\";\ninterface Props {\n    children: ReactNode;\n    fallbackHeight?: number | string;\n}\ninterface State {\n    hasError: boolean;\n    error: Error | null;\n}\n/**\n * Error boundary for Monaco Editor components.\n * Catches errors during render and provides a recovery UI.\n */\nexport declare class MonacoErrorBoundary extends Component<Props, State> {\n    constructor(props: Props);\n    static getDerivedStateFromError(error: Error): State;\n    componentDidCatch(error: Error, errorInfo: React.ErrorInfo): void;\n    handleRetry: () => void;\n    render(): ReactNode;\n}\nexport {};\n//# sourceMappingURL=MonacoErrorBoundary.d.ts.map",
      "PushPullProgress.d.ts": "import type { GitProgress } from \"@natstack/git\";\nexport interface PushPullProgressProps {\n    progress: GitProgress;\n}\nexport declare function PushPullProgress({ progress }: PushPullProgressProps): import(\"react/jsx-runtime\").JSX.Element;\n//# sourceMappingURL=PushPullProgress.d.ts.map",
      "RemoteOperationsBar.d.ts": "import type { GitProgress, RemoteStatus } from \"@natstack/git\";\nexport interface RemoteOperationsBarProps {\n    status: RemoteStatus | null;\n    loading?: boolean;\n    isPulling?: boolean;\n    isPushing?: boolean;\n    progress?: GitProgress | null;\n    onPull: () => void;\n    onPush: () => void;\n}\nexport declare function RemoteOperationsBar({ status, loading, isPulling, isPushing, progress, onPull, onPush, }: RemoteOperationsBarProps): import(\"react/jsx-runtime\").JSX.Element | null;\n//# sourceMappingURL=RemoteOperationsBar.d.ts.map",
      "SettingsDialog.d.ts": "import type { DiffViewOptions } from \"./DiffBlock\";\nexport interface SettingsDialogProps {\n    open: boolean;\n    onOpenChange: (open: boolean) => void;\n    diffViewOptions: DiffViewOptions;\n    onDiffViewOptionsChange: (options: DiffViewOptions) => void;\n}\nexport declare function SettingsDialog({ open, onOpenChange, diffViewOptions, onDiffViewOptionsChange, }: SettingsDialogProps): import(\"react/jsx-runtime\").JSX.Element;\n//# sourceMappingURL=SettingsDialog.d.ts.map",
      "StashDropConfirmDialog.d.ts": "export interface StashDropConfirmDialogProps {\n    open: boolean;\n    onOpenChange: (open: boolean) => void;\n    stashRef: string;\n    stashMessage: string;\n    onConfirm: () => void;\n    loading?: boolean;\n}\nexport declare function StashDropConfirmDialog({ open, onOpenChange, stashRef, stashMessage, onConfirm, loading, }: StashDropConfirmDialogProps): import(\"react/jsx-runtime\").JSX.Element;\n//# sourceMappingURL=StashDropConfirmDialog.d.ts.map",
      "StashForm.d.ts": "export interface StashFormProps {\n    onStash: (options: {\n        message?: string;\n    }) => Promise<void>;\n    disabled?: boolean;\n    loading?: boolean;\n}\nexport declare function StashForm({ onStash, disabled, loading }: StashFormProps): import(\"react/jsx-runtime\").JSX.Element;\n//# sourceMappingURL=StashForm.d.ts.map",
      "StashSection.d.ts": "/**\n * Stash management section content\n */\nexport declare function StashSection(): import(\"react/jsx-runtime\").JSX.Element;\n//# sourceMappingURL=StashSection.d.ts.map",
      "ThreeWayMergeEditor.d.ts": "import type { ConflictInfo } from \"@natstack/git\";\ninterface ThreeWayMergeEditorProps {\n    conflict: ConflictInfo;\n    onResolve: (content: string) => Promise<void>;\n    theme?: \"light\" | \"dark\";\n    disabled?: boolean;\n}\nexport declare function ThreeWayMergeEditor({ conflict, onResolve, theme, disabled }: ThreeWayMergeEditorProps): import(\"react/jsx-runtime\").JSX.Element;\nexport {};\n//# sourceMappingURL=ThreeWayMergeEditor.d.ts.map",
      "UnsavedChangesDialog.d.ts": "export interface UnsavedChangesDialogProps {\n    open: boolean;\n    onOpenChange: (open: boolean) => void;\n    onDiscard: () => void;\n    onSave?: () => void;\n}\n/**\n * Confirmation dialog for unsaved changes\n */\nexport declare function UnsavedChangesDialog({ open, onOpenChange, onDiscard, onSave, }: UnsavedChangesDialogProps): import(\"react/jsx-runtime\").JSX.Element;\n//# sourceMappingURL=UnsavedChangesDialog.d.ts.map",
      "UnstageConfirmDialog.d.ts": "export interface UnstageConfirmDialogProps {\n    open: boolean;\n    onOpenChange: (open: boolean) => void;\n    fileCount: number;\n    onConfirm: () => void;\n    loading?: boolean;\n}\n/**\n * Confirmation dialog for unstaging all files\n */\nexport declare function UnstageConfirmDialog({ open, onOpenChange, fileCount, onConfirm, loading, }: UnstageConfirmDialogProps): import(\"react/jsx-runtime\").JSX.Element;\n//# sourceMappingURL=UnstageConfirmDialog.d.ts.map",
      "constants.d.ts": "/**\n * Git UI configuration constants\n */\nexport declare const REFRESH_INTERVAL_MS = 30000;\nexport declare const MIN_REFRESH_AGE_MS = 30000;\nexport declare const LARGE_DIFF_LINE_THRESHOLD = 300;\nexport declare const LARGE_FOLDER_FILE_THRESHOLD = 20;\nexport declare const INITIAL_COMMITS_DEPTH = 10;\nexport declare const COMMITS_PAGE_SIZE = 10;\nexport declare const MAX_CACHED_COMMITS = 5;\nexport declare const MAX_CACHED_BLAME_ENTRIES = 20;\nexport declare const MAX_CACHED_HISTORY_ENTRIES = 20;\nexport declare const MAX_CACHED_DIFFS = 100;\nexport declare const BLAME_CACHE_TTL_MS: number;\nexport declare const DEFAULT_EDITOR_HEIGHT = 400;\nexport declare const MIN_EDITOR_HEIGHT = 200;\nexport declare const MAX_EDITOR_HEIGHT = 800;\nexport declare const EDITOR_LINE_HEIGHT_PX = 20;\nexport declare const FILE_TREE_WIDTH = 240;\nexport declare const DIFF_VIEW_STORAGE_KEY = \"git-ui.diffViewOptions\";\nexport declare const DEFAULT_DIFF_VIEW_OPTIONS: {\n    viewMode: \"split\";\n    wordDiff: boolean;\n    showWhitespace: boolean;\n    contextLines: number;\n};\nexport declare const KEYBOARD_SHORTCUTS: readonly [{\n    readonly key: \"j / \";\n    readonly description: \"Move focus down\";\n}, {\n    readonly key: \"k / \";\n    readonly description: \"Move focus up\";\n}, {\n    readonly key: \"s\";\n    readonly description: \"Stage focused file\";\n}, {\n    readonly key: \"u\";\n    readonly description: \"Unstage focused file\";\n}, {\n    readonly key: \"d\";\n    readonly description: \"Discard focused file\";\n}, {\n    readonly key: \"c\";\n    readonly description: \"Open commit form\";\n}, {\n    readonly key: \"`\";\n    readonly description: \"Switch sections\";\n}, {\n    readonly key: \"Escape\";\n    readonly description: \"Close dialogs\";\n}];\nexport declare const FILE_EXTENSION_LANGUAGE_MAP: Record<string, string>;\n//# sourceMappingURL=constants.d.ts.map",
      "hooks/index.d.ts": "/**\n * Git UI custom hooks\n *\n * These hooks use local state for simplicity. They read gitClient config\n * from the global Jotai store but manage their own loading/error/data state.\n */\nexport { useFileBlame } from \"./useFileBlame\";\nexport { useFileHistory } from \"./useFileHistory\";\nexport { useDiffViewOptions } from \"./useDiffViewOptions\";\nexport { useHunkSelection } from \"./useHunkSelection\";\nexport { useKeyboardNavigation } from \"./useKeyboardNavigation\";\nexport type { UseKeyboardNavigationOptions } from \"./useKeyboardNavigation\";\nexport { useConflicts } from \"./useConflicts\";\nexport { useGitBranches } from \"./useGitBranches\";\nexport { useGitRemote } from \"./useGitRemote\";\n//# sourceMappingURL=index.d.ts.map",
      "hooks/useConflicts.d.ts": "import type { ConflictInfo, ConflictResolution } from \"@natstack/git\";\ninterface UseConflictsResult {\n    conflicts: ConflictInfo[];\n    loading: boolean;\n    resolving: boolean;\n    error: Error | null;\n    refresh: () => Promise<void>;\n    resolve: (resolution: ConflictResolution) => Promise<void>;\n}\nexport declare function useConflicts(): UseConflictsResult;\nexport {};\n//# sourceMappingURL=useConflicts.d.ts.map",
      "hooks/useDiffViewOptions.d.ts": "import type { DiffViewOptions } from \"../DiffBlock/types\";\n/**\n * Hook to manage diff view options with localStorage persistence.\n * Options are automatically saved when changed and restored on mount.\n */\nexport declare function useDiffViewOptions(): [DiffViewOptions, (next: DiffViewOptions) => void];\n//# sourceMappingURL=useDiffViewOptions.d.ts.map",
      "hooks/useFileBlame.d.ts": "import type { BlameLine } from \"@natstack/git\";\ninterface UseFileBlameResult {\n    blame: BlameLine[];\n    loading: boolean;\n    error: Error | null;\n    refresh: () => Promise<void>;\n}\n/**\n * Hook to fetch git blame information for a file.\n *\n * Uses a shared Jotai atom for caching, so multiple hook instances\n * share the same cache. The cache has TTL-based invalidation and FIFO eviction.\n */\nexport declare function useFileBlame(path: string | null, enabled?: boolean): UseFileBlameResult;\nexport {};\n//# sourceMappingURL=useFileBlame.d.ts.map",
      "hooks/useFileHistory.d.ts": "import type { FileHistoryEntry } from \"@natstack/git\";\ninterface UseFileHistoryResult {\n    history: FileHistoryEntry[];\n    loading: boolean;\n    error: Error | null;\n    refresh: () => Promise<void>;\n}\n/**\n * Hook to fetch git file history.\n *\n * Uses a shared Jotai atom for caching, so multiple hook instances\n * share the same cache. The cache has FIFO eviction when it exceeds the max size.\n */\nexport declare function useFileHistory(path: string | null, enabled?: boolean): UseFileHistoryResult;\nexport {};\n//# sourceMappingURL=useFileHistory.d.ts.map",
      "hooks/useFileSelection.d.ts": "import type { FileChange } from \"../DiffBlock/types\";\nexport interface UseFileSelectionOptions {\n    files: FileChange[];\n    /** External controlled selection (when provided, internal state is ignored) */\n    focusedPath?: string | null;\n}\nexport interface UseFileSelectionResult {\n    selectedFiles: Set<string>;\n    handleFileSelect: (path: string, event: React.MouseEvent) => void;\n    clearSelection: () => void;\n    selectAll: () => void;\n}\n/**\n * Custom hook to manage file selection state with support for:\n * - Single selection (regular click)\n * - Multi-selection (Ctrl/Cmd + click)\n * - Range selection (Shift + click)\n * - Controlled mode (via focusedPath prop)\n * - Auto-selection of first file when list changes\n */\nexport declare function useFileSelection({ files, focusedPath, }: UseFileSelectionOptions): UseFileSelectionResult;\n//# sourceMappingURL=useFileSelection.d.ts.map",
      "hooks/useGitBranches.d.ts": "import type { BranchInfo, CreateBranchOptions } from \"@natstack/git\";\ninterface UseGitBranchesResult {\n    branches: BranchInfo[];\n    remoteBranches: BranchInfo[];\n    currentBranch: string | null;\n    loading: boolean;\n    error: Error | null;\n    refresh: () => Promise<void>;\n    createBranch: (options: Omit<CreateBranchOptions, \"dir\">) => Promise<void>;\n    deleteBranch: (name: string) => Promise<void>;\n    checkoutBranch: (name: string) => Promise<void>;\n}\nexport declare function useGitBranches(): UseGitBranchesResult;\nexport {};\n//# sourceMappingURL=useGitBranches.d.ts.map",
      "hooks/useGitRemote.d.ts": "import type { GitProgress, RemoteStatus } from \"@natstack/git\";\nimport { GitAuthError } from \"@natstack/git\";\ninterface UseGitRemoteResult {\n    status: RemoteStatus | null;\n    loading: boolean;\n    progress: GitProgress | null;\n    isPulling: boolean;\n    isPushing: boolean;\n    authError: GitAuthError | null;\n    error: Error | null;\n    refresh: () => Promise<void>;\n    pull: () => Promise<void>;\n    push: () => Promise<void>;\n    clearAuthError: () => void;\n}\nexport declare function useGitRemote(): UseGitRemoteResult;\nexport {};\n//# sourceMappingURL=useGitRemote.d.ts.map",
      "hooks/useHunkSelection.d.ts": "import type { HunkSelection } from \"@natstack/git\";\ninterface Hunk {\n    lines: Array<{\n        type: string;\n    }>;\n}\ninterface UseHunkSelectionOptions {\n    hunks: Hunk[];\n    diffPath: string;\n}\n/**\n * Hook to manage hunk and line selection for staging/unstaging partial changes.\n */\nexport declare function useHunkSelection({ hunks, diffPath }: UseHunkSelectionOptions): {\n    selectionMode: boolean;\n    setSelectionMode: import(\"react\").Dispatch<import(\"react\").SetStateAction<boolean>>;\n    selectedHunks: Map<number, Set<number> | null>;\n    hunkChangeIndices: number[][];\n    toggleHunkSelection: (hunkIndex: number) => void;\n    toggleLineSelection: (hunkIndex: number, lineIndex: number) => void;\n    buildSelections: () => HunkSelection[];\n    clearSelections: () => void;\n};\nexport {};\n//# sourceMappingURL=useHunkSelection.d.ts.map",
      "hooks/useKeyboardNavigation.d.ts": "import { RefObject } from \"react\";\nimport type { GitNotification } from \"../store\";\nexport interface UseKeyboardNavigationOptions {\n    containerRef: RefObject<HTMLDivElement | null>;\n    onStageFile: (path: string) => void;\n    onUnstageFile: (path: string) => void;\n    onFocusCommit?: () => void;\n    onNotify?: (notification: GitNotification) => void;\n}\n/**\n * Hook to handle keyboard navigation for the Git status view\n */\nexport declare function useKeyboardNavigation({ containerRef, onStageFile, onUnstageFile, onFocusCommit, onNotify, }: UseKeyboardNavigationOptions): void;\n//# sourceMappingURL=useKeyboardNavigation.d.ts.map",
      "index.d.ts": "/**\n * @natstack/git-ui - Git UI components for React\n *\n * This package provides a complete Git status view with:\n * - File staging/unstaging with diff views\n * - Commit creation and history viewing\n * - Stash management\n * - Branch operations\n * - Conflict resolution\n *\n * @remarks\n * **Important**: This package uses a global Jotai store for state management.\n * Only one GitStatusView instance should be mounted at a time. If you need to\n * switch between repositories, unmount the current GitStatusView before mounting\n * a new one with different props. Multiple simultaneous instances will share\n * state unexpectedly.\n */\nexport { getMonaco, isMonacoReady, getMonacoSync, type MonacoNamespace } from \"./modernMonaco\";\nexport { MonacoEditor } from \"./MonacoEditor\";\nexport { configureMonacoTypeCheck, addMonacoTypeDefinition, diagnosticsToMarkers, setDiagnosticsOnModel, type MonacoTypeCheckConfig, type MarkerData, } from \"./monacoTypeCheck\";\nexport { DiffBlock, FileTree, DiffStack, FileDiff, FileDiffHeader, LargeDiffGuard, DiffViewControls, HunkHeader, LineSelectionOverlay, BinaryFileDiff, ImageCompare, DiffEditorDirect, } from \"./DiffBlock\";\nexport type { DiffBlockProps, FileChange, FileDiffType, Hunk, DiffLine, FileTreeContextMenuActions, FileDiffHeaderProps, DiffViewOptions, FileFilter, } from \"./DiffBlock\";\nexport { GitStatusView } from \"./GitStatusView\";\nexport type { GitStatusViewProps, GitNotification } from \"./GitStatusView\";\nexport { useGitStatus } from \"./useGitStatus\";\nexport type { UseGitStatusResult } from \"./useGitStatus\";\nexport { useGitBranches } from \"./hooks/useGitBranches\";\nexport { useGitRemote } from \"./hooks/useGitRemote\";\nexport { useFileBlame } from \"./hooks/useFileBlame\";\nexport { useFileHistory } from \"./hooks/useFileHistory\";\nexport { useConflicts } from \"./hooks/useConflicts\";\nexport { useFileSelection } from \"./hooks/useFileSelection\";\nexport type { UseFileSelectionOptions, UseFileSelectionResult } from \"./hooks/useFileSelection\";\nexport { GitStatusHeader } from \"./GitStatusHeader\";\nexport type { GitStatusHeaderProps } from \"./GitStatusHeader\";\nexport { BranchSelector } from \"./BranchSelector\";\nexport { CreateBranchDialog } from \"./CreateBranchDialog\";\nexport { RemoteOperationsBar } from \"./RemoteOperationsBar\";\nexport { PushPullProgress } from \"./PushPullProgress\";\nexport { AuthErrorDialog } from \"./AuthErrorDialog\";\nexport { CommitForm } from \"./CommitForm\";\nexport type { CommitFormProps } from \"./CommitForm\";\nexport { CommitHistory } from \"./CommitHistory\";\nexport type { CommitHistoryProps } from \"./CommitHistory\";\nexport { BlameView } from \"./BlameView\";\nexport { FileHistoryPanel } from \"./FileHistoryPanel\";\nexport { ConflictResolutionView } from \"./ConflictResolutionView\";\nexport { ThreeWayMergeEditor } from \"./ThreeWayMergeEditor\";\nexport { ConflictMarkerButtons } from \"./ConflictMarkerButtons\";\nexport { MonacoErrorBoundary } from \"./MonacoErrorBoundary\";\nexport { ErrorBoundary } from \"./ErrorBoundary\";\nexport { LoadingState } from \"./LoadingState\";\nexport type { LoadingStateProps } from \"./LoadingState\";\nexport { StashForm } from \"./StashForm\";\nexport type { StashFormProps } from \"./StashForm\";\nexport { StashDropConfirmDialog } from \"./StashDropConfirmDialog\";\nexport type { StashDropConfirmDialogProps } from \"./StashDropConfirmDialog\";\nexport { DiscardConfirmDialog } from \"./DiscardConfirmDialog\";\nexport type { DiscardConfirmDialogProps } from \"./DiscardConfirmDialog\";\nexport { UnstageConfirmDialog } from \"./UnstageConfirmDialog\";\nexport type { UnstageConfirmDialogProps } from \"./UnstageConfirmDialog\";\nexport { UnsavedChangesDialog } from \"./UnsavedChangesDialog\";\nexport type { UnsavedChangesDialogProps } from \"./UnsavedChangesDialog\";\nexport { SettingsDialog } from \"./SettingsDialog\";\nexport type { SettingsDialogProps } from \"./SettingsDialog\";\nexport { FileOverview } from \"./FileOverview\";\nexport type { FileOverviewProps } from \"./FileOverview\";\nexport { CompactHeader } from \"./CompactHeader\";\nexport type { CompactHeaderProps } from \"./CompactHeader\";\nexport { CreateFileDialog } from \"./CreateFileDialog\";\nexport type { CreateFileDialogProps } from \"./CreateFileDialog\";\nexport { DeleteConfirmDialog } from \"./DeleteConfirmDialog\";\nexport type { DeleteConfirmDialogProps } from \"./DeleteConfirmDialog\";\nexport { initializeStoreAtom, } from \"./store\";\nexport type { GitStoreConfig, CommitEntry, } from \"./store\";\nexport { REFRESH_INTERVAL_MS, MIN_REFRESH_AGE_MS, LARGE_DIFF_LINE_THRESHOLD, LARGE_FOLDER_FILE_THRESHOLD, INITIAL_COMMITS_DEPTH, COMMITS_PAGE_SIZE, MAX_CACHED_COMMITS, MAX_CACHED_BLAME_ENTRIES, MAX_CACHED_HISTORY_ENTRIES, DEFAULT_EDITOR_HEIGHT, MIN_EDITOR_HEIGHT, DIFF_VIEW_STORAGE_KEY, DEFAULT_DIFF_VIEW_OPTIONS, KEYBOARD_SHORTCUTS, FILE_EXTENSION_LANGUAGE_MAP, } from \"./constants\";\n//# sourceMappingURL=index.d.ts.map",
      "modernMonaco.d.ts": "/**\n * modern-monaco initialization and utilities.\n *\n * Replaces monacoWorkers.ts - modern-monaco handles workers automatically\n * via blob URLs, eliminating the need for complex environment configuration.\n */\nimport { init } from \"modern-monaco\";\n/** Monaco namespace type - inferred from init() return type */\nexport type MonacoNamespace = Awaited<ReturnType<typeof init>>;\n/**\n * Get initialized Monaco instance.\n * Returns cached instance or initializes on first call.\n *\n * modern-monaco automatically:\n * - Handles worker creation via blob URLs (NO MonacoEnvironment setup)\n * - Uses Shiki for syntax highlighting (lighter than Monaco's language services)\n * - Provides LSP integration for HTML, CSS, JS/TS, JSON\n */\nexport declare function getMonaco(): Promise<MonacoNamespace>;\n/**\n * Check if Monaco is already initialized.\n */\nexport declare function isMonacoReady(): boolean;\n/**\n * Get Monaco instance synchronously (throws if not initialized).\n * Use this only when you're certain Monaco has already been initialized.\n */\nexport declare function getMonacoSync(): MonacoNamespace;\n//# sourceMappingURL=modernMonaco.d.ts.map",
      "monaco.d.ts": "/**\n * @natstack/git-ui/monaco - Monaco-dependent exports\n *\n * This module provides Monaco editor integration components and utilities.\n * Import from this subpath when you need Monaco functionality.\n *\n * Uses modern-monaco for:\n * - Automatic worker handling via blob URLs (no MonacoEnvironment setup)\n * - Shiki-based syntax highlighting (lighter than Monaco's language services)\n * - Built-in LSP providers for HTML, CSS, JS/TS, JSON\n */\nexport { getMonaco, isMonacoReady, getMonacoSync, type MonacoNamespace } from \"./modernMonaco.js\";\nexport { MonacoEditor } from \"./MonacoEditor.js\";\nexport { configureMonacoTypeCheck, addMonacoTypeDefinition, diagnosticsToMarkers, setDiagnosticsOnModel, type MonacoTypeCheckConfig, type MarkerData, } from \"./monacoTypeCheck.js\";\nexport { ThreeWayMergeEditor } from \"./ThreeWayMergeEditor.js\";\nexport { BlameView } from \"./BlameView.js\";\nexport { DiffEditorDirect } from \"./DiffBlock/DiffEditorDirect.js\";\nexport { MonacoErrorBoundary } from \"./MonacoErrorBoundary.js\";\nexport { FileContentView } from \"./DiffBlock/FileContentView.js\";\n//# sourceMappingURL=monaco.d.ts.map",
      "monacoTypeCheck.d.ts": "/**\n * Monaco Editor TypeScript configuration for NatStack.\n *\n * This module configures Monaco's TypeScript language service to use\n * NatStack's bundled type definitions, providing accurate IntelliSense\n * for @natstack/runtime APIs, fs shim, and other panel-specific types.\n */\n/**\n * Configuration options for Monaco TypeScript setup.\n */\nexport interface MonacoTypeCheckConfig {\n    /**\n     * Enable strict mode (default: true)\n     */\n    strict?: boolean;\n    /**\n     * Target ECMAScript version (default: ES2022)\n     */\n    target?: number;\n    /**\n     * JSX mode (default: ReactJSX)\n     */\n    jsx?: number;\n    /**\n     * Additional type definition files to include.\n     * Format: { virtualPath: content }\n     *\n     * For React types, use TypeDefinitionLoader to fetch @types/react and add here:\n     * @example\n     * ```typescript\n     * const reactTypes = await typeDefLoader.loadPackageTypes(\"@types/react\");\n     * configureMonacoTypeCheck({\n     *   additionalTypes: Object.fromEntries(\n     *     [...reactTypes.files.entries()].map(([path, content]) =>\n     *       [`file:///node_modules/@types/react/${path}`, content]\n     *     )\n     *   ),\n     * });\n     * ```\n     */\n    additionalTypes?: Record<string, string>;\n}\n/**\n * Configure Monaco's TypeScript/JavaScript language service for NatStack panels.\n *\n * This sets up:\n * - Compiler options matching the panel build system\n * - Bundled TypeScript lib files (ES2022, DOM)\n * - @natstack/runtime type definitions\n * - fs shim type definitions\n * - Global NatStack types\n *\n * Call this once when initializing Monaco in your application.\n *\n * @returns Promise<true> if configuration succeeded, Promise<false> if Monaco typescript API unavailable\n */\nexport declare function configureMonacoTypeCheck(config?: MonacoTypeCheckConfig): Promise<boolean>;\n/**\n * Add type definitions for an additional package.\n *\n * Use this to add types for packages loaded dynamically or\n * not included in the default configuration.\n *\n * @returns Promise<true> if the definition was added, Promise<false> if Monaco typescript API unavailable\n */\nexport declare function addMonacoTypeDefinition(virtualPath: string, content: string, language?: \"typescript\" | \"javascript\"): Promise<boolean>;\n/**\n * Marker data type compatible with Monaco's IMarkerData interface.\n */\nexport interface MarkerData {\n    startLineNumber: number;\n    startColumn: number;\n    endLineNumber: number;\n    endColumn: number;\n    message: string;\n    severity: 8 | 4 | 2;\n}\n/**\n * Create Monaco markers from TypeCheckDiagnostic array.\n *\n * Use this to convert diagnostics from TypeCheckService to Monaco markers.\n */\nexport declare function diagnosticsToMarkers(diagnostics: Array<{\n    file: string;\n    line: number;\n    column: number;\n    endLine?: number;\n    endColumn?: number;\n    message: string;\n    severity: \"error\" | \"warning\" | \"info\";\n}>, filterFile?: string): MarkerData[];\n/**\n * Set Monaco markers on a model from TypeCheckService diagnostics.\n *\n * @param modelUri - The URI of the model (e.g., \"file:///path/to/file.ts\")\n * @param diagnostics - Array of diagnostics from TypeCheckService\n * @param owner - Owner identifier for the markers (default: \"natstack-typecheck\")\n */\nexport declare function setDiagnosticsOnModel(modelUri: string, diagnostics: Array<{\n    file: string;\n    line: number;\n    column: number;\n    endLine?: number;\n    endColumn?: number;\n    message: string;\n    severity: \"error\" | \"warning\" | \"info\";\n}>, owner?: string): Promise<void>;\n//# sourceMappingURL=monacoTypeCheck.d.ts.map",
      "store/actions.d.ts": "import type { RefreshTrigger } from \"./types\";\nimport type { HunkSelection } from \"@natstack/git\";\n/**\n * Build a cache key for diff entries.\n * Centralizes the cache key format to prevent inconsistencies.\n */\nexport declare function buildDiffCacheKey(type: \"working\" | \"staged\" | \"commit\", path: string, sha?: string): string;\n/**\n * Delete diff cache entries for specific paths.\n * Also clears any in-flight loading state to prevent stale data from racing in.\n */\nexport declare const deleteDiffCacheForPathsAtom: import(\"jotai\").WritableAtom<null, [paths: string[]], void> & {\n    init: null;\n};\n/**\n * Refresh git status from the repository.\n *\n * PRINCIPLE: Git is the source of truth. We always fetch fresh state and\n * replace our atoms entirely. No complex change detection that can race.\n */\nexport declare const refreshStatusAtom: import(\"jotai\").WritableAtom<null, [trigger?: RefreshTrigger | undefined], Promise<void>> & {\n    init: null;\n};\n/**\n * Manual refresh entry point - does a FULL state reset.\n *\n * Clears all caches and reloads everything fresh from git.\n * Use this when the UI seems out of sync with git state.\n */\nexport declare const manualRefreshAtom: import(\"jotai\").WritableAtom<null, [], Promise<void>> & {\n    init: null;\n};\n/**\n * Refresh stash list\n */\nexport declare const refreshStashesAtom: import(\"jotai\").WritableAtom<null, [], Promise<void>> & {\n    init: null;\n};\n/**\n * Refresh commit history\n */\nexport declare const refreshHistoryAtom: import(\"jotai\").WritableAtom<null, [resetDepth?: unknown], Promise<void>> & {\n    init: null;\n};\n/**\n * Load more commit history\n */\nexport declare const loadMoreHistoryAtom: import(\"jotai\").WritableAtom<null, [], Promise<void>> & {\n    init: null;\n};\n/**\n * Stage a file\n */\nexport declare const stageFileAtom: import(\"jotai\").WritableAtom<null, [path: string], Promise<void>> & {\n    init: null;\n};\n/**\n * Stage selected hunks/lines\n */\nexport declare const stageHunksAtom: import(\"jotai\").WritableAtom<null, [payload: {\n    path: string;\n    hunks: HunkSelection[];\n}], Promise<void>> & {\n    init: null;\n};\n/**\n * Stage all files\n */\nexport declare const stageAllAtom: import(\"jotai\").WritableAtom<null, [paths: string[]], Promise<void>> & {\n    init: null;\n};\n/**\n * Unstage a file\n */\nexport declare const unstageFileAtom: import(\"jotai\").WritableAtom<null, [path: string], Promise<void>> & {\n    init: null;\n};\n/**\n * Unstage selected hunks/lines\n */\nexport declare const unstageHunksAtom: import(\"jotai\").WritableAtom<null, [payload: {\n    path: string;\n    hunks: HunkSelection[];\n}], Promise<void>> & {\n    init: null;\n};\n/**\n * Unstage all files\n */\nexport declare const unstageAllAtom: import(\"jotai\").WritableAtom<null, [paths: string[]], Promise<void>> & {\n    init: null;\n};\n/**\n * Discard changes to a file\n */\nexport declare const discardFileAtom: import(\"jotai\").WritableAtom<null, [path: string], Promise<void>> & {\n    init: null;\n};\n/**\n * Save file content\n */\nexport declare const saveFileAtom: import(\"jotai\").WritableAtom<null, [path: string, content: string], Promise<void>> & {\n    init: null;\n};\n/**\n * Create a new file or directory\n */\nexport declare const createFileAtom: import(\"jotai\").WritableAtom<null, [{\n    path: string;\n    isDirectory: boolean;\n}], Promise<void>> & {\n    init: null;\n};\n/**\n * Delete a file or directory\n */\nexport declare const deletePathAtom: import(\"jotai\").WritableAtom<null, [path: string], Promise<void>> & {\n    init: null;\n};\n/**\n * Create a commit\n */\nexport declare const commitAtom: import(\"jotai\").WritableAtom<null, [message: string], Promise<string>> & {\n    init: null;\n};\n/**\n * Create a stash\n */\nexport declare const createStashAtom: import(\"jotai\").WritableAtom<null, [options?: {\n    message?: string;\n} | undefined], Promise<void>> & {\n    init: null;\n};\n/**\n * Apply a stash\n */\nexport declare const applyStashAtom: import(\"jotai\").WritableAtom<null, [index: number], Promise<void>> & {\n    init: null;\n};\n/**\n * Pop a stash\n */\nexport declare const popStashAtom: import(\"jotai\").WritableAtom<null, [index: number], Promise<void>> & {\n    init: null;\n};\n/**\n * Drop a stash\n */\nexport declare const dropStashAtom: import(\"jotai\").WritableAtom<null, [index: number], Promise<void>> & {\n    init: null;\n};\n/**\n * Fetch a diff (working tree, staged, or commit).\n *\n * This action has dual purposes:\n * 1. Returns the diff directly for immediate use by the caller\n * 2. Caches the diff in diffsAtom for other components to read via getDiffAtom\n *\n * @param type - The type of diff: \"working\" (index vs workdir), \"staged\" (HEAD vs index), or \"commit\"\n * @param path - The file path to get the diff for\n * @param options.force - If true, bypass the cache and fetch fresh data\n * @param options.sha - Required for \"commit\" type - the commit hash\n * @returns The FileDiff, or null if still loading or config not set\n */\nexport declare const fetchDiffAtom: import(\"jotai\").WritableAtom<null, [type: \"staged\" | \"working\" | \"commit\", path: string, options?: {\n    force?: boolean;\n    sha?: string;\n} | undefined], Promise<import(\"@natstack/git\").FileDiff | null>> & {\n    init: null;\n};\n/**\n * Clear all diff cache\n */\nexport declare const clearDiffCacheAtom: import(\"jotai\").WritableAtom<null, [], void> & {\n    init: null;\n};\n/**\n * Set focused section\n */\nexport declare const setFocusedSectionAtom: import(\"jotai\").WritableAtom<null, [section: \"staged\" | \"unstaged\"], void> & {\n    init: null;\n};\n/**\n * Move focus up\n */\nexport declare const moveFocusUpAtom: import(\"jotai\").WritableAtom<null, [], void> & {\n    init: null;\n};\n/**\n * Move focus down\n */\nexport declare const moveFocusDownAtom: import(\"jotai\").WritableAtom<null, [], void> & {\n    init: null;\n};\n/**\n * Toggle focused section\n */\nexport declare const toggleFocusedSectionAtom: import(\"jotai\").WritableAtom<null, [], void> & {\n    init: null;\n};\n/**\n * Initialize the store with config and fetch initial data.\n * Synchronous to avoid race conditions with useEffect cleanup in StrictMode.\n */\nexport declare const initializeStoreAtom: import(\"jotai\").WritableAtom<null, [config: import(\"./types\").GitStoreConfig], void> & {\n    init: null;\n};\n/**\n * Cleanup the store when the component unmounts.\n * Sets config to null to prevent in-flight async operations from updating stale state.\n * Other atoms are left intact - they're bounded by LRU limits and can be reused on remount.\n */\nexport declare const cleanupStoreAtom: import(\"jotai\").WritableAtom<null, [], void> & {\n    init: null;\n};\n//# sourceMappingURL=actions.d.ts.map",
      "store/atoms.d.ts": "import type { FileState, DiffState, CommitEntry, GitStoreConfig, StashEntry } from \"./types\";\nexport declare const configAtom: import(\"jotai\").PrimitiveAtom<GitStoreConfig | null> & {\n    init: GitStoreConfig | null;\n};\n/**\n * Normalized file state - Map<path, FileState>\n * Using Map for O(1) lookups and structural sharing\n */\nexport declare const filesAtom: import(\"jotai\").PrimitiveAtom<Map<string, FileState>> & {\n    init: Map<string, FileState>;\n};\n/**\n * Cached diffs - Map<key, DiffState>\n * Key format: \"working:path\" | \"staged:path\" | \"commit:sha:path\"\n */\nexport declare const diffsAtom: import(\"jotai\").PrimitiveAtom<Map<string, DiffState>> & {\n    init: Map<string, DiffState>;\n};\n/**\n * Stash entries\n */\nexport declare const stashesAtom: import(\"jotai\").PrimitiveAtom<StashEntry[]> & {\n    init: StashEntry[];\n};\n/**\n * Commit history entries\n */\nexport declare const commitsAtom: import(\"jotai\").PrimitiveAtom<CommitEntry[]> & {\n    init: CommitEntry[];\n};\n/**\n * Whether there are more commits to load\n */\nexport declare const commitsHasMoreAtom: import(\"jotai\").PrimitiveAtom<boolean> & {\n    init: boolean;\n};\n/**\n * Current commit history depth (for pagination)\n */\nexport declare const commitsDepthAtom: import(\"jotai\").PrimitiveAtom<number> & {\n    init: number;\n};\n/**\n * Currently focused section for keyboard navigation\n */\nexport declare const focusedSectionAtom: import(\"jotai\").PrimitiveAtom<\"staged\" | \"unstaged\"> & {\n    init: \"staged\" | \"unstaged\";\n};\n/**\n * Currently focused index within the focused section\n */\nexport declare const focusedIndexAtom: import(\"jotai\").PrimitiveAtom<number> & {\n    init: number;\n};\n/**\n * All tracked files in the repository (from git ls-files equivalent)\n * Always shown in the file tree\n */\nexport declare const allTrackedFilesAtom: import(\"jotai\").PrimitiveAtom<string[]> & {\n    init: string[];\n};\n/**\n * Whether the header is minimized to show more diff content\n */\nexport declare const headerMinimizedAtom: import(\"jotai\").PrimitiveAtom<boolean> & {\n    init: boolean;\n};\n/**\n * Empty directories created by the user (not tracked by git)\n * These need to be displayed even though they have no files\n */\nexport declare const emptyDirectoriesAtom: import(\"jotai\").PrimitiveAtom<Set<string>> & {\n    init: Set<string>;\n};\n/**\n * Current branch name\n */\nexport declare const branchAtom: import(\"jotai\").PrimitiveAtom<string | null> & {\n    init: string | null;\n};\n/**\n * Last successful refresh timestamp\n */\nexport declare const lastRefreshAtom: import(\"jotai\").PrimitiveAtom<number> & {\n    init: number;\n};\n/**\n * Whether a refresh is currently in progress\n */\nexport declare const refreshingAtom: import(\"jotai\").PrimitiveAtom<boolean> & {\n    init: boolean;\n};\n/**\n * Loading state for initial load\n */\nexport declare const loadingAtom: import(\"jotai\").PrimitiveAtom<boolean> & {\n    init: boolean;\n};\n/**\n * Error from last refresh attempt\n */\nexport declare const errorAtom: import(\"jotai\").PrimitiveAtom<Error | null> & {\n    init: Error | null;\n};\n/**\n * Whether stash list is loading (set to true when refresh starts)\n */\nexport declare const stashLoadingAtom: import(\"jotai\").PrimitiveAtom<boolean> & {\n    init: boolean;\n};\n/**\n * Whether a stash action is in progress\n */\nexport declare const stashActionLoadingAtom: import(\"jotai\").PrimitiveAtom<boolean> & {\n    init: boolean;\n};\n/**\n * Error from stash operations\n */\nexport declare const stashErrorAtom: import(\"jotai\").PrimitiveAtom<Error | null> & {\n    init: Error | null;\n};\n/**\n * Whether commit history is loading (set to true when refresh starts)\n */\nexport declare const historyLoadingAtom: import(\"jotai\").PrimitiveAtom<boolean> & {\n    init: boolean;\n};\n/**\n * Whether an action (stage, unstage, commit, etc.) is in progress\n */\nexport declare const actionLoadingAtom: import(\"jotai\").PrimitiveAtom<boolean> & {\n    init: boolean;\n};\n/**\n * Path of file to discard (null = dialog closed)\n */\nexport declare const discardPathAtom: import(\"jotai\").PrimitiveAtom<string | null> & {\n    init: string | null;\n};\n/**\n * Whether to show unstage all confirmation dialog\n */\nexport declare const showUnstageConfirmAtom: import(\"jotai\").PrimitiveAtom<boolean> & {\n    init: boolean;\n};\n/**\n * Stash index to drop (null = dialog closed)\n */\nexport declare const dropStashIndexAtom: import(\"jotai\").PrimitiveAtom<number | null> & {\n    init: number | null;\n};\n/**\n * Whether to show commit form\n */\nexport declare const showCommitFormAtom: import(\"jotai\").PrimitiveAtom<boolean> & {\n    init: boolean;\n};\n/**\n * Paths currently being loaded\n */\nexport declare const loadingDiffsAtom: import(\"jotai\").PrimitiveAtom<Set<string>> & {\n    init: Set<string>;\n};\n/**\n * Errors for specific diff paths\n */\nexport declare const diffErrorsAtom: import(\"jotai\").PrimitiveAtom<Map<string, string>> & {\n    init: Map<string, string>;\n};\nimport type { BlameLine, FileHistoryEntry } from \"@natstack/git\";\nexport interface BlameCacheEntry {\n    blame: BlameLine[];\n    fetchedAt: number;\n}\nexport interface HistoryCacheEntry {\n    history: FileHistoryEntry[];\n    fetchedAt: number;\n}\n/**\n * Shared blame cache - Map<path, CacheEntry>\n * Multiple useFileBlame instances share this cache.\n */\nexport declare const blameCacheAtom: import(\"jotai\").PrimitiveAtom<Map<string, BlameCacheEntry>> & {\n    init: Map<string, BlameCacheEntry>;\n};\n/**\n * Shared file history cache - Map<path, CacheEntry>\n * Multiple useFileHistory instances share this cache.\n */\nexport declare const historyCacheAtom: import(\"jotai\").PrimitiveAtom<Map<string, HistoryCacheEntry>> & {\n    init: Map<string, HistoryCacheEntry>;\n};\n//# sourceMappingURL=atoms.d.ts.map",
      "store/index.d.ts": "export type { UIFileStatus, FileState, DiffState, CommitEntry, RefreshTrigger, GitStoreConfig, GitNotification, FileChange, FileDiff, StashEntry, GitClient, FsPromisesLike, } from \"./types\";\nexport { configAtom, filesAtom, diffsAtom, stashesAtom, commitsAtom, commitsHasMoreAtom, commitsDepthAtom, focusedSectionAtom, focusedIndexAtom, branchAtom, lastRefreshAtom, refreshingAtom, loadingAtom, errorAtom, stashLoadingAtom, stashActionLoadingAtom, stashErrorAtom, historyLoadingAtom, actionLoadingAtom, discardPathAtom, showUnstageConfirmAtom, dropStashIndexAtom, showCommitFormAtom, loadingDiffsAtom, diffErrorsAtom, blameCacheAtom, historyCacheAtom, allTrackedFilesAtom, headerMinimizedAtom, emptyDirectoriesAtom, } from \"./atoms\";\nexport type { BlameCacheEntry, HistoryCacheEntry } from \"./atoms\";\nexport { stagedFilesAtom, unstagedFilesAtom, changesTreeFilesAtom, partiallyStagedFilesAtom, hasStagedAtom, hasChangesAtom, pollingPausedAtom, focusedPathAtom, getDiffAtom, computeDiffStats, } from \"./selectors\";\nexport { refreshStatusAtom, manualRefreshAtom, refreshStashesAtom, refreshHistoryAtom, loadMoreHistoryAtom, stageFileAtom, stageHunksAtom, stageAllAtom, unstageFileAtom, unstageHunksAtom, unstageAllAtom, discardFileAtom, saveFileAtom, createFileAtom, deletePathAtom, commitAtom, createStashAtom, applyStashAtom, popStashAtom, dropStashAtom, fetchDiffAtom, clearDiffCacheAtom, setFocusedSectionAtom, moveFocusUpAtom, moveFocusDownAtom, toggleFocusedSectionAtom, initializeStoreAtom, cleanupStoreAtom, } from \"./actions\";\n//# sourceMappingURL=index.d.ts.map",
      "store/selectors.d.ts": "import type { FileChange } from \"./types\";\n/**\n * Derived atom for staged files.\n * Jotai handles subscription efficiently - only re-renders when filesAtom changes.\n * Component-level React.memo handles UI optimization.\n */\nexport declare const stagedFilesAtom: import(\"jotai\").Atom<FileChange[]>;\n/**\n * Derived atom for unstaged files\n */\nexport declare const unstagedFilesAtom: import(\"jotai\").Atom<FileChange[]>;\n/**\n * Files to display in the Changes section tree.\n * Includes changed files, all tracked files, and empty directories.\n */\nexport declare const changesTreeFilesAtom: import(\"jotai\").Atom<FileChange[]>;\n/**\n * Set of partially staged file paths (appear in both staged and unstaged)\n */\nexport declare const partiallyStagedFilesAtom: import(\"jotai\").Atom<Set<string>>;\n/**\n * Helper to compute additions/deletions from a diff's hunks.\n * Exported for use in components.\n */\nexport declare function computeDiffStats(hunks: Array<{\n    lines: Array<{\n        type: string;\n    }>;\n}>): {\n    additions: number;\n    deletions: number;\n};\n/**\n * Whether there are any staged changes\n */\nexport declare const hasStagedAtom: import(\"jotai\").Atom<boolean>;\n/**\n * Whether there are any changes (staged or unstaged)\n */\nexport declare const hasChangesAtom: import(\"jotai\").Atom<boolean>;\n/**\n * Whether polling should be paused (dialog open)\n */\nexport declare const pollingPausedAtom: import(\"jotai\").Atom<boolean>;\n/**\n * Currently focused file path based on section and index\n */\nexport declare const focusedPathAtom: import(\"jotai\").Atom<string | null>;\n/**\n * Get diff for a specific key from cache\n */\nexport declare const getDiffAtom: import(\"jotai\").Atom<(key: string) => import(\"@natstack/git\").FileDiff | null>;\n//# sourceMappingURL=selectors.d.ts.map",
      "store/types.d.ts": "import type { FileDiff, StashEntry, GitClient, FsPromisesLike } from \"@natstack/git\";\n/**\n * UI file status values.\n *\n * These are mapped from git's raw status values:\n * - \"added\"  git \"added\" or \"untracked\" (new files)\n * - \"modified\"  git \"modified\" or any unknown status\n * - \"deleted\"  git \"deleted\"\n * - \"renamed\"  detected when oldPath differs from path\n * - \"unmodified\"  tracked file with no changes (used when showing all files)\n */\nexport type UIFileStatus = \"added\" | \"modified\" | \"deleted\" | \"renamed\" | \"unmodified\";\n/**\n * Normalized file state stored in the files Map\n */\nexport interface FileState {\n    path: string;\n    status: UIFileStatus;\n    staged: boolean;\n    unstaged: boolean;\n    oldPath?: string;\n}\n/**\n * Cached diff entry\n */\nexport interface DiffState {\n    /** The diff data */\n    diff: FileDiff;\n}\n/**\n * Commit entry from git log\n */\nexport interface CommitEntry {\n    oid: string;\n    message: string;\n    author: {\n        name: string;\n        email: string;\n        timestamp: number;\n    };\n}\n/**\n * Refresh trigger types for event-driven updates\n */\nexport type RefreshTrigger = {\n    type: \"user-action\";\n    action: string;\n} | {\n    type: \"manual-refresh\";\n} | {\n    type: \"focus-gained\";\n} | {\n    type: \"initial\";\n} | {\n    type: \"interval\";\n    minAge: number;\n};\n/**\n * Git store configuration (passed when initializing)\n */\nexport interface GitStoreConfig {\n    dir: string;\n    gitClient: GitClient;\n    fs: FsPromisesLike;\n    /** Callback for notifications */\n    onNotify?: (notification: GitNotification) => void;\n}\n/**\n * Notification from git actions\n */\nexport interface GitNotification {\n    type: \"success\" | \"error\" | \"info\";\n    title: string;\n    description?: string;\n}\n/**\n * FileChange type compatible with DiffBlock components\n */\nexport interface FileChange {\n    path: string;\n    status: UIFileStatus;\n    oldPath?: string;\n    staged: boolean;\n    /** Number of added lines (computed from diff when available) */\n    additions?: number;\n    /** Number of deleted lines (computed from diff when available) */\n    deletions?: number;\n    /** True for empty directory entries (no files inside yet) */\n    isDirectory?: boolean;\n}\nexport type { FileDiff, StashEntry, GitClient, FsPromisesLike };\n//# sourceMappingURL=types.d.ts.map",
      "useGitStatus.d.ts": "import type { FileChange } from \"./store/types\";\n/**\n * Result of useGitStatus hook\n */\nexport interface UseGitStatusResult {\n    /** Files with staged changes */\n    stagedFiles: FileChange[];\n    /** Files with unstaged changes */\n    unstagedFiles: FileChange[];\n    /** Files that appear in both staged and unstaged (partially staged) */\n    partiallyStagedFiles: Set<string>;\n    /** Whether there are any staged changes */\n    hasStaged: boolean;\n    /** Whether there are any changes (staged or unstaged) */\n    hasChanges: boolean;\n    /** Current branch name */\n    branch: string | null;\n    /** Whether initial load is in progress */\n    loading: boolean;\n    /** Whether a refresh is in progress */\n    refreshing: boolean;\n    /** Error from last operation */\n    error: Error | null;\n    /** Whether the store has been initialized */\n    initialized: boolean;\n}\n/**\n * Hook to read git status from the global store.\n *\n * IMPORTANT: This hook only reads state. The store must be initialized\n * separately using `initializeStoreAtom` before this hook returns useful data.\n * GitStatusView handles initialization automatically.\n *\n * @example\n * ```tsx\n * // In a component that's a child of GitStatusView:\n * function MyComponent() {\n *   const { stagedFiles, loading } = useGitStatus();\n *   if (loading) return <Spinner />;\n *   return <FileList files={stagedFiles} />;\n * }\n * ```\n */\nexport declare function useGitStatus(): UseGitStatusResult;\n//# sourceMappingURL=useGitStatus.d.ts.map",
      "utils/buildTree.d.ts": "import type { FileChange } from \"../store/types\";\n/**\n * Tree node representation for file hierarchy\n */\nexport interface TreeNode {\n    name: string;\n    path: string;\n    isDirectory: boolean;\n    children: TreeNode[];\n    file?: FileChange;\n}\n/**\n * Build a tree structure from a flat list of file changes.\n * Used by both FileTree and FileOverview components.\n *\n * @param files - Array of file changes to build tree from\n * @returns Root tree node with nested children\n */\nexport declare function buildTree(files: FileChange[]): TreeNode;\n//# sourceMappingURL=buildTree.d.ts.map",
      "utils/formatRelativeTime.d.ts": "/**\n * Format a date as relative time (e.g., \"5m ago\", \"2h ago\", \"3d ago\")\n */\nexport declare function formatRelativeTime(date: Date): string;\n/**\n * Convert a Unix timestamp to a Date, handling both seconds and milliseconds.\n * Git timestamps are typically in seconds, but some APIs return milliseconds.\n *\n * Heuristic: If the timestamp is before year 2001 when interpreted as seconds,\n * assume it's in milliseconds. Year 2001 = ~978307200 seconds.\n *\n * @param timestamp - Unix timestamp (seconds or milliseconds)\n * @returns Date object, or null if timestamp is invalid\n */\nexport declare function timestampToDate(timestamp: number): Date | null;\n//# sourceMappingURL=formatRelativeTime.d.ts.map",
      "utils/index.d.ts": "export { formatRelativeTime, timestampToDate } from \"./formatRelativeTime\";\nexport { buildTree, type TreeNode } from \"./buildTree\";\n//# sourceMappingURL=index.d.ts.map"
    },
    "subpaths": {
      "./constants": "constants.d.ts",
      "./monaco": "monaco.d.ts"
    }
  },
  "@natstack/react": {
    "files": {
      "FormRenderer.d.ts": "/**\n * FormRenderer Component\n *\n * Renders data-driven forms from field definitions.\n * Supports conditionality, notched sliders, and multiple field types.\n */\nimport type { FieldDefinition, FieldValue, FormSchema } from \"@natstack/runtime\";\n/**\n * Props for custom field renderer components.\n * Used with customFieldRenderers to handle custom field types like toolPreview.\n */\nexport interface CustomFieldRendererProps {\n    field: FieldDefinition;\n    value: FieldValue;\n    theme?: \"light\" | \"dark\";\n}\nexport interface FormRendererProps {\n    /** Field definitions or full form schema */\n    schema: FormSchema | FieldDefinition[];\n    /** Current values for each field */\n    values: Record<string, FieldValue>;\n    /** Callback when a value changes */\n    onChange: (key: string, value: FieldValue) => void;\n    /**\n     * Optional callback for form submission (used by buttonGroup with submitOnSelect)\n     */\n    onSubmit?: () => void;\n    /**\n     * Size of form controls\n     * @default \"2\"\n     */\n    size?: \"1\" | \"2\" | \"3\";\n    /**\n     * Whether to group fields by their `group` property\n     * @default true\n     */\n    showGroups?: boolean;\n    /**\n     * Whether to show field descriptions\n     * @default true\n     */\n    showDescriptions?: boolean;\n    /**\n     * Whether to show required/optional indicators\n     * @default false\n     */\n    showRequiredIndicators?: boolean;\n    /**\n     * Whether to stop click propagation on inputs\n     * @default false\n     */\n    stopPropagation?: boolean;\n    /**\n     * Custom field renderers for handling additional field types.\n     * Keys are field type names (e.g., \"toolPreview\"), values are React components.\n     * This allows injecting custom rendering without circular dependencies.\n     */\n    customFieldRenderers?: Record<string, React.ComponentType<CustomFieldRendererProps>>;\n    /**\n     * Theme for custom field renderers\n     * @default \"dark\"\n     */\n    theme?: \"light\" | \"dark\";\n}\n/**\n * Renders a data-driven form from field definitions.\n */\nexport declare function FormRenderer({ schema, values, onChange, onSubmit, size, showGroups, showDescriptions, showRequiredIndicators, stopPropagation, customFieldRenderers, theme, }: FormRendererProps): import(\"react/jsx-runtime\").JSX.Element;\n//# sourceMappingURL=FormRenderer.d.ts.map",
      "ParameterEditor.d.ts": "/**\n * ParameterEditor Component\n *\n * Thin wrapper around FormRenderer for backwards compatibility.\n * Used by agent-manager (preferences) and pubsub-chat (pre-connection setup).\n *\n * @deprecated Use FormRenderer directly for new code\n */\nimport type { FieldDefinition, FieldValue } from \"@natstack/runtime\";\n/**\n * Format slider value for display based on field definition hints.\n * Supports notched sliders, temperature-like decimals, and token counts.\n */\nexport declare function formatSliderValue(value: number, field: FieldDefinition): string;\n/**\n * Group parameters by their group field\n * @deprecated Use groupFields from @natstack/runtime\n */\nexport declare function groupParameters(parameters: FieldDefinition[]): Map<string, FieldDefinition[]>;\nexport interface ParameterEditorProps {\n    /** Parameter definitions to render */\n    parameters: FieldDefinition[];\n    /** Current values for each parameter */\n    values: Record<string, FieldValue>;\n    /** Callback when a value changes */\n    onChange: (key: string, value: FieldValue) => void;\n    /**\n     * Size of form controls\n     * @default \"2\"\n     */\n    size?: \"1\" | \"2\" | \"3\";\n    /**\n     * Whether to group parameters by their `group` field\n     * @default true\n     */\n    showGroups?: boolean;\n    /**\n     * Whether to show required/optional indicators\n     * @default false\n     */\n    showRequiredIndicators?: boolean;\n    /**\n     * Whether to stop click propagation on inputs\n     * (useful when editor is inside a clickable container)\n     * @default false\n     */\n    stopPropagation?: boolean;\n}\n/**\n * Renders a form for editing agent parameters.\n *\n * @deprecated Use FormRenderer directly for new code\n */\nexport declare function ParameterEditor({ parameters, values, onChange, size, showGroups, showRequiredIndicators, stopPropagation, }: ParameterEditorProps): import(\"react/jsx-runtime\").JSX.Element;\n//# sourceMappingURL=ParameterEditor.d.ts.map",
      "autoMount.d.ts": "/**\n * Auto-mounting system for React panels with zero configuration.\n * This module automatically mounts default exports or named App exports.\n */\nexport interface AutoMountConfig {\n    rootId?: string;\n    enableTheme?: boolean;\n}\n/**\n * Auto-mount a React component from a module.\n * Looks for default export or named \"App\" export.\n *\n * @param userModule - The imported user module\n * @param config - Auto-mount configuration\n */\nexport declare function autoMountReactPanel(userModule: any, config?: AutoMountConfig): void;\n/**\n * Detects if a module should be auto-mounted.\n * Returns false if the module manually calls mount().\n */\nexport declare function shouldAutoMount(userModule: any): boolean;\n//# sourceMappingURL=autoMount.d.ts.map",
      "hooks.d.ts": "/**\n * React hooks for NatStack panel development.\n * Provides declarative, idiomatic React APIs for panel features.\n */\nimport * as runtime from \"@natstack/runtime\";\nimport { Rpc } from \"@natstack/runtime\";\nimport type { CreateChildOptions, ChildHandle, ParentHandle, ThemeAppearance, BootstrapResult } from \"@natstack/runtime\";\n/**\n * Get the panel API object.\n * This is the same as importing panelAPI directly, but as a hook for consistency.\n *\n * @example\n * ```tsx\n * function MyPanel() {\n *   const panel = usePanel();\n *   const handleClick = () => panel.setTitle(\"New Title\");\n *   return <button onClick={handleClick}>Rename</button>;\n * }\n * ```\n */\nexport declare function usePanel(): typeof runtime;\n/**\n * Get the current panel's theme and subscribe to theme changes.\n *\n * @example\n * ```tsx\n * function MyPanel() {\n *   const theme = usePanelTheme();\n *   return <div>Current theme: {theme}</div>;\n * }\n * ```\n */\nexport declare function usePanelTheme(): ThemeAppearance;\n/**\n * Get the panel's ID.\n * This is a static value, so it's memoized.\n *\n * @example\n * ```tsx\n * function MyPanel() {\n *   const panelId = usePanelId();\n *   return <div>My ID: {panelId}</div>;\n * }\n * ```\n */\nexport declare function usePanelId(): string;\n/**\n * Get the panel's session ID.\n * Session ID format: {mode}_{type}_{identifier}\n * - mode: \"safe\" | \"unsafe\" - security context\n * - type: \"auto\" | \"named\" - auto = tree-derived, named = explicit\n * - identifier: tree path or random string\n *\n * Panels/workers with the same session share OPFS state.\n *\n * @example\n * ```tsx\n * function MyPanel() {\n *   const sessionId = useSessionId();\n *   return <div>Session: {sessionId}</div>;\n * }\n * ```\n */\nexport declare function useSessionId(): string;\n/**\n * Get the panel's partition name.\n *\n * @example\n * ```tsx\n * function MyPanel() {\n *   const partition = usePanelPartition();\n *   return <div>Storage partition: {partition ?? \"loading...\"}</div>;\n * }\n * ```\n */\nexport declare function usePanelPartition(): string | null;\n/**\n * Subscribe to global RPC events from any panel.\n *\n * @example\n * ```tsx\n * function MyPanel() {\n *   const [events, setEvents] = useState<Array<{ from: string; data: any }>>([]);\n *\n *   usePanelRpcGlobalEvent(\"status-update\", (fromPanelId, payload) => {\n *     setEvents(prev => [...prev, { from: fromPanelId, data: payload }]);\n *   });\n *\n *   return <div>Events: {events.length}</div>;\n * }\n * ```\n */\nexport declare function usePanelRpcGlobalEvent<T = unknown>(eventName: string, handler: (fromPanelId: string, payload: T) => void): void;\n/**\n * Get a typed handle for communicating with the parent panel.\n * Returns null if this panel has no parent (is root).\n *\n * @typeParam T - RPC methods the parent exposes\n * @typeParam E - RPC event map for typed events from parent\n *\n * @example\n * ```tsx\n * interface ParentApi {\n *   notifyReady(): Promise<void>;\n *   reportStatus(status: string): Promise<void>;\n * }\n *\n * function MyPanel() {\n *   const parent = usePanelParent<ParentApi>();\n *\n *   useEffect(() => {\n *     if (parent) {\n *       parent.call.notifyReady();\n *     }\n *   }, [parent]);\n *\n *   return <div>Has parent: {parent ? \"Yes\" : \"No\"}</div>;\n * }\n * ```\n */\nexport declare function usePanelParent<T extends Rpc.ExposedMethods = Rpc.ExposedMethods, E extends Rpc.RpcEventMap = Rpc.RpcEventMap>(): ParentHandle<T, E> | null;\n/**\n * Manage child panels.\n * Returns ChildHandles for unified interaction with children.\n * Note: Panels cannot be closed/removed - they are permanent history.\n *\n * @example\n * ```tsx\n * interface EditorApi {\n *   openFile(path: string): Promise<void>;\n * }\n *\n * function MyPanel() {\n *   const { children, createChild } = useChildPanels();\n *\n *   const handleAddChild = async () => {\n *     const editor = await createChild<EditorApi>({\n *       type: 'app',\n *       name: 'editor',\n *       source: 'panels/editor',\n *     });\n *     await editor.call.openFile('/foo.txt');\n *   };\n *\n *   return (\n *     <div>\n *       <button onClick={handleAddChild}>Add Child</button>\n *       <ul>\n *         {children.map(handle => (\n *           <li key={handle.id}>\n *             {handle.name} ({handle.type})\n *           </li>\n *         ))}\n *       </ul>\n *     </div>\n *   );\n * }\n * ```\n */\nexport declare function useChildPanels(): {\n    children: runtime.ChildHandle<import(\"node_modules/@natstack/runtime/dist/core/rpc\").ExposedMethods, import(\"node_modules/@natstack/runtime/dist/core/rpc\").RpcEventMap, import(\"node_modules/@natstack/runtime/dist/core/rpc\").RpcEventMap>[];\n    createChild: <T extends Rpc.ExposedMethods = import(\"node_modules/@natstack/runtime/dist/core/rpc\").ExposedMethods, E extends Rpc.RpcEventMap = import(\"node_modules/@natstack/runtime/dist/core/rpc\").RpcEventMap>(source: string, options?: CreateChildOptions) => Promise<ChildHandle<T, E>>;\n    createBrowserChild: <T extends Rpc.ExposedMethods = import(\"node_modules/@natstack/runtime/dist/core/rpc\").ExposedMethods, E extends Rpc.RpcEventMap = import(\"node_modules/@natstack/runtime/dist/core/rpc\").RpcEventMap>(url: string) => Promise<ChildHandle<T, E>>;\n};\n/**\n * Track focus state of the panel.\n *\n * @example\n * ```tsx\n * function MyPanel() {\n *   const isFocused = usePanelFocus();\n *   return (\n *     <div style={{ opacity: isFocused ? 1 : 0.5 }}>\n *       {isFocused ? \"Focused\" : \"Not focused\"}\n *     </div>\n *   );\n * }\n * ```\n */\nexport declare function usePanelFocus(): boolean;\n/**\n * Get a child handle by name with automatic updates.\n * Returns undefined if the child doesn't exist.\n *\n * @typeParam T - RPC methods the child exposes\n * @typeParam E - RPC event map for typed events\n * @param name - The child's name (as provided in createChild spec)\n * @returns ChildHandle or undefined if not found\n *\n * @example\n * ```tsx\n * interface EditorApi {\n *   openFile(path: string): Promise<void>;\n *   getContent(): Promise<string>;\n * }\n *\n * function MyPanel() {\n *   const editor = usePanelChild<EditorApi>(\"editor\");\n *\n *   const handleOpen = async () => {\n *     if (editor) {\n *       await editor.call.openFile(\"/foo.txt\");\n *     }\n *   };\n *\n *   return (\n *     <div>\n *       <button onClick={handleOpen} disabled={!editor}>\n *         Open File\n *       </button>\n *     </div>\n *   );\n * }\n * ```\n */\nexport declare function usePanelChild<T extends Rpc.ExposedMethods = Rpc.ExposedMethods, E extends Rpc.RpcEventMap = Rpc.RpcEventMap>(name: string): ChildHandle<T, E> | undefined;\n/**\n * Get all children as a Map with automatic updates.\n * Useful for rendering a list of children or iterating over them.\n *\n * Note: Ephemeral children can be closed/removed. The map updates automatically.\n *\n * @returns ReadonlyMap of child names to ChildHandles\n *\n * @example\n * ```tsx\n * function MyPanel() {\n *   const children = usePanelChildren();\n *\n *   return (\n *     <ul>\n *       {[...children.entries()].map(([name, handle]) => (\n *         <li key={handle.id}>\n *           {name} ({handle.type}) - {handle.title}\n *         </li>\n *       ))}\n *     </ul>\n *   );\n * }\n * ```\n */\nexport declare function usePanelChildren(): ReadonlyMap<string, ChildHandle>;\n/**\n * Create a child panel on first mount.\n * The child is created when the hook is first called.\n *\n * Note: Panels are permanent history and persist across component unmounts.\n * The handle is set to null on unmount to prevent state updates, but the\n * panel itself remains in the tree.\n *\n * @typeParam T - RPC methods the child exposes\n * @typeParam E - RPC event map for typed events\n * @param spec - Child specification (or null to skip creation)\n * @returns ChildHandle or null while loading/if spec is null\n *\n * @example\n * ```tsx\n * interface WorkerApi {\n *   compute(data: number[]): Promise<number>;\n * }\n *\n * function MyPanel() {\n *   const worker = usePanelCreateChild<WorkerApi>({\n *     type: \"worker\",\n *     name: \"compute-worker\",\n *     source: \"workers/compute\",\n *   });\n *\n *   const handleCompute = async () => {\n *     if (worker) {\n *       const result = await worker.call.compute([1, 2, 3]);\n *       console.log(\"Result:\", result);\n *     }\n *   };\n *\n *   return <button onClick={handleCompute}>Compute</button>;\n * }\n * ```\n */\nexport declare function usePanelCreateChild<T extends Rpc.ExposedMethods = Rpc.ExposedMethods, E extends Rpc.RpcEventMap = Rpc.RpcEventMap>(spec: null | {\n    kind: \"browser\";\n    url: string;\n} | {\n    kind?: \"appOrWorker\";\n    source: string;\n    options?: CreateChildOptions;\n}): ChildHandle<T, E> | null;\nexport interface BootstrapState {\n    /** Whether bootstrap is still in progress */\n    loading: boolean;\n    /** Bootstrap result (null if still loading or no bootstrap needed) */\n    result: BootstrapResult | null;\n    /** Error message if bootstrap failed */\n    error: string | null;\n}\n/**\n * Subscribe to bootstrap state.\n * Returns loading/result/error states for the bootstrap process.\n *\n * Bootstrap clones repoArgs repositories before panel code runs.\n * This hook allows panels to show loading UI while bootstrap completes.\n *\n * @returns BootstrapState with loading, result, and error fields\n *\n * @example\n * ```tsx\n * function MyPanel() {\n *   const bootstrap = useBootstrap();\n *\n *   if (bootstrap.loading) {\n *     return <div>Cloning repositories...</div>;\n *   }\n *\n *   if (bootstrap.error) {\n *     return <div>Bootstrap failed: {bootstrap.error}</div>;\n *   }\n *\n *   // Bootstrap complete - can now access cloned repos\n *   return <div>Ready! Source at {bootstrap.result?.sourcePath}</div>;\n * }\n * ```\n */\nexport declare function useBootstrap(): BootstrapState;\n/**\n * Get the bootstrap promise for direct awaiting.\n * Useful for imperative code that needs to wait for bootstrap.\n *\n * @returns Promise that resolves to BootstrapResult or null\n *\n * @example\n * ```tsx\n * async function initializeApp() {\n *   const bootstrap = await getBootstrapPromise();\n *   if (bootstrap?.success) {\n *     console.log(\"Source at:\", bootstrap.sourcePath);\n *   }\n * }\n * ```\n */\nexport declare function getBootstrapPromise(): Promise<BootstrapResult | null>;\n/**\n * Hook for use inside a Suspense boundary that waits for bootstrap.\n * Throws a promise while loading (for Suspense) or an error if bootstrap failed.\n *\n * @returns BootstrapResult or null if no bootstrap was needed\n * @throws Promise while bootstrap is in progress (for Suspense)\n * @throws Error if bootstrap failed\n *\n * @example\n * ```tsx\n * function BootstrappedContent() {\n *   const bootstrap = useBootstrapSuspense();\n *   return <div>Source at: {bootstrap?.sourcePath ?? \"N/A\"}</div>;\n * }\n *\n * function MyPanel() {\n *   return (\n *     <Suspense fallback={<div>Loading repos...</div>}>\n *       <BootstrappedContent />\n *     </Suspense>\n *   );\n * }\n * ```\n */\nexport declare function useBootstrapSuspense(): BootstrapResult | null;\n//# sourceMappingURL=hooks.d.ts.map",
      "index.d.ts": "/**\n * @natstack/react\n *\n * React bindings for NatStack panels. This provides:\n * - React hooks for panel state and RPC\n * - Auto-mount utilities for React panels\n * - React panel mounting helpers\n *\n * Use alongside @natstack/runtime for full functionality.\n */\nexport * from './hooks.js';\nexport { autoMountReactPanel, shouldAutoMount } from './autoMount.js';\nexport { createReactPanelMount, type ReactPanelOptions, type ReactPanelInstance } from './reactPanel.js';\nexport { FormRenderer, type FormRendererProps, type CustomFieldRendererProps } from './FormRenderer.js';\nexport { ParameterEditor, formatSliderValue, groupParameters, type ParameterEditorProps, } from './ParameterEditor.js';\n//# sourceMappingURL=index.d.ts.map",
      "reactPanel.d.ts": "import type { ComponentType, ReactNode } from \"react\";\nimport type { Root } from \"react-dom/client\";\nexport interface ReactPanelOptions {\n    rootId?: string;\n    ThemeComponent?: ComponentType<{\n        appearance: \"light\" | \"dark\";\n        children?: ReactNode;\n    }>;\n}\ntype ReactNamespace = typeof import(\"react\");\ntype CreateRootFn = typeof import(\"react-dom/client\").createRoot;\nexport interface ReactPanelInstance<Props> {\n    update: (nextProps?: Props) => void;\n    unmount: () => void;\n    root: Root;\n}\nexport declare function createReactPanelMount(ReactLib: ReactNamespace, createRootFn: CreateRootFn, options?: ReactPanelOptions): <Props>(Component: ComponentType<Props>, initialProps?: Props) => ReactPanelInstance<Props>;\nexport {};\n//# sourceMappingURL=reactPanel.d.ts.map"
    },
    "subpaths": {}
  },
  "@natstack/rpc": {
    "files": {
      "bridge.d.ts": "import type { RpcBridgeConfig, RpcBridgeInternal } from \"./types.js\";\nexport declare function createRpcBridge(config: RpcBridgeConfig): RpcBridgeInternal;\n//# sourceMappingURL=bridge.d.ts.map",
      "index.d.ts": "export type { RpcRequest, RpcResponse, RpcResponseSuccess, RpcResponseError, RpcEvent, RpcMessage, ExposedMethods, RpcEventListener, RpcTransport, RpcBridgeConfig, RpcBridge, RpcBridgeInternal, ServiceCallRequest, ServiceCallResponse, ServicePushEvent, ServiceInvokeRequest, ServiceInvokeResponse, ServiceHandler, } from \"./types.js\";\nexport { createRpcBridge } from \"./bridge.js\";\nexport { createHandlerRegistry } from \"./transport-helpers.js\";\n//# sourceMappingURL=index.d.ts.map",
      "transport-helpers.d.ts": "import type { RpcMessage } from \"./types.js\";\ntype AnyHandler = (sourceId: string, message: RpcMessage) => void;\nexport declare function createHandlerRegistry(options?: {\n    context?: string;\n}): {\n    deliver: (sourceId: string, message: RpcMessage) => void;\n    onMessage: (sourceId: string, handler: (message: RpcMessage) => void) => (() => void);\n    onAnyMessage: (handler: AnyHandler) => (() => void);\n};\nexport {};\n//# sourceMappingURL=transport-helpers.d.ts.map",
      "types.d.ts": "/**\n * Shared RPC types for panel/worker communication.\n *\n * This package is the single source of truth for the message protocol and\n * the in-process RPC bridge API (createRpcBridge).\n */\n/**\n * RPC request message sent between endpoints.\n */\nexport interface RpcRequest {\n    type: \"request\";\n    requestId: string;\n    fromId: string;\n    method: string;\n    args: unknown[];\n}\n/**\n * RPC response message (success case).\n */\nexport interface RpcResponseSuccess {\n    type: \"response\";\n    requestId: string;\n    result: unknown;\n}\n/**\n * RPC response message (error case).\n */\nexport interface RpcResponseError {\n    type: \"response\";\n    requestId: string;\n    error: string;\n}\n/**\n * Union type for RPC responses.\n */\nexport type RpcResponse = RpcResponseSuccess | RpcResponseError;\n/**\n * RPC event message for one-way notifications.\n */\nexport interface RpcEvent {\n    type: \"event\";\n    fromId: string;\n    event: string;\n    payload: unknown;\n}\n/**\n * Union type for all RPC messages.\n */\nexport type RpcMessage = RpcRequest | RpcResponse | RpcEvent;\n/**\n * Methods that can be exposed by an RPC endpoint.\n */\nexport type ExposedMethods = Record<string, (...args: unknown[]) => unknown | Promise<unknown>>;\n/**\n * Event listener callback type.\n */\nexport type RpcEventListener = (fromId: string, payload: unknown) => void;\n/**\n * Transport abstraction for sending and receiving RPC messages.\n */\nexport interface RpcTransport {\n    /**\n     * Send a message to a target endpoint.\n     */\n    send(targetId: string, message: RpcMessage): Promise<void>;\n    /**\n     * Register a handler for incoming messages from a specific source.\n     * Returns an unsubscribe function.\n     */\n    onMessage(sourceId: string, handler: (message: RpcMessage) => void): () => void;\n    /**\n     * Register a handler for messages from any source.\n     * Returns an unsubscribe function.\n     */\n    onAnyMessage(handler: (sourceId: string, message: RpcMessage) => void): () => void;\n}\nexport interface RpcBridgeConfig {\n    /** The ID of this endpoint (e.g., \"panel:abc\" or \"worker:xyz\") */\n    selfId: string;\n    /** The transport implementation */\n    transport: RpcTransport;\n    /** Timeout for RPC calls in milliseconds (default: 30000) */\n    callTimeoutMs?: number;\n    /** Timeout for AI-related calls (default: 300000) */\n    aiCallTimeoutMs?: number;\n}\n/**\n * RPC bridge interface exposed to user code.\n */\nexport interface RpcBridge {\n    readonly selfId: string;\n    expose(methods: ExposedMethods): void;\n    call<T = unknown>(targetId: string, method: string, ...args: unknown[]): Promise<T>;\n    emit(targetId: string, event: string, payload: unknown): Promise<void>;\n    onEvent(event: string, listener: RpcEventListener): () => void;\n}\n/**\n * Internal RPC bridge interface (for transport delivery).\n */\nexport interface RpcBridgeInternal extends RpcBridge {\n    _handleMessage(sourceId: string, message: RpcMessage): void;\n}\n/**\n * Parse an endpoint ID to determine its type.\n */\nexport declare function parseEndpointId(id: string): {\n    type: \"panel\" | \"worker\";\n    id: string;\n};\nexport declare function panelId(id: string): string;\nexport declare function workerId(id: string): string;\nexport interface ServiceCallRequest {\n    type: \"service:call\";\n    requestId: string;\n    workerId: string;\n    service: string;\n    method: string;\n    args: unknown[];\n}\nexport interface ServiceCallResponse {\n    type: \"service:response\";\n    requestId: string;\n    result?: unknown;\n    error?: string;\n}\nexport interface ServicePushEvent {\n    type: \"service:push\";\n    workerId: string;\n    service: string;\n    event: string;\n    payload: unknown;\n}\nexport interface ServiceInvokeRequest {\n    type: \"service:invoke\";\n    requestId: string;\n    workerId: string;\n    service: string;\n    method: string;\n    args: unknown[];\n}\nexport interface ServiceInvokeResponse {\n    type: \"service:invoke-response\";\n    requestId: string;\n    workerId: string;\n    result?: unknown;\n    error?: string;\n}\nexport type ServiceHandler = (workerId: string, method: string, args: unknown[]) => Promise<unknown> | unknown;\n//# sourceMappingURL=types.d.ts.map"
    },
    "subpaths": {}
  },
  "@natstack/pubsub": {
    "files": {
      "client.d.ts": "/**\n * PubSub WebSocket client implementation.\n *\n * Provides an async/generator-friendly API for pub/sub messaging.\n */\nimport type { Message, PublishOptions, UpdateMetadataOptions, ConnectOptions, RosterUpdate, ParticipantMetadata, Participant } from \"./types.js\";\n/**\n * PubSub client interface.\n */\nexport interface PubSubClient<T extends ParticipantMetadata = ParticipantMetadata> {\n    /** Async iterator for incoming messages */\n    messages(): AsyncIterableIterator<Message>;\n    /** Publish a message to the channel. Returns the message ID for persisted messages. */\n    publish<P>(type: string, payload: P, options?: PublishOptions): Promise<number | undefined>;\n    /** Update this client's participant metadata (triggers roster broadcast). */\n    updateMetadata(metadata: T, options?: UpdateMetadataOptions): Promise<void>;\n    /** Wait for the ready signal (replay complete). Throws if timeout exceeded. */\n    ready(timeoutMs?: number): Promise<void>;\n    /** Close the connection */\n    close(): void;\n    /** Whether currently connected */\n    readonly connected: boolean;\n    /** Whether currently attempting to reconnect */\n    readonly reconnecting: boolean;\n    /** Context ID for the channel (from server ready message) */\n    readonly contextId: string | undefined;\n    /** Register error handler. Returns unsubscribe function. */\n    onError(handler: (error: Error) => void): () => void;\n    /** Register disconnect handler. Returns unsubscribe function. */\n    onDisconnect(handler: () => void): () => void;\n    /** Register reconnect handler (called after successful reconnection). Returns unsubscribe function. */\n    onReconnect(handler: () => void): () => void;\n    /** Register roster update handler. Returns unsubscribe function. */\n    onRoster(handler: (roster: RosterUpdate<T>) => void): () => void;\n    /** Get the current roster participants (may be empty if no roster update received yet) */\n    readonly roster: Record<string, Participant<T>>;\n}\n/**\n * Connect to a PubSub channel.\n *\n * @param serverUrl - WebSocket server URL (e.g., \"ws://127.0.0.1:49452\")\n * @param token - Authentication token\n * @param options - Connection options including channel and optional sinceId\n * @returns A PubSubClient instance\n */\nexport declare function connect<T extends ParticipantMetadata = ParticipantMetadata>(serverUrl: string, token: string, options: ConnectOptions<T>): PubSubClient<T>;\n//# sourceMappingURL=client.d.ts.map",
      "index.d.ts": "/**\n * @natstack/pubsub - WebSocket pub/sub client for NatStack\n *\n * Provides real-time messaging between panels and workers via a persistent\n * WebSocket connection with SQLite-backed message history.\n *\n * @example Basic usage\n * ```typescript\n * import { connect } from \"@natstack/pubsub\";\n * import { pubsubConfig } from \"@natstack/runtime/panel\";\n *\n * // Connect to a channel\n * const client = connect(pubsubConfig.serverUrl, pubsubConfig.token, {\n *   channel: \"chat\",\n *   sinceId: lastKnownId, // Optional: resume from where you left off\n * });\n *\n * // Wait for ready (replay complete)\n * await client.ready();\n *\n * // Process messages\n * for await (const msg of client.messages()) {\n *   console.log(msg.type, msg.payload);\n * }\n * ```\n *\n * @example With auto-reconnection\n * ```typescript\n * const client = connect(serverUrl, token, {\n *   channel: \"chat\",\n *   reconnect: true, // Use defaults: 1s initial delay, 30s max, infinite attempts\n * });\n *\n * // Or with custom config\n * const client = connect(serverUrl, token, {\n *   channel: \"chat\",\n *   reconnect: { delayMs: 500, maxDelayMs: 10000, maxAttempts: 5 },\n * });\n *\n * client.onDisconnect(() => console.log(\"Disconnected, reconnecting...\"));\n * client.onReconnect(() => console.log(\"Reconnected!\"));\n * ```\n *\n * @example Presence / roster tracking with metadata\n * ```typescript\n * // Define your metadata type\n * interface UserMetadata {\n *   name: string;\n *   status: \"online\" | \"away\";\n * }\n *\n * // Connect with typed metadata\n * const client = connect<UserMetadata>(serverUrl, token, {\n *   channel: \"chat\",\n *   metadata: { name: \"Alice\", status: \"online\" },\n * });\n *\n * // Get notified when roster changes (idempotent - receives full state)\n * client.onRoster((roster) => {\n *   for (const [id, participant] of Object.entries(roster.participants)) {\n *     console.log(`${participant.metadata.name} is ${participant.metadata.status}`);\n *   }\n * });\n *\n * // Access current roster at any time\n * console.log(\"Currently online:\", Object.keys(client.roster));\n * ```\n */\nexport * from \"./types.js\";\nexport { connect } from \"./client.js\";\nexport type { PubSubClient } from \"./client.js\";\nimport { type PubSubClient } from \"./client.js\";\nimport { type ConnectOptions, type ParticipantMetadata } from \"./types.js\";\n/**\n * Connect using runtime-injected config.\n * For use in panels/workers where pubsubConfig is available.\n *\n * @example\n * ```typescript\n * import { connectWithConfig } from \"@natstack/pubsub\";\n * import { pubsubConfig } from \"@natstack/runtime/panel\";\n *\n * const client = connectWithConfig(pubsubConfig, { channel: \"notifications\" });\n * await client.ready();\n * ```\n */\nexport declare function connectWithConfig<T extends ParticipantMetadata = ParticipantMetadata>(config: {\n    serverUrl: string;\n    token: string;\n} | null, options: ConnectOptions<T>): PubSubClient<T>;\n//# sourceMappingURL=index.d.ts.map",
      "types.d.ts": "/**\n * Types for the PubSub client.\n */\n/**\n * Error codes for PubSub operations.\n */\nexport type PubSubErrorCode = \"auth\" | \"validation\" | \"connection\" | \"server\" | \"timeout\";\n/**\n * Typed error for PubSub operations.\n * Allows programmatic distinction between different error types.\n */\nexport declare class PubSubError extends Error {\n    readonly code: PubSubErrorCode;\n    constructor(message: string, code: PubSubErrorCode);\n}\n/**\n * A message received from the PubSub server.\n */\nexport interface PubSubMessage<T = unknown> {\n    /** Message kind: replay (historical), persisted (new + saved), or ephemeral (not saved) */\n    kind: \"replay\" | \"persisted\" | \"ephemeral\";\n    /** Message ID (only present for persisted/replay messages) */\n    id?: number;\n    /** User-defined message type */\n    type: string;\n    /** Message payload (JSON-serializable value) */\n    payload: T;\n    /** ID of the sender */\n    senderId: string;\n    /** Timestamp in milliseconds */\n    ts: number;\n    /** Binary attachment (separate from JSON payload) */\n    attachment?: Uint8Array;\n    /** Sender metadata snapshot (if available) */\n    senderMetadata?: Record<string, unknown>;\n}\n/**\n * Stream marker emitted after replay completes.\n */\nexport interface ReadyMessage {\n    kind: \"ready\";\n}\nexport type Message<T = unknown> = PubSubMessage<T> | ReadyMessage;\n/**\n * Participant metadata - arbitrary key-value data associated with a connected client.\n */\nexport type ParticipantMetadata = Record<string, unknown>;\n/**\n * A participant in a channel with their metadata.\n */\nexport interface Participant<T extends ParticipantMetadata = ParticipantMetadata> {\n    /** The client's unique ID */\n    id: string;\n    /** Arbitrary metadata provided by the client on connection */\n    metadata: T;\n}\n/**\n * Roster update from the server.\n * Sent whenever a client joins or leaves the channel.\n * This is idempotent - it contains the complete current state.\n */\nexport interface RosterUpdate<T extends ParticipantMetadata = ParticipantMetadata> {\n    /** Map of client ID to participant info (including metadata) */\n    participants: Record<string, Participant<T>>;\n    /** Timestamp of the update */\n    ts: number;\n}\n/**\n * Options for publishing a message.\n */\nexport interface PublishOptions {\n    /** Whether to persist the message to SQLite. Default: true */\n    persist?: boolean;\n    /** Timeout in milliseconds for the publish operation. Default: 30000 */\n    timeoutMs?: number;\n    /** Binary attachment to send alongside JSON payload */\n    attachment?: Uint8Array;\n}\n/**\n * Options for updating participant metadata.\n */\nexport interface UpdateMetadataOptions {\n    /** Timeout in milliseconds for the update operation. Default: 30000 */\n    timeoutMs?: number;\n}\n/**\n * Configuration for automatic reconnection.\n */\nexport interface ReconnectConfig {\n    /** Initial reconnect delay in ms. Default: 1000 */\n    delayMs?: number;\n    /** Maximum reconnect delay in ms (for exponential backoff). Default: 30000 */\n    maxDelayMs?: number;\n    /** Maximum reconnection attempts (0 = infinite). Default: 0 */\n    maxAttempts?: number;\n}\n/**\n * Options for connecting to a channel.\n */\nexport interface ConnectOptions<T extends ParticipantMetadata = ParticipantMetadata> {\n    /** Channel name to subscribe to */\n    channel: string;\n    /** Context ID for the channel (required for first connection, optional for joiners) */\n    contextId?: string;\n    /** Replay messages with id > sinceId */\n    sinceId?: number;\n    /** Enable auto-reconnection. Pass true for defaults, or a config object. Default: false */\n    reconnect?: boolean | ReconnectConfig;\n    /** Metadata to associate with this participant. Sent to all other participants in roster updates. */\n    metadata?: T;\n    /** This client's ID (used for skipOwnMessages filtering) */\n    clientId?: string;\n    /** Skip messages sent by this client (echo suppression). Requires clientId to be set. Default: false */\n    skipOwnMessages?: boolean;\n}\n//# sourceMappingURL=types.d.ts.map"
    },
    "subpaths": {}
  },
  "@natstack/agentic-messaging": {
    "files": {
      "agent-configs.d.ts": "/**\n * Centralized Agent Configuration Definitions\n *\n * Single source of truth for all agent parameters. Used by:\n * - Agent Manager to advertise agent capabilities\n * - Pre-connection UI (AgentSetupPhase) to render parameter inputs\n * - Workers to validate and merge initialization config\n * - Settings UI generator to create runtime settings forms\n */\nimport type { FieldDefinition, FieldValue } from \"@natstack/runtime\";\n/**\n * Fallback model lists for when SDK is unavailable.\n * These are used as default options in parameter definitions.\n */\nexport declare const CLAUDE_MODEL_FALLBACKS: Array<{\n    value: string;\n    label: string;\n    description?: string;\n}>;\nexport declare const AI_ROLE_FALLBACKS: Array<{\n    value: string;\n    label: string;\n    description?: string;\n}>;\n/**\n * Claude Code agent parameters\n */\nexport declare const CLAUDE_CODE_PARAMETERS: FieldDefinition[];\n/**\n * AI Responder (fast AI) agent parameters\n */\nexport declare const AI_RESPONDER_PARAMETERS: FieldDefinition[];\n/**\n * Codex agent parameters\n */\nexport declare const CODEX_PARAMETERS: FieldDefinition[];\n/**\n * Get default values from parameter definitions\n */\nexport declare function getParameterDefaults(parameters: FieldDefinition[]): Record<string, FieldValue>;\n//# sourceMappingURL=agent-configs.d.ts.map",
      "broker-client.d.ts": "/**\n * @natstack/agentic-messaging broker client\n *\n * API for discovering brokers and inviting agents.\n */\nimport type { AgenticClient, AgenticParticipantMetadata } from \"./types.js\";\nimport type { AgentTypeAdvertisement, BrokerClientOptions, BrokerQuery, DiscoveredBroker, InviteResponse, InviteResult } from \"./broker-types.js\";\n/**\n * Client for discovering brokers and inviting agents.\n */\nexport interface BrokerDiscoveryClient {\n    /** Underlying agentic client */\n    readonly client: AgenticClient<AgenticParticipantMetadata>;\n    /** Discover all available brokers */\n    discoverBrokers(): DiscoveredBroker[];\n    /** Discover brokers matching a query */\n    queryBrokers(query: BrokerQuery): DiscoveredBroker[];\n    /** Find agent types across all brokers matching a query */\n    findAgentTypes(query: BrokerQuery): Array<{\n        broker: DiscoveredBroker;\n        agentType: AgentTypeAdvertisement;\n    }>;\n    /** Send an invite to a broker */\n    invite(brokerId: string, agentTypeId: string, targetChannel: string, options?: {\n        config?: Record<string, unknown>;\n        context?: string;\n        timeoutMs?: number;\n    }): InviteResult;\n    /** Subscribe to broker roster changes */\n    onBrokersChanged(handler: (brokers: DiscoveredBroker[]) => void): () => void;\n    /** Close the connection */\n    close(): Promise<void>;\n}\n/**\n * Connect to the availability channel to discover and invite brokers.\n *\n * @example\n * ```ts\n * const discovery = await connectForDiscovery(serverUrl, token, {\n *   availabilityChannel: \"agent-availability\",\n *   name: \"My App\",\n *   type: \"client\",\n * });\n *\n * // Discover brokers\n * const brokers = discovery.discoverBrokers();\n *\n * // Query by capability\n * const codingBrokers = discovery.queryBrokers({\n *   providesMethods: [\"execute_code\"],\n *   tags: [\"coding\"],\n * });\n *\n * // Invite an agent\n * const result = discovery.invite(\n *   brokers[0].brokerId,\n *   \"code-assistant\",\n *   \"my-work-channel\",\n *   { context: \"Help me write a function\" }\n * );\n *\n * const response = await result.response;\n * if (response.accepted) {\n *   console.log(`Agent connected with ID: ${response.agentId}`);\n * }\n * ```\n */\nexport declare function connectForDiscovery(serverUrl: string, token: string, options: BrokerClientOptions): Promise<BrokerDiscoveryClient>;\n/**\n * Convenience function to invite an agent and wait for connection.\n * Combines discovery + invite in one call.\n *\n * @example\n * ```ts\n * const response = await inviteAgent(serverUrl, token, {\n *   availabilityChannel: \"agent-availability\",\n *   brokerId: \"broker-123\",\n *   agentTypeId: \"code-assistant\",\n *   targetChannel: \"my-work-channel\",\n *   clientName: \"My App\",\n *   timeoutMs: 30000,\n * });\n *\n * if (response.accepted) {\n *   // Agent is now connected to my-work-channel\n * }\n * ```\n */\nexport declare function inviteAgent(serverUrl: string, token: string, options: {\n    availabilityChannel: string;\n    brokerId: string;\n    agentTypeId: string;\n    targetChannel: string;\n    clientName: string;\n    clientHandle: string;\n    config?: Record<string, unknown>;\n    context?: string;\n    timeoutMs?: number;\n}): Promise<InviteResponse>;\n//# sourceMappingURL=broker-client.d.ts.map",
      "broker-entry.d.ts": "export * from \"./broker-types.js\";\nexport * from \"./broker-protocol.js\";\nexport { connectAsBroker, connectAsSelfBroker } from \"./broker.js\";\nexport { connectForDiscovery, inviteAgent } from \"./broker-client.js\";\nexport type { BrokerClient } from \"./broker.js\";\nexport type { BrokerDiscoveryClient } from \"./broker-client.js\";\n//# sourceMappingURL=broker-entry.d.ts.map",
      "broker-protocol.d.ts": "/**\n * @natstack/agentic-messaging broker protocol\n *\n * Zod schemas for broker invite/response messages.\n */\nimport { z } from \"zod\";\n/**\n * Schema for required method specification in agent type advertisements.\n */\nexport declare const RequiredMethodSpecSchema: z.ZodObject<{\n    name: z.ZodOptional<z.ZodString>;\n    pattern: z.ZodOptional<z.ZodString>;\n    description: z.ZodOptional<z.ZodString>;\n    required: z.ZodBoolean;\n}, \"strip\", z.ZodTypeAny, {\n    required: boolean;\n    name?: string | undefined;\n    pattern?: string | undefined;\n    description?: string | undefined;\n}, {\n    required: boolean;\n    name?: string | undefined;\n    pattern?: string | undefined;\n    description?: string | undefined;\n}>;\n/**\n * Schema for method advertisement (matching existing MethodAdvertisement structure).\n */\nexport declare const MethodAdvertisementSchema: z.ZodObject<{\n    name: z.ZodString;\n    description: z.ZodOptional<z.ZodString>;\n    parameters: z.ZodRecord<z.ZodString, z.ZodUnknown>;\n    returns: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnknown>>;\n    streaming: z.ZodOptional<z.ZodBoolean>;\n    timeout: z.ZodOptional<z.ZodNumber>;\n}, \"strip\", z.ZodTypeAny, {\n    name: string;\n    parameters: Record<string, unknown>;\n    description?: string | undefined;\n    returns?: Record<string, unknown> | undefined;\n    streaming?: boolean | undefined;\n    timeout?: number | undefined;\n}, {\n    name: string;\n    parameters: Record<string, unknown>;\n    description?: string | undefined;\n    returns?: Record<string, unknown> | undefined;\n    streaming?: boolean | undefined;\n    timeout?: number | undefined;\n}>;\n/**\n * Schema for field definition (formerly AgentParameterDefinition).\n * Matches FieldDefinition from @natstack/runtime.\n */\nexport declare const FieldDefinitionSchema: z.ZodObject<{\n    key: z.ZodString;\n    label: z.ZodOptional<z.ZodString>;\n    description: z.ZodOptional<z.ZodString>;\n    type: z.ZodEnum<[\"string\", \"number\", \"boolean\", \"select\", \"slider\", \"segmented\", \"toggle\", \"readonly\", \"code\", \"buttonGroup\", \"multiSelect\", \"diff\", \"toolPreview\", \"approvalHeader\"]>;\n    required: z.ZodOptional<z.ZodBoolean>;\n    default: z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber, z.ZodBoolean, z.ZodArray<z.ZodString, \"many\">]>>;\n    options: z.ZodOptional<z.ZodArray<z.ZodObject<{\n        value: z.ZodString;\n        label: z.ZodString;\n        description: z.ZodOptional<z.ZodString>;\n    }, \"strip\", z.ZodTypeAny, {\n        value: string;\n        label: string;\n        description?: string | undefined;\n    }, {\n        value: string;\n        label: string;\n        description?: string | undefined;\n    }>, \"many\">>;\n    placeholder: z.ZodOptional<z.ZodString>;\n    min: z.ZodOptional<z.ZodNumber>;\n    max: z.ZodOptional<z.ZodNumber>;\n    step: z.ZodOptional<z.ZodNumber>;\n    notches: z.ZodOptional<z.ZodArray<z.ZodObject<{\n        value: z.ZodNumber;\n        label: z.ZodString;\n        description: z.ZodOptional<z.ZodString>;\n    }, \"strip\", z.ZodTypeAny, {\n        value: number;\n        label: string;\n        description?: string | undefined;\n    }, {\n        value: number;\n        label: string;\n        description?: string | undefined;\n    }>, \"many\">>;\n    sliderLabels: z.ZodOptional<z.ZodObject<{\n        min: z.ZodOptional<z.ZodString>;\n        max: z.ZodOptional<z.ZodString>;\n    }, \"strip\", z.ZodTypeAny, {\n        min?: string | undefined;\n        max?: string | undefined;\n    }, {\n        min?: string | undefined;\n        max?: string | undefined;\n    }>>;\n    group: z.ZodOptional<z.ZodString>;\n    order: z.ZodOptional<z.ZodNumber>;\n    visibleWhen: z.ZodOptional<z.ZodUnion<[z.ZodObject<{\n        field: z.ZodString;\n        operator: z.ZodEnum<[\"eq\", \"neq\", \"gt\", \"gte\", \"lt\", \"lte\", \"in\"]>;\n        value: z.ZodUnion<[z.ZodUnion<[z.ZodString, z.ZodNumber, z.ZodBoolean]>, z.ZodArray<z.ZodUnion<[z.ZodString, z.ZodNumber, z.ZodBoolean]>, \"many\">]>;\n    }, \"strip\", z.ZodTypeAny, {\n        value: string | number | boolean | (string | number | boolean)[];\n        field: string;\n        operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n    }, {\n        value: string | number | boolean | (string | number | boolean)[];\n        field: string;\n        operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n    }>, z.ZodArray<z.ZodObject<{\n        field: z.ZodString;\n        operator: z.ZodEnum<[\"eq\", \"neq\", \"gt\", \"gte\", \"lt\", \"lte\", \"in\"]>;\n        value: z.ZodUnion<[z.ZodUnion<[z.ZodString, z.ZodNumber, z.ZodBoolean]>, z.ZodArray<z.ZodUnion<[z.ZodString, z.ZodNumber, z.ZodBoolean]>, \"many\">]>;\n    }, \"strip\", z.ZodTypeAny, {\n        value: string | number | boolean | (string | number | boolean)[];\n        field: string;\n        operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n    }, {\n        value: string | number | boolean | (string | number | boolean)[];\n        field: string;\n        operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n    }>, \"many\">]>>;\n    enabledWhen: z.ZodOptional<z.ZodUnion<[z.ZodObject<{\n        field: z.ZodString;\n        operator: z.ZodEnum<[\"eq\", \"neq\", \"gt\", \"gte\", \"lt\", \"lte\", \"in\"]>;\n        value: z.ZodUnion<[z.ZodUnion<[z.ZodString, z.ZodNumber, z.ZodBoolean]>, z.ZodArray<z.ZodUnion<[z.ZodString, z.ZodNumber, z.ZodBoolean]>, \"many\">]>;\n    }, \"strip\", z.ZodTypeAny, {\n        value: string | number | boolean | (string | number | boolean)[];\n        field: string;\n        operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n    }, {\n        value: string | number | boolean | (string | number | boolean)[];\n        field: string;\n        operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n    }>, z.ZodArray<z.ZodObject<{\n        field: z.ZodString;\n        operator: z.ZodEnum<[\"eq\", \"neq\", \"gt\", \"gte\", \"lt\", \"lte\", \"in\"]>;\n        value: z.ZodUnion<[z.ZodUnion<[z.ZodString, z.ZodNumber, z.ZodBoolean]>, z.ZodArray<z.ZodUnion<[z.ZodString, z.ZodNumber, z.ZodBoolean]>, \"many\">]>;\n    }, \"strip\", z.ZodTypeAny, {\n        value: string | number | boolean | (string | number | boolean)[];\n        field: string;\n        operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n    }, {\n        value: string | number | boolean | (string | number | boolean)[];\n        field: string;\n        operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n    }>, \"many\">]>>;\n    warnings: z.ZodOptional<z.ZodArray<z.ZodObject<{\n        when: z.ZodUnion<[z.ZodUnion<[z.ZodString, z.ZodNumber, z.ZodBoolean]>, z.ZodArray<z.ZodUnion<[z.ZodString, z.ZodNumber, z.ZodBoolean]>, \"many\">]>;\n        message: z.ZodString;\n        severity: z.ZodOptional<z.ZodEnum<[\"info\", \"warning\", \"danger\"]>>;\n    }, \"strip\", z.ZodTypeAny, {\n        message: string;\n        when: string | number | boolean | (string | number | boolean)[];\n        severity?: \"info\" | \"warning\" | \"danger\" | undefined;\n    }, {\n        message: string;\n        when: string | number | boolean | (string | number | boolean)[];\n        severity?: \"info\" | \"warning\" | \"danger\" | undefined;\n    }>, \"many\">>;\n    language: z.ZodOptional<z.ZodString>;\n    maxHeight: z.ZodOptional<z.ZodNumber>;\n    buttonStyle: z.ZodOptional<z.ZodEnum<[\"outline\", \"solid\", \"soft\"]>>;\n    buttons: z.ZodOptional<z.ZodArray<z.ZodObject<{\n        value: z.ZodString;\n        label: z.ZodString;\n        color: z.ZodOptional<z.ZodEnum<[\"gray\", \"green\", \"red\", \"amber\"]>>;\n        description: z.ZodOptional<z.ZodString>;\n    }, \"strip\", z.ZodTypeAny, {\n        value: string;\n        label: string;\n        description?: string | undefined;\n        color?: \"gray\" | \"green\" | \"red\" | \"amber\" | undefined;\n    }, {\n        value: string;\n        label: string;\n        description?: string | undefined;\n        color?: \"gray\" | \"green\" | \"red\" | \"amber\" | undefined;\n    }>, \"many\">>;\n    submitOnSelect: z.ZodOptional<z.ZodBoolean>;\n    toolName: z.ZodOptional<z.ZodString>;\n    toolArgs: z.ZodOptional<z.ZodUnknown>;\n    agentName: z.ZodOptional<z.ZodString>;\n    displayName: z.ZodOptional<z.ZodString>;\n    isFirstTimeGrant: z.ZodOptional<z.ZodBoolean>;\n    floorLevel: z.ZodOptional<z.ZodNumber>;\n}, \"strip\", z.ZodTypeAny, {\n    type: \"string\" | \"number\" | \"boolean\" | \"code\" | \"select\" | \"slider\" | \"segmented\" | \"toggle\" | \"readonly\" | \"buttonGroup\" | \"multiSelect\" | \"diff\" | \"toolPreview\" | \"approvalHeader\";\n    key: string;\n    description?: string | undefined;\n    required?: boolean | undefined;\n    options?: {\n        value: string;\n        label: string;\n        description?: string | undefined;\n    }[] | undefined;\n    label?: string | undefined;\n    default?: string | number | boolean | string[] | undefined;\n    placeholder?: string | undefined;\n    min?: number | undefined;\n    max?: number | undefined;\n    step?: number | undefined;\n    notches?: {\n        value: number;\n        label: string;\n        description?: string | undefined;\n    }[] | undefined;\n    sliderLabels?: {\n        min?: string | undefined;\n        max?: string | undefined;\n    } | undefined;\n    group?: string | undefined;\n    order?: number | undefined;\n    visibleWhen?: {\n        value: string | number | boolean | (string | number | boolean)[];\n        field: string;\n        operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n    } | {\n        value: string | number | boolean | (string | number | boolean)[];\n        field: string;\n        operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n    }[] | undefined;\n    enabledWhen?: {\n        value: string | number | boolean | (string | number | boolean)[];\n        field: string;\n        operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n    } | {\n        value: string | number | boolean | (string | number | boolean)[];\n        field: string;\n        operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n    }[] | undefined;\n    warnings?: {\n        message: string;\n        when: string | number | boolean | (string | number | boolean)[];\n        severity?: \"info\" | \"warning\" | \"danger\" | undefined;\n    }[] | undefined;\n    language?: string | undefined;\n    maxHeight?: number | undefined;\n    buttonStyle?: \"outline\" | \"solid\" | \"soft\" | undefined;\n    buttons?: {\n        value: string;\n        label: string;\n        description?: string | undefined;\n        color?: \"gray\" | \"green\" | \"red\" | \"amber\" | undefined;\n    }[] | undefined;\n    submitOnSelect?: boolean | undefined;\n    toolName?: string | undefined;\n    toolArgs?: unknown;\n    agentName?: string | undefined;\n    displayName?: string | undefined;\n    isFirstTimeGrant?: boolean | undefined;\n    floorLevel?: number | undefined;\n}, {\n    type: \"string\" | \"number\" | \"boolean\" | \"code\" | \"select\" | \"slider\" | \"segmented\" | \"toggle\" | \"readonly\" | \"buttonGroup\" | \"multiSelect\" | \"diff\" | \"toolPreview\" | \"approvalHeader\";\n    key: string;\n    description?: string | undefined;\n    required?: boolean | undefined;\n    options?: {\n        value: string;\n        label: string;\n        description?: string | undefined;\n    }[] | undefined;\n    label?: string | undefined;\n    default?: string | number | boolean | string[] | undefined;\n    placeholder?: string | undefined;\n    min?: number | undefined;\n    max?: number | undefined;\n    step?: number | undefined;\n    notches?: {\n        value: number;\n        label: string;\n        description?: string | undefined;\n    }[] | undefined;\n    sliderLabels?: {\n        min?: string | undefined;\n        max?: string | undefined;\n    } | undefined;\n    group?: string | undefined;\n    order?: number | undefined;\n    visibleWhen?: {\n        value: string | number | boolean | (string | number | boolean)[];\n        field: string;\n        operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n    } | {\n        value: string | number | boolean | (string | number | boolean)[];\n        field: string;\n        operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n    }[] | undefined;\n    enabledWhen?: {\n        value: string | number | boolean | (string | number | boolean)[];\n        field: string;\n        operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n    } | {\n        value: string | number | boolean | (string | number | boolean)[];\n        field: string;\n        operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n    }[] | undefined;\n    warnings?: {\n        message: string;\n        when: string | number | boolean | (string | number | boolean)[];\n        severity?: \"info\" | \"warning\" | \"danger\" | undefined;\n    }[] | undefined;\n    language?: string | undefined;\n    maxHeight?: number | undefined;\n    buttonStyle?: \"outline\" | \"solid\" | \"soft\" | undefined;\n    buttons?: {\n        value: string;\n        label: string;\n        description?: string | undefined;\n        color?: \"gray\" | \"green\" | \"red\" | \"amber\" | undefined;\n    }[] | undefined;\n    submitOnSelect?: boolean | undefined;\n    toolName?: string | undefined;\n    toolArgs?: unknown;\n    agentName?: string | undefined;\n    displayName?: string | undefined;\n    isFirstTimeGrant?: boolean | undefined;\n    floorLevel?: number | undefined;\n}>;\n/**\n * Schema for agent type advertisement.\n */\nexport declare const AgentTypeAdvertisementSchema: z.ZodObject<{\n    id: z.ZodString;\n    name: z.ZodString;\n    proposedHandle: z.ZodString;\n    description: z.ZodString;\n    providesMethods: z.ZodArray<z.ZodObject<{\n        name: z.ZodString;\n        description: z.ZodOptional<z.ZodString>;\n        parameters: z.ZodRecord<z.ZodString, z.ZodUnknown>;\n        returns: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnknown>>;\n        streaming: z.ZodOptional<z.ZodBoolean>;\n        timeout: z.ZodOptional<z.ZodNumber>;\n    }, \"strip\", z.ZodTypeAny, {\n        name: string;\n        parameters: Record<string, unknown>;\n        description?: string | undefined;\n        returns?: Record<string, unknown> | undefined;\n        streaming?: boolean | undefined;\n        timeout?: number | undefined;\n    }, {\n        name: string;\n        parameters: Record<string, unknown>;\n        description?: string | undefined;\n        returns?: Record<string, unknown> | undefined;\n        streaming?: boolean | undefined;\n        timeout?: number | undefined;\n    }>, \"many\">;\n    requiresMethods: z.ZodArray<z.ZodObject<{\n        name: z.ZodOptional<z.ZodString>;\n        pattern: z.ZodOptional<z.ZodString>;\n        description: z.ZodOptional<z.ZodString>;\n        required: z.ZodBoolean;\n    }, \"strip\", z.ZodTypeAny, {\n        required: boolean;\n        name?: string | undefined;\n        pattern?: string | undefined;\n        description?: string | undefined;\n    }, {\n        required: boolean;\n        name?: string | undefined;\n        pattern?: string | undefined;\n        description?: string | undefined;\n    }>, \"many\">;\n    parameters: z.ZodOptional<z.ZodArray<z.ZodObject<{\n        key: z.ZodString;\n        label: z.ZodOptional<z.ZodString>;\n        description: z.ZodOptional<z.ZodString>;\n        type: z.ZodEnum<[\"string\", \"number\", \"boolean\", \"select\", \"slider\", \"segmented\", \"toggle\", \"readonly\", \"code\", \"buttonGroup\", \"multiSelect\", \"diff\", \"toolPreview\", \"approvalHeader\"]>;\n        required: z.ZodOptional<z.ZodBoolean>;\n        default: z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber, z.ZodBoolean, z.ZodArray<z.ZodString, \"many\">]>>;\n        options: z.ZodOptional<z.ZodArray<z.ZodObject<{\n            value: z.ZodString;\n            label: z.ZodString;\n            description: z.ZodOptional<z.ZodString>;\n        }, \"strip\", z.ZodTypeAny, {\n            value: string;\n            label: string;\n            description?: string | undefined;\n        }, {\n            value: string;\n            label: string;\n            description?: string | undefined;\n        }>, \"many\">>;\n        placeholder: z.ZodOptional<z.ZodString>;\n        min: z.ZodOptional<z.ZodNumber>;\n        max: z.ZodOptional<z.ZodNumber>;\n        step: z.ZodOptional<z.ZodNumber>;\n        notches: z.ZodOptional<z.ZodArray<z.ZodObject<{\n            value: z.ZodNumber;\n            label: z.ZodString;\n            description: z.ZodOptional<z.ZodString>;\n        }, \"strip\", z.ZodTypeAny, {\n            value: number;\n            label: string;\n            description?: string | undefined;\n        }, {\n            value: number;\n            label: string;\n            description?: string | undefined;\n        }>, \"many\">>;\n        sliderLabels: z.ZodOptional<z.ZodObject<{\n            min: z.ZodOptional<z.ZodString>;\n            max: z.ZodOptional<z.ZodString>;\n        }, \"strip\", z.ZodTypeAny, {\n            min?: string | undefined;\n            max?: string | undefined;\n        }, {\n            min?: string | undefined;\n            max?: string | undefined;\n        }>>;\n        group: z.ZodOptional<z.ZodString>;\n        order: z.ZodOptional<z.ZodNumber>;\n        visibleWhen: z.ZodOptional<z.ZodUnion<[z.ZodObject<{\n            field: z.ZodString;\n            operator: z.ZodEnum<[\"eq\", \"neq\", \"gt\", \"gte\", \"lt\", \"lte\", \"in\"]>;\n            value: z.ZodUnion<[z.ZodUnion<[z.ZodString, z.ZodNumber, z.ZodBoolean]>, z.ZodArray<z.ZodUnion<[z.ZodString, z.ZodNumber, z.ZodBoolean]>, \"many\">]>;\n        }, \"strip\", z.ZodTypeAny, {\n            value: string | number | boolean | (string | number | boolean)[];\n            field: string;\n            operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n        }, {\n            value: string | number | boolean | (string | number | boolean)[];\n            field: string;\n            operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n        }>, z.ZodArray<z.ZodObject<{\n            field: z.ZodString;\n            operator: z.ZodEnum<[\"eq\", \"neq\", \"gt\", \"gte\", \"lt\", \"lte\", \"in\"]>;\n            value: z.ZodUnion<[z.ZodUnion<[z.ZodString, z.ZodNumber, z.ZodBoolean]>, z.ZodArray<z.ZodUnion<[z.ZodString, z.ZodNumber, z.ZodBoolean]>, \"many\">]>;\n        }, \"strip\", z.ZodTypeAny, {\n            value: string | number | boolean | (string | number | boolean)[];\n            field: string;\n            operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n        }, {\n            value: string | number | boolean | (string | number | boolean)[];\n            field: string;\n            operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n        }>, \"many\">]>>;\n        enabledWhen: z.ZodOptional<z.ZodUnion<[z.ZodObject<{\n            field: z.ZodString;\n            operator: z.ZodEnum<[\"eq\", \"neq\", \"gt\", \"gte\", \"lt\", \"lte\", \"in\"]>;\n            value: z.ZodUnion<[z.ZodUnion<[z.ZodString, z.ZodNumber, z.ZodBoolean]>, z.ZodArray<z.ZodUnion<[z.ZodString, z.ZodNumber, z.ZodBoolean]>, \"many\">]>;\n        }, \"strip\", z.ZodTypeAny, {\n            value: string | number | boolean | (string | number | boolean)[];\n            field: string;\n            operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n        }, {\n            value: string | number | boolean | (string | number | boolean)[];\n            field: string;\n            operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n        }>, z.ZodArray<z.ZodObject<{\n            field: z.ZodString;\n            operator: z.ZodEnum<[\"eq\", \"neq\", \"gt\", \"gte\", \"lt\", \"lte\", \"in\"]>;\n            value: z.ZodUnion<[z.ZodUnion<[z.ZodString, z.ZodNumber, z.ZodBoolean]>, z.ZodArray<z.ZodUnion<[z.ZodString, z.ZodNumber, z.ZodBoolean]>, \"many\">]>;\n        }, \"strip\", z.ZodTypeAny, {\n            value: string | number | boolean | (string | number | boolean)[];\n            field: string;\n            operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n        }, {\n            value: string | number | boolean | (string | number | boolean)[];\n            field: string;\n            operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n        }>, \"many\">]>>;\n        warnings: z.ZodOptional<z.ZodArray<z.ZodObject<{\n            when: z.ZodUnion<[z.ZodUnion<[z.ZodString, z.ZodNumber, z.ZodBoolean]>, z.ZodArray<z.ZodUnion<[z.ZodString, z.ZodNumber, z.ZodBoolean]>, \"many\">]>;\n            message: z.ZodString;\n            severity: z.ZodOptional<z.ZodEnum<[\"info\", \"warning\", \"danger\"]>>;\n        }, \"strip\", z.ZodTypeAny, {\n            message: string;\n            when: string | number | boolean | (string | number | boolean)[];\n            severity?: \"info\" | \"warning\" | \"danger\" | undefined;\n        }, {\n            message: string;\n            when: string | number | boolean | (string | number | boolean)[];\n            severity?: \"info\" | \"warning\" | \"danger\" | undefined;\n        }>, \"many\">>;\n        language: z.ZodOptional<z.ZodString>;\n        maxHeight: z.ZodOptional<z.ZodNumber>;\n        buttonStyle: z.ZodOptional<z.ZodEnum<[\"outline\", \"solid\", \"soft\"]>>;\n        buttons: z.ZodOptional<z.ZodArray<z.ZodObject<{\n            value: z.ZodString;\n            label: z.ZodString;\n            color: z.ZodOptional<z.ZodEnum<[\"gray\", \"green\", \"red\", \"amber\"]>>;\n            description: z.ZodOptional<z.ZodString>;\n        }, \"strip\", z.ZodTypeAny, {\n            value: string;\n            label: string;\n            description?: string | undefined;\n            color?: \"gray\" | \"green\" | \"red\" | \"amber\" | undefined;\n        }, {\n            value: string;\n            label: string;\n            description?: string | undefined;\n            color?: \"gray\" | \"green\" | \"red\" | \"amber\" | undefined;\n        }>, \"many\">>;\n        submitOnSelect: z.ZodOptional<z.ZodBoolean>;\n        toolName: z.ZodOptional<z.ZodString>;\n        toolArgs: z.ZodOptional<z.ZodUnknown>;\n        agentName: z.ZodOptional<z.ZodString>;\n        displayName: z.ZodOptional<z.ZodString>;\n        isFirstTimeGrant: z.ZodOptional<z.ZodBoolean>;\n        floorLevel: z.ZodOptional<z.ZodNumber>;\n    }, \"strip\", z.ZodTypeAny, {\n        type: \"string\" | \"number\" | \"boolean\" | \"code\" | \"select\" | \"slider\" | \"segmented\" | \"toggle\" | \"readonly\" | \"buttonGroup\" | \"multiSelect\" | \"diff\" | \"toolPreview\" | \"approvalHeader\";\n        key: string;\n        description?: string | undefined;\n        required?: boolean | undefined;\n        options?: {\n            value: string;\n            label: string;\n            description?: string | undefined;\n        }[] | undefined;\n        label?: string | undefined;\n        default?: string | number | boolean | string[] | undefined;\n        placeholder?: string | undefined;\n        min?: number | undefined;\n        max?: number | undefined;\n        step?: number | undefined;\n        notches?: {\n            value: number;\n            label: string;\n            description?: string | undefined;\n        }[] | undefined;\n        sliderLabels?: {\n            min?: string | undefined;\n            max?: string | undefined;\n        } | undefined;\n        group?: string | undefined;\n        order?: number | undefined;\n        visibleWhen?: {\n            value: string | number | boolean | (string | number | boolean)[];\n            field: string;\n            operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n        } | {\n            value: string | number | boolean | (string | number | boolean)[];\n            field: string;\n            operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n        }[] | undefined;\n        enabledWhen?: {\n            value: string | number | boolean | (string | number | boolean)[];\n            field: string;\n            operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n        } | {\n            value: string | number | boolean | (string | number | boolean)[];\n            field: string;\n            operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n        }[] | undefined;\n        warnings?: {\n            message: string;\n            when: string | number | boolean | (string | number | boolean)[];\n            severity?: \"info\" | \"warning\" | \"danger\" | undefined;\n        }[] | undefined;\n        language?: string | undefined;\n        maxHeight?: number | undefined;\n        buttonStyle?: \"outline\" | \"solid\" | \"soft\" | undefined;\n        buttons?: {\n            value: string;\n            label: string;\n            description?: string | undefined;\n            color?: \"gray\" | \"green\" | \"red\" | \"amber\" | undefined;\n        }[] | undefined;\n        submitOnSelect?: boolean | undefined;\n        toolName?: string | undefined;\n        toolArgs?: unknown;\n        agentName?: string | undefined;\n        displayName?: string | undefined;\n        isFirstTimeGrant?: boolean | undefined;\n        floorLevel?: number | undefined;\n    }, {\n        type: \"string\" | \"number\" | \"boolean\" | \"code\" | \"select\" | \"slider\" | \"segmented\" | \"toggle\" | \"readonly\" | \"buttonGroup\" | \"multiSelect\" | \"diff\" | \"toolPreview\" | \"approvalHeader\";\n        key: string;\n        description?: string | undefined;\n        required?: boolean | undefined;\n        options?: {\n            value: string;\n            label: string;\n            description?: string | undefined;\n        }[] | undefined;\n        label?: string | undefined;\n        default?: string | number | boolean | string[] | undefined;\n        placeholder?: string | undefined;\n        min?: number | undefined;\n        max?: number | undefined;\n        step?: number | undefined;\n        notches?: {\n            value: number;\n            label: string;\n            description?: string | undefined;\n        }[] | undefined;\n        sliderLabels?: {\n            min?: string | undefined;\n            max?: string | undefined;\n        } | undefined;\n        group?: string | undefined;\n        order?: number | undefined;\n        visibleWhen?: {\n            value: string | number | boolean | (string | number | boolean)[];\n            field: string;\n            operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n        } | {\n            value: string | number | boolean | (string | number | boolean)[];\n            field: string;\n            operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n        }[] | undefined;\n        enabledWhen?: {\n            value: string | number | boolean | (string | number | boolean)[];\n            field: string;\n            operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n        } | {\n            value: string | number | boolean | (string | number | boolean)[];\n            field: string;\n            operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n        }[] | undefined;\n        warnings?: {\n            message: string;\n            when: string | number | boolean | (string | number | boolean)[];\n            severity?: \"info\" | \"warning\" | \"danger\" | undefined;\n        }[] | undefined;\n        language?: string | undefined;\n        maxHeight?: number | undefined;\n        buttonStyle?: \"outline\" | \"solid\" | \"soft\" | undefined;\n        buttons?: {\n            value: string;\n            label: string;\n            description?: string | undefined;\n            color?: \"gray\" | \"green\" | \"red\" | \"amber\" | undefined;\n        }[] | undefined;\n        submitOnSelect?: boolean | undefined;\n        toolName?: string | undefined;\n        toolArgs?: unknown;\n        agentName?: string | undefined;\n        displayName?: string | undefined;\n        isFirstTimeGrant?: boolean | undefined;\n        floorLevel?: number | undefined;\n    }>, \"many\">>;\n    tags: z.ZodOptional<z.ZodArray<z.ZodString, \"many\">>;\n    version: z.ZodOptional<z.ZodString>;\n}, \"strip\", z.ZodTypeAny, {\n    name: string;\n    description: string;\n    id: string;\n    proposedHandle: string;\n    providesMethods: {\n        name: string;\n        parameters: Record<string, unknown>;\n        description?: string | undefined;\n        returns?: Record<string, unknown> | undefined;\n        streaming?: boolean | undefined;\n        timeout?: number | undefined;\n    }[];\n    requiresMethods: {\n        required: boolean;\n        name?: string | undefined;\n        pattern?: string | undefined;\n        description?: string | undefined;\n    }[];\n    parameters?: {\n        type: \"string\" | \"number\" | \"boolean\" | \"code\" | \"select\" | \"slider\" | \"segmented\" | \"toggle\" | \"readonly\" | \"buttonGroup\" | \"multiSelect\" | \"diff\" | \"toolPreview\" | \"approvalHeader\";\n        key: string;\n        description?: string | undefined;\n        required?: boolean | undefined;\n        options?: {\n            value: string;\n            label: string;\n            description?: string | undefined;\n        }[] | undefined;\n        label?: string | undefined;\n        default?: string | number | boolean | string[] | undefined;\n        placeholder?: string | undefined;\n        min?: number | undefined;\n        max?: number | undefined;\n        step?: number | undefined;\n        notches?: {\n            value: number;\n            label: string;\n            description?: string | undefined;\n        }[] | undefined;\n        sliderLabels?: {\n            min?: string | undefined;\n            max?: string | undefined;\n        } | undefined;\n        group?: string | undefined;\n        order?: number | undefined;\n        visibleWhen?: {\n            value: string | number | boolean | (string | number | boolean)[];\n            field: string;\n            operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n        } | {\n            value: string | number | boolean | (string | number | boolean)[];\n            field: string;\n            operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n        }[] | undefined;\n        enabledWhen?: {\n            value: string | number | boolean | (string | number | boolean)[];\n            field: string;\n            operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n        } | {\n            value: string | number | boolean | (string | number | boolean)[];\n            field: string;\n            operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n        }[] | undefined;\n        warnings?: {\n            message: string;\n            when: string | number | boolean | (string | number | boolean)[];\n            severity?: \"info\" | \"warning\" | \"danger\" | undefined;\n        }[] | undefined;\n        language?: string | undefined;\n        maxHeight?: number | undefined;\n        buttonStyle?: \"outline\" | \"solid\" | \"soft\" | undefined;\n        buttons?: {\n            value: string;\n            label: string;\n            description?: string | undefined;\n            color?: \"gray\" | \"green\" | \"red\" | \"amber\" | undefined;\n        }[] | undefined;\n        submitOnSelect?: boolean | undefined;\n        toolName?: string | undefined;\n        toolArgs?: unknown;\n        agentName?: string | undefined;\n        displayName?: string | undefined;\n        isFirstTimeGrant?: boolean | undefined;\n        floorLevel?: number | undefined;\n    }[] | undefined;\n    tags?: string[] | undefined;\n    version?: string | undefined;\n}, {\n    name: string;\n    description: string;\n    id: string;\n    proposedHandle: string;\n    providesMethods: {\n        name: string;\n        parameters: Record<string, unknown>;\n        description?: string | undefined;\n        returns?: Record<string, unknown> | undefined;\n        streaming?: boolean | undefined;\n        timeout?: number | undefined;\n    }[];\n    requiresMethods: {\n        required: boolean;\n        name?: string | undefined;\n        pattern?: string | undefined;\n        description?: string | undefined;\n    }[];\n    parameters?: {\n        type: \"string\" | \"number\" | \"boolean\" | \"code\" | \"select\" | \"slider\" | \"segmented\" | \"toggle\" | \"readonly\" | \"buttonGroup\" | \"multiSelect\" | \"diff\" | \"toolPreview\" | \"approvalHeader\";\n        key: string;\n        description?: string | undefined;\n        required?: boolean | undefined;\n        options?: {\n            value: string;\n            label: string;\n            description?: string | undefined;\n        }[] | undefined;\n        label?: string | undefined;\n        default?: string | number | boolean | string[] | undefined;\n        placeholder?: string | undefined;\n        min?: number | undefined;\n        max?: number | undefined;\n        step?: number | undefined;\n        notches?: {\n            value: number;\n            label: string;\n            description?: string | undefined;\n        }[] | undefined;\n        sliderLabels?: {\n            min?: string | undefined;\n            max?: string | undefined;\n        } | undefined;\n        group?: string | undefined;\n        order?: number | undefined;\n        visibleWhen?: {\n            value: string | number | boolean | (string | number | boolean)[];\n            field: string;\n            operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n        } | {\n            value: string | number | boolean | (string | number | boolean)[];\n            field: string;\n            operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n        }[] | undefined;\n        enabledWhen?: {\n            value: string | number | boolean | (string | number | boolean)[];\n            field: string;\n            operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n        } | {\n            value: string | number | boolean | (string | number | boolean)[];\n            field: string;\n            operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n        }[] | undefined;\n        warnings?: {\n            message: string;\n            when: string | number | boolean | (string | number | boolean)[];\n            severity?: \"info\" | \"warning\" | \"danger\" | undefined;\n        }[] | undefined;\n        language?: string | undefined;\n        maxHeight?: number | undefined;\n        buttonStyle?: \"outline\" | \"solid\" | \"soft\" | undefined;\n        buttons?: {\n            value: string;\n            label: string;\n            description?: string | undefined;\n            color?: \"gray\" | \"green\" | \"red\" | \"amber\" | undefined;\n        }[] | undefined;\n        submitOnSelect?: boolean | undefined;\n        toolName?: string | undefined;\n        toolArgs?: unknown;\n        agentName?: string | undefined;\n        displayName?: string | undefined;\n        isFirstTimeGrant?: boolean | undefined;\n        floorLevel?: number | undefined;\n    }[] | undefined;\n    tags?: string[] | undefined;\n    version?: string | undefined;\n}>;\n/**\n * Schema for broker metadata.\n */\nexport declare const BrokerMetadataSchema: z.ZodObject<{\n    name: z.ZodString;\n    type: z.ZodString;\n    isBroker: z.ZodLiteral<true>;\n    agentTypes: z.ZodArray<z.ZodObject<{\n        id: z.ZodString;\n        name: z.ZodString;\n        proposedHandle: z.ZodString;\n        description: z.ZodString;\n        providesMethods: z.ZodArray<z.ZodObject<{\n            name: z.ZodString;\n            description: z.ZodOptional<z.ZodString>;\n            parameters: z.ZodRecord<z.ZodString, z.ZodUnknown>;\n            returns: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnknown>>;\n            streaming: z.ZodOptional<z.ZodBoolean>;\n            timeout: z.ZodOptional<z.ZodNumber>;\n        }, \"strip\", z.ZodTypeAny, {\n            name: string;\n            parameters: Record<string, unknown>;\n            description?: string | undefined;\n            returns?: Record<string, unknown> | undefined;\n            streaming?: boolean | undefined;\n            timeout?: number | undefined;\n        }, {\n            name: string;\n            parameters: Record<string, unknown>;\n            description?: string | undefined;\n            returns?: Record<string, unknown> | undefined;\n            streaming?: boolean | undefined;\n            timeout?: number | undefined;\n        }>, \"many\">;\n        requiresMethods: z.ZodArray<z.ZodObject<{\n            name: z.ZodOptional<z.ZodString>;\n            pattern: z.ZodOptional<z.ZodString>;\n            description: z.ZodOptional<z.ZodString>;\n            required: z.ZodBoolean;\n        }, \"strip\", z.ZodTypeAny, {\n            required: boolean;\n            name?: string | undefined;\n            pattern?: string | undefined;\n            description?: string | undefined;\n        }, {\n            required: boolean;\n            name?: string | undefined;\n            pattern?: string | undefined;\n            description?: string | undefined;\n        }>, \"many\">;\n        parameters: z.ZodOptional<z.ZodArray<z.ZodObject<{\n            key: z.ZodString;\n            label: z.ZodOptional<z.ZodString>;\n            description: z.ZodOptional<z.ZodString>;\n            type: z.ZodEnum<[\"string\", \"number\", \"boolean\", \"select\", \"slider\", \"segmented\", \"toggle\", \"readonly\", \"code\", \"buttonGroup\", \"multiSelect\", \"diff\", \"toolPreview\", \"approvalHeader\"]>;\n            required: z.ZodOptional<z.ZodBoolean>;\n            default: z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber, z.ZodBoolean, z.ZodArray<z.ZodString, \"many\">]>>;\n            options: z.ZodOptional<z.ZodArray<z.ZodObject<{\n                value: z.ZodString;\n                label: z.ZodString;\n                description: z.ZodOptional<z.ZodString>;\n            }, \"strip\", z.ZodTypeAny, {\n                value: string;\n                label: string;\n                description?: string | undefined;\n            }, {\n                value: string;\n                label: string;\n                description?: string | undefined;\n            }>, \"many\">>;\n            placeholder: z.ZodOptional<z.ZodString>;\n            min: z.ZodOptional<z.ZodNumber>;\n            max: z.ZodOptional<z.ZodNumber>;\n            step: z.ZodOptional<z.ZodNumber>;\n            notches: z.ZodOptional<z.ZodArray<z.ZodObject<{\n                value: z.ZodNumber;\n                label: z.ZodString;\n                description: z.ZodOptional<z.ZodString>;\n            }, \"strip\", z.ZodTypeAny, {\n                value: number;\n                label: string;\n                description?: string | undefined;\n            }, {\n                value: number;\n                label: string;\n                description?: string | undefined;\n            }>, \"many\">>;\n            sliderLabels: z.ZodOptional<z.ZodObject<{\n                min: z.ZodOptional<z.ZodString>;\n                max: z.ZodOptional<z.ZodString>;\n            }, \"strip\", z.ZodTypeAny, {\n                min?: string | undefined;\n                max?: string | undefined;\n            }, {\n                min?: string | undefined;\n                max?: string | undefined;\n            }>>;\n            group: z.ZodOptional<z.ZodString>;\n            order: z.ZodOptional<z.ZodNumber>;\n            visibleWhen: z.ZodOptional<z.ZodUnion<[z.ZodObject<{\n                field: z.ZodString;\n                operator: z.ZodEnum<[\"eq\", \"neq\", \"gt\", \"gte\", \"lt\", \"lte\", \"in\"]>;\n                value: z.ZodUnion<[z.ZodUnion<[z.ZodString, z.ZodNumber, z.ZodBoolean]>, z.ZodArray<z.ZodUnion<[z.ZodString, z.ZodNumber, z.ZodBoolean]>, \"many\">]>;\n            }, \"strip\", z.ZodTypeAny, {\n                value: string | number | boolean | (string | number | boolean)[];\n                field: string;\n                operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n            }, {\n                value: string | number | boolean | (string | number | boolean)[];\n                field: string;\n                operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n            }>, z.ZodArray<z.ZodObject<{\n                field: z.ZodString;\n                operator: z.ZodEnum<[\"eq\", \"neq\", \"gt\", \"gte\", \"lt\", \"lte\", \"in\"]>;\n                value: z.ZodUnion<[z.ZodUnion<[z.ZodString, z.ZodNumber, z.ZodBoolean]>, z.ZodArray<z.ZodUnion<[z.ZodString, z.ZodNumber, z.ZodBoolean]>, \"many\">]>;\n            }, \"strip\", z.ZodTypeAny, {\n                value: string | number | boolean | (string | number | boolean)[];\n                field: string;\n                operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n            }, {\n                value: string | number | boolean | (string | number | boolean)[];\n                field: string;\n                operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n            }>, \"many\">]>>;\n            enabledWhen: z.ZodOptional<z.ZodUnion<[z.ZodObject<{\n                field: z.ZodString;\n                operator: z.ZodEnum<[\"eq\", \"neq\", \"gt\", \"gte\", \"lt\", \"lte\", \"in\"]>;\n                value: z.ZodUnion<[z.ZodUnion<[z.ZodString, z.ZodNumber, z.ZodBoolean]>, z.ZodArray<z.ZodUnion<[z.ZodString, z.ZodNumber, z.ZodBoolean]>, \"many\">]>;\n            }, \"strip\", z.ZodTypeAny, {\n                value: string | number | boolean | (string | number | boolean)[];\n                field: string;\n                operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n            }, {\n                value: string | number | boolean | (string | number | boolean)[];\n                field: string;\n                operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n            }>, z.ZodArray<z.ZodObject<{\n                field: z.ZodString;\n                operator: z.ZodEnum<[\"eq\", \"neq\", \"gt\", \"gte\", \"lt\", \"lte\", \"in\"]>;\n                value: z.ZodUnion<[z.ZodUnion<[z.ZodString, z.ZodNumber, z.ZodBoolean]>, z.ZodArray<z.ZodUnion<[z.ZodString, z.ZodNumber, z.ZodBoolean]>, \"many\">]>;\n            }, \"strip\", z.ZodTypeAny, {\n                value: string | number | boolean | (string | number | boolean)[];\n                field: string;\n                operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n            }, {\n                value: string | number | boolean | (string | number | boolean)[];\n                field: string;\n                operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n            }>, \"many\">]>>;\n            warnings: z.ZodOptional<z.ZodArray<z.ZodObject<{\n                when: z.ZodUnion<[z.ZodUnion<[z.ZodString, z.ZodNumber, z.ZodBoolean]>, z.ZodArray<z.ZodUnion<[z.ZodString, z.ZodNumber, z.ZodBoolean]>, \"many\">]>;\n                message: z.ZodString;\n                severity: z.ZodOptional<z.ZodEnum<[\"info\", \"warning\", \"danger\"]>>;\n            }, \"strip\", z.ZodTypeAny, {\n                message: string;\n                when: string | number | boolean | (string | number | boolean)[];\n                severity?: \"info\" | \"warning\" | \"danger\" | undefined;\n            }, {\n                message: string;\n                when: string | number | boolean | (string | number | boolean)[];\n                severity?: \"info\" | \"warning\" | \"danger\" | undefined;\n            }>, \"many\">>;\n            language: z.ZodOptional<z.ZodString>;\n            maxHeight: z.ZodOptional<z.ZodNumber>;\n            buttonStyle: z.ZodOptional<z.ZodEnum<[\"outline\", \"solid\", \"soft\"]>>;\n            buttons: z.ZodOptional<z.ZodArray<z.ZodObject<{\n                value: z.ZodString;\n                label: z.ZodString;\n                color: z.ZodOptional<z.ZodEnum<[\"gray\", \"green\", \"red\", \"amber\"]>>;\n                description: z.ZodOptional<z.ZodString>;\n            }, \"strip\", z.ZodTypeAny, {\n                value: string;\n                label: string;\n                description?: string | undefined;\n                color?: \"gray\" | \"green\" | \"red\" | \"amber\" | undefined;\n            }, {\n                value: string;\n                label: string;\n                description?: string | undefined;\n                color?: \"gray\" | \"green\" | \"red\" | \"amber\" | undefined;\n            }>, \"many\">>;\n            submitOnSelect: z.ZodOptional<z.ZodBoolean>;\n            toolName: z.ZodOptional<z.ZodString>;\n            toolArgs: z.ZodOptional<z.ZodUnknown>;\n            agentName: z.ZodOptional<z.ZodString>;\n            displayName: z.ZodOptional<z.ZodString>;\n            isFirstTimeGrant: z.ZodOptional<z.ZodBoolean>;\n            floorLevel: z.ZodOptional<z.ZodNumber>;\n        }, \"strip\", z.ZodTypeAny, {\n            type: \"string\" | \"number\" | \"boolean\" | \"code\" | \"select\" | \"slider\" | \"segmented\" | \"toggle\" | \"readonly\" | \"buttonGroup\" | \"multiSelect\" | \"diff\" | \"toolPreview\" | \"approvalHeader\";\n            key: string;\n            description?: string | undefined;\n            required?: boolean | undefined;\n            options?: {\n                value: string;\n                label: string;\n                description?: string | undefined;\n            }[] | undefined;\n            label?: string | undefined;\n            default?: string | number | boolean | string[] | undefined;\n            placeholder?: string | undefined;\n            min?: number | undefined;\n            max?: number | undefined;\n            step?: number | undefined;\n            notches?: {\n                value: number;\n                label: string;\n                description?: string | undefined;\n            }[] | undefined;\n            sliderLabels?: {\n                min?: string | undefined;\n                max?: string | undefined;\n            } | undefined;\n            group?: string | undefined;\n            order?: number | undefined;\n            visibleWhen?: {\n                value: string | number | boolean | (string | number | boolean)[];\n                field: string;\n                operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n            } | {\n                value: string | number | boolean | (string | number | boolean)[];\n                field: string;\n                operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n            }[] | undefined;\n            enabledWhen?: {\n                value: string | number | boolean | (string | number | boolean)[];\n                field: string;\n                operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n            } | {\n                value: string | number | boolean | (string | number | boolean)[];\n                field: string;\n                operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n            }[] | undefined;\n            warnings?: {\n                message: string;\n                when: string | number | boolean | (string | number | boolean)[];\n                severity?: \"info\" | \"warning\" | \"danger\" | undefined;\n            }[] | undefined;\n            language?: string | undefined;\n            maxHeight?: number | undefined;\n            buttonStyle?: \"outline\" | \"solid\" | \"soft\" | undefined;\n            buttons?: {\n                value: string;\n                label: string;\n                description?: string | undefined;\n                color?: \"gray\" | \"green\" | \"red\" | \"amber\" | undefined;\n            }[] | undefined;\n            submitOnSelect?: boolean | undefined;\n            toolName?: string | undefined;\n            toolArgs?: unknown;\n            agentName?: string | undefined;\n            displayName?: string | undefined;\n            isFirstTimeGrant?: boolean | undefined;\n            floorLevel?: number | undefined;\n        }, {\n            type: \"string\" | \"number\" | \"boolean\" | \"code\" | \"select\" | \"slider\" | \"segmented\" | \"toggle\" | \"readonly\" | \"buttonGroup\" | \"multiSelect\" | \"diff\" | \"toolPreview\" | \"approvalHeader\";\n            key: string;\n            description?: string | undefined;\n            required?: boolean | undefined;\n            options?: {\n                value: string;\n                label: string;\n                description?: string | undefined;\n            }[] | undefined;\n            label?: string | undefined;\n            default?: string | number | boolean | string[] | undefined;\n            placeholder?: string | undefined;\n            min?: number | undefined;\n            max?: number | undefined;\n            step?: number | undefined;\n            notches?: {\n                value: number;\n                label: string;\n                description?: string | undefined;\n            }[] | undefined;\n            sliderLabels?: {\n                min?: string | undefined;\n                max?: string | undefined;\n            } | undefined;\n            group?: string | undefined;\n            order?: number | undefined;\n            visibleWhen?: {\n                value: string | number | boolean | (string | number | boolean)[];\n                field: string;\n                operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n            } | {\n                value: string | number | boolean | (string | number | boolean)[];\n                field: string;\n                operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n            }[] | undefined;\n            enabledWhen?: {\n                value: string | number | boolean | (string | number | boolean)[];\n                field: string;\n                operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n            } | {\n                value: string | number | boolean | (string | number | boolean)[];\n                field: string;\n                operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n            }[] | undefined;\n            warnings?: {\n                message: string;\n                when: string | number | boolean | (string | number | boolean)[];\n                severity?: \"info\" | \"warning\" | \"danger\" | undefined;\n            }[] | undefined;\n            language?: string | undefined;\n            maxHeight?: number | undefined;\n            buttonStyle?: \"outline\" | \"solid\" | \"soft\" | undefined;\n            buttons?: {\n                value: string;\n                label: string;\n                description?: string | undefined;\n                color?: \"gray\" | \"green\" | \"red\" | \"amber\" | undefined;\n            }[] | undefined;\n            submitOnSelect?: boolean | undefined;\n            toolName?: string | undefined;\n            toolArgs?: unknown;\n            agentName?: string | undefined;\n            displayName?: string | undefined;\n            isFirstTimeGrant?: boolean | undefined;\n            floorLevel?: number | undefined;\n        }>, \"many\">>;\n        tags: z.ZodOptional<z.ZodArray<z.ZodString, \"many\">>;\n        version: z.ZodOptional<z.ZodString>;\n    }, \"strip\", z.ZodTypeAny, {\n        name: string;\n        description: string;\n        id: string;\n        proposedHandle: string;\n        providesMethods: {\n            name: string;\n            parameters: Record<string, unknown>;\n            description?: string | undefined;\n            returns?: Record<string, unknown> | undefined;\n            streaming?: boolean | undefined;\n            timeout?: number | undefined;\n        }[];\n        requiresMethods: {\n            required: boolean;\n            name?: string | undefined;\n            pattern?: string | undefined;\n            description?: string | undefined;\n        }[];\n        parameters?: {\n            type: \"string\" | \"number\" | \"boolean\" | \"code\" | \"select\" | \"slider\" | \"segmented\" | \"toggle\" | \"readonly\" | \"buttonGroup\" | \"multiSelect\" | \"diff\" | \"toolPreview\" | \"approvalHeader\";\n            key: string;\n            description?: string | undefined;\n            required?: boolean | undefined;\n            options?: {\n                value: string;\n                label: string;\n                description?: string | undefined;\n            }[] | undefined;\n            label?: string | undefined;\n            default?: string | number | boolean | string[] | undefined;\n            placeholder?: string | undefined;\n            min?: number | undefined;\n            max?: number | undefined;\n            step?: number | undefined;\n            notches?: {\n                value: number;\n                label: string;\n                description?: string | undefined;\n            }[] | undefined;\n            sliderLabels?: {\n                min?: string | undefined;\n                max?: string | undefined;\n            } | undefined;\n            group?: string | undefined;\n            order?: number | undefined;\n            visibleWhen?: {\n                value: string | number | boolean | (string | number | boolean)[];\n                field: string;\n                operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n            } | {\n                value: string | number | boolean | (string | number | boolean)[];\n                field: string;\n                operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n            }[] | undefined;\n            enabledWhen?: {\n                value: string | number | boolean | (string | number | boolean)[];\n                field: string;\n                operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n            } | {\n                value: string | number | boolean | (string | number | boolean)[];\n                field: string;\n                operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n            }[] | undefined;\n            warnings?: {\n                message: string;\n                when: string | number | boolean | (string | number | boolean)[];\n                severity?: \"info\" | \"warning\" | \"danger\" | undefined;\n            }[] | undefined;\n            language?: string | undefined;\n            maxHeight?: number | undefined;\n            buttonStyle?: \"outline\" | \"solid\" | \"soft\" | undefined;\n            buttons?: {\n                value: string;\n                label: string;\n                description?: string | undefined;\n                color?: \"gray\" | \"green\" | \"red\" | \"amber\" | undefined;\n            }[] | undefined;\n            submitOnSelect?: boolean | undefined;\n            toolName?: string | undefined;\n            toolArgs?: unknown;\n            agentName?: string | undefined;\n            displayName?: string | undefined;\n            isFirstTimeGrant?: boolean | undefined;\n            floorLevel?: number | undefined;\n        }[] | undefined;\n        tags?: string[] | undefined;\n        version?: string | undefined;\n    }, {\n        name: string;\n        description: string;\n        id: string;\n        proposedHandle: string;\n        providesMethods: {\n            name: string;\n            parameters: Record<string, unknown>;\n            description?: string | undefined;\n            returns?: Record<string, unknown> | undefined;\n            streaming?: boolean | undefined;\n            timeout?: number | undefined;\n        }[];\n        requiresMethods: {\n            required: boolean;\n            name?: string | undefined;\n            pattern?: string | undefined;\n            description?: string | undefined;\n        }[];\n        parameters?: {\n            type: \"string\" | \"number\" | \"boolean\" | \"code\" | \"select\" | \"slider\" | \"segmented\" | \"toggle\" | \"readonly\" | \"buttonGroup\" | \"multiSelect\" | \"diff\" | \"toolPreview\" | \"approvalHeader\";\n            key: string;\n            description?: string | undefined;\n            required?: boolean | undefined;\n            options?: {\n                value: string;\n                label: string;\n                description?: string | undefined;\n            }[] | undefined;\n            label?: string | undefined;\n            default?: string | number | boolean | string[] | undefined;\n            placeholder?: string | undefined;\n            min?: number | undefined;\n            max?: number | undefined;\n            step?: number | undefined;\n            notches?: {\n                value: number;\n                label: string;\n                description?: string | undefined;\n            }[] | undefined;\n            sliderLabels?: {\n                min?: string | undefined;\n                max?: string | undefined;\n            } | undefined;\n            group?: string | undefined;\n            order?: number | undefined;\n            visibleWhen?: {\n                value: string | number | boolean | (string | number | boolean)[];\n                field: string;\n                operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n            } | {\n                value: string | number | boolean | (string | number | boolean)[];\n                field: string;\n                operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n            }[] | undefined;\n            enabledWhen?: {\n                value: string | number | boolean | (string | number | boolean)[];\n                field: string;\n                operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n            } | {\n                value: string | number | boolean | (string | number | boolean)[];\n                field: string;\n                operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n            }[] | undefined;\n            warnings?: {\n                message: string;\n                when: string | number | boolean | (string | number | boolean)[];\n                severity?: \"info\" | \"warning\" | \"danger\" | undefined;\n            }[] | undefined;\n            language?: string | undefined;\n            maxHeight?: number | undefined;\n            buttonStyle?: \"outline\" | \"solid\" | \"soft\" | undefined;\n            buttons?: {\n                value: string;\n                label: string;\n                description?: string | undefined;\n                color?: \"gray\" | \"green\" | \"red\" | \"amber\" | undefined;\n            }[] | undefined;\n            submitOnSelect?: boolean | undefined;\n            toolName?: string | undefined;\n            toolArgs?: unknown;\n            agentName?: string | undefined;\n            displayName?: string | undefined;\n            isFirstTimeGrant?: boolean | undefined;\n            floorLevel?: number | undefined;\n        }[] | undefined;\n        tags?: string[] | undefined;\n        version?: string | undefined;\n    }>, \"many\">;\n    brokerVersion: z.ZodOptional<z.ZodString>;\n    methods: z.ZodOptional<z.ZodArray<z.ZodObject<{\n        name: z.ZodString;\n        description: z.ZodOptional<z.ZodString>;\n        parameters: z.ZodRecord<z.ZodString, z.ZodUnknown>;\n        returns: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnknown>>;\n        streaming: z.ZodOptional<z.ZodBoolean>;\n        timeout: z.ZodOptional<z.ZodNumber>;\n    }, \"strip\", z.ZodTypeAny, {\n        name: string;\n        parameters: Record<string, unknown>;\n        description?: string | undefined;\n        returns?: Record<string, unknown> | undefined;\n        streaming?: boolean | undefined;\n        timeout?: number | undefined;\n    }, {\n        name: string;\n        parameters: Record<string, unknown>;\n        description?: string | undefined;\n        returns?: Record<string, unknown> | undefined;\n        streaming?: boolean | undefined;\n        timeout?: number | undefined;\n    }>, \"many\">>;\n}, \"strip\", z.ZodTypeAny, {\n    name: string;\n    type: string;\n    isBroker: true;\n    agentTypes: {\n        name: string;\n        description: string;\n        id: string;\n        proposedHandle: string;\n        providesMethods: {\n            name: string;\n            parameters: Record<string, unknown>;\n            description?: string | undefined;\n            returns?: Record<string, unknown> | undefined;\n            streaming?: boolean | undefined;\n            timeout?: number | undefined;\n        }[];\n        requiresMethods: {\n            required: boolean;\n            name?: string | undefined;\n            pattern?: string | undefined;\n            description?: string | undefined;\n        }[];\n        parameters?: {\n            type: \"string\" | \"number\" | \"boolean\" | \"code\" | \"select\" | \"slider\" | \"segmented\" | \"toggle\" | \"readonly\" | \"buttonGroup\" | \"multiSelect\" | \"diff\" | \"toolPreview\" | \"approvalHeader\";\n            key: string;\n            description?: string | undefined;\n            required?: boolean | undefined;\n            options?: {\n                value: string;\n                label: string;\n                description?: string | undefined;\n            }[] | undefined;\n            label?: string | undefined;\n            default?: string | number | boolean | string[] | undefined;\n            placeholder?: string | undefined;\n            min?: number | undefined;\n            max?: number | undefined;\n            step?: number | undefined;\n            notches?: {\n                value: number;\n                label: string;\n                description?: string | undefined;\n            }[] | undefined;\n            sliderLabels?: {\n                min?: string | undefined;\n                max?: string | undefined;\n            } | undefined;\n            group?: string | undefined;\n            order?: number | undefined;\n            visibleWhen?: {\n                value: string | number | boolean | (string | number | boolean)[];\n                field: string;\n                operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n            } | {\n                value: string | number | boolean | (string | number | boolean)[];\n                field: string;\n                operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n            }[] | undefined;\n            enabledWhen?: {\n                value: string | number | boolean | (string | number | boolean)[];\n                field: string;\n                operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n            } | {\n                value: string | number | boolean | (string | number | boolean)[];\n                field: string;\n                operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n            }[] | undefined;\n            warnings?: {\n                message: string;\n                when: string | number | boolean | (string | number | boolean)[];\n                severity?: \"info\" | \"warning\" | \"danger\" | undefined;\n            }[] | undefined;\n            language?: string | undefined;\n            maxHeight?: number | undefined;\n            buttonStyle?: \"outline\" | \"solid\" | \"soft\" | undefined;\n            buttons?: {\n                value: string;\n                label: string;\n                description?: string | undefined;\n                color?: \"gray\" | \"green\" | \"red\" | \"amber\" | undefined;\n            }[] | undefined;\n            submitOnSelect?: boolean | undefined;\n            toolName?: string | undefined;\n            toolArgs?: unknown;\n            agentName?: string | undefined;\n            displayName?: string | undefined;\n            isFirstTimeGrant?: boolean | undefined;\n            floorLevel?: number | undefined;\n        }[] | undefined;\n        tags?: string[] | undefined;\n        version?: string | undefined;\n    }[];\n    brokerVersion?: string | undefined;\n    methods?: {\n        name: string;\n        parameters: Record<string, unknown>;\n        description?: string | undefined;\n        returns?: Record<string, unknown> | undefined;\n        streaming?: boolean | undefined;\n        timeout?: number | undefined;\n    }[] | undefined;\n}, {\n    name: string;\n    type: string;\n    isBroker: true;\n    agentTypes: {\n        name: string;\n        description: string;\n        id: string;\n        proposedHandle: string;\n        providesMethods: {\n            name: string;\n            parameters: Record<string, unknown>;\n            description?: string | undefined;\n            returns?: Record<string, unknown> | undefined;\n            streaming?: boolean | undefined;\n            timeout?: number | undefined;\n        }[];\n        requiresMethods: {\n            required: boolean;\n            name?: string | undefined;\n            pattern?: string | undefined;\n            description?: string | undefined;\n        }[];\n        parameters?: {\n            type: \"string\" | \"number\" | \"boolean\" | \"code\" | \"select\" | \"slider\" | \"segmented\" | \"toggle\" | \"readonly\" | \"buttonGroup\" | \"multiSelect\" | \"diff\" | \"toolPreview\" | \"approvalHeader\";\n            key: string;\n            description?: string | undefined;\n            required?: boolean | undefined;\n            options?: {\n                value: string;\n                label: string;\n                description?: string | undefined;\n            }[] | undefined;\n            label?: string | undefined;\n            default?: string | number | boolean | string[] | undefined;\n            placeholder?: string | undefined;\n            min?: number | undefined;\n            max?: number | undefined;\n            step?: number | undefined;\n            notches?: {\n                value: number;\n                label: string;\n                description?: string | undefined;\n            }[] | undefined;\n            sliderLabels?: {\n                min?: string | undefined;\n                max?: string | undefined;\n            } | undefined;\n            group?: string | undefined;\n            order?: number | undefined;\n            visibleWhen?: {\n                value: string | number | boolean | (string | number | boolean)[];\n                field: string;\n                operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n            } | {\n                value: string | number | boolean | (string | number | boolean)[];\n                field: string;\n                operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n            }[] | undefined;\n            enabledWhen?: {\n                value: string | number | boolean | (string | number | boolean)[];\n                field: string;\n                operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n            } | {\n                value: string | number | boolean | (string | number | boolean)[];\n                field: string;\n                operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n            }[] | undefined;\n            warnings?: {\n                message: string;\n                when: string | number | boolean | (string | number | boolean)[];\n                severity?: \"info\" | \"warning\" | \"danger\" | undefined;\n            }[] | undefined;\n            language?: string | undefined;\n            maxHeight?: number | undefined;\n            buttonStyle?: \"outline\" | \"solid\" | \"soft\" | undefined;\n            buttons?: {\n                value: string;\n                label: string;\n                description?: string | undefined;\n                color?: \"gray\" | \"green\" | \"red\" | \"amber\" | undefined;\n            }[] | undefined;\n            submitOnSelect?: boolean | undefined;\n            toolName?: string | undefined;\n            toolArgs?: unknown;\n            agentName?: string | undefined;\n            displayName?: string | undefined;\n            isFirstTimeGrant?: boolean | undefined;\n            floorLevel?: number | undefined;\n        }[] | undefined;\n        tags?: string[] | undefined;\n        version?: string | undefined;\n    }[];\n    brokerVersion?: string | undefined;\n    methods?: {\n        name: string;\n        parameters: Record<string, unknown>;\n        description?: string | undefined;\n        returns?: Record<string, unknown> | undefined;\n        streaming?: boolean | undefined;\n        timeout?: number | undefined;\n    }[] | undefined;\n}>;\n/**\n * Schema for invite message payload.\n */\nexport declare const InviteSchema: z.ZodObject<{\n    inviteId: z.ZodString;\n    targetChannel: z.ZodString;\n    agentTypeId: z.ZodString;\n    config: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnknown>>;\n    context: z.ZodOptional<z.ZodString>;\n    handleOverride: z.ZodOptional<z.ZodString>;\n    ts: z.ZodNumber;\n}, \"strip\", z.ZodTypeAny, {\n    inviteId: string;\n    targetChannel: string;\n    agentTypeId: string;\n    ts: number;\n    config?: Record<string, unknown> | undefined;\n    context?: string | undefined;\n    handleOverride?: string | undefined;\n}, {\n    inviteId: string;\n    targetChannel: string;\n    agentTypeId: string;\n    ts: number;\n    config?: Record<string, unknown> | undefined;\n    context?: string | undefined;\n    handleOverride?: string | undefined;\n}>;\n/**\n * Schema for invite response payload.\n */\nexport declare const InviteResponseSchema: z.ZodObject<{\n    inviteId: z.ZodString;\n    accepted: z.ZodBoolean;\n    declineReason: z.ZodOptional<z.ZodString>;\n    declineCode: z.ZodOptional<z.ZodEnum<[\"unknown-agent-type\", \"capacity-exceeded\", \"invalid-config\", \"target-unreachable\", \"internal-error\", \"declined-by-policy\", \"timeout\"]>>;\n    agentId: z.ZodOptional<z.ZodString>;\n    ts: z.ZodNumber;\n}, \"strip\", z.ZodTypeAny, {\n    inviteId: string;\n    ts: number;\n    accepted: boolean;\n    declineReason?: string | undefined;\n    declineCode?: \"timeout\" | \"unknown-agent-type\" | \"capacity-exceeded\" | \"invalid-config\" | \"target-unreachable\" | \"internal-error\" | \"declined-by-policy\" | undefined;\n    agentId?: string | undefined;\n}, {\n    inviteId: string;\n    ts: number;\n    accepted: boolean;\n    declineReason?: string | undefined;\n    declineCode?: \"timeout\" | \"unknown-agent-type\" | \"capacity-exceeded\" | \"invalid-config\" | \"target-unreachable\" | \"internal-error\" | \"declined-by-policy\" | undefined;\n    agentId?: string | undefined;\n}>;\nexport type InviteMessage = z.infer<typeof InviteSchema>;\nexport type InviteResponseMessage = z.infer<typeof InviteResponseSchema>;\nexport type AgentTypeAdvertisementMessage = z.infer<typeof AgentTypeAdvertisementSchema>;\nexport type BrokerMetadataMessage = z.infer<typeof BrokerMetadataSchema>;\n/**\n * Arguments for feedback_form method.\n * Use this for standard forms with JSON schema-defined fields.\n */\nexport interface FeedbackFormArgs {\n    title: string;\n    fields: z.infer<typeof FieldDefinitionSchema>[];\n    values?: Record<string, string | number | boolean | string[]>;\n    submitLabel?: string;\n    cancelLabel?: string;\n    timeout?: number;\n    timeoutAction?: \"cancel\" | \"submit\";\n    severity?: \"info\" | \"warning\" | \"danger\";\n    hideSubmit?: boolean;\n    hideCancel?: boolean;\n}\n/**\n * Arguments for feedback_custom method.\n * Use this for complex custom UIs with custom layout, validation, or interactions.\n */\nexport interface FeedbackCustomArgs {\n    code: string;\n}\n/**\n * Zod schema for feedback_form method arguments.\n */\nexport declare const FeedbackFormArgsSchema: z.ZodObject<{\n    title: z.ZodString;\n    fields: z.ZodArray<z.ZodObject<{\n        key: z.ZodString;\n        label: z.ZodOptional<z.ZodString>;\n        description: z.ZodOptional<z.ZodString>;\n        type: z.ZodEnum<[\"string\", \"number\", \"boolean\", \"select\", \"slider\", \"segmented\", \"toggle\", \"readonly\", \"code\", \"buttonGroup\", \"multiSelect\", \"diff\", \"toolPreview\", \"approvalHeader\"]>;\n        required: z.ZodOptional<z.ZodBoolean>;\n        default: z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber, z.ZodBoolean, z.ZodArray<z.ZodString, \"many\">]>>;\n        options: z.ZodOptional<z.ZodArray<z.ZodObject<{\n            value: z.ZodString;\n            label: z.ZodString;\n            description: z.ZodOptional<z.ZodString>;\n        }, \"strip\", z.ZodTypeAny, {\n            value: string;\n            label: string;\n            description?: string | undefined;\n        }, {\n            value: string;\n            label: string;\n            description?: string | undefined;\n        }>, \"many\">>;\n        placeholder: z.ZodOptional<z.ZodString>;\n        min: z.ZodOptional<z.ZodNumber>;\n        max: z.ZodOptional<z.ZodNumber>;\n        step: z.ZodOptional<z.ZodNumber>;\n        notches: z.ZodOptional<z.ZodArray<z.ZodObject<{\n            value: z.ZodNumber;\n            label: z.ZodString;\n            description: z.ZodOptional<z.ZodString>;\n        }, \"strip\", z.ZodTypeAny, {\n            value: number;\n            label: string;\n            description?: string | undefined;\n        }, {\n            value: number;\n            label: string;\n            description?: string | undefined;\n        }>, \"many\">>;\n        sliderLabels: z.ZodOptional<z.ZodObject<{\n            min: z.ZodOptional<z.ZodString>;\n            max: z.ZodOptional<z.ZodString>;\n        }, \"strip\", z.ZodTypeAny, {\n            min?: string | undefined;\n            max?: string | undefined;\n        }, {\n            min?: string | undefined;\n            max?: string | undefined;\n        }>>;\n        group: z.ZodOptional<z.ZodString>;\n        order: z.ZodOptional<z.ZodNumber>;\n        visibleWhen: z.ZodOptional<z.ZodUnion<[z.ZodObject<{\n            field: z.ZodString;\n            operator: z.ZodEnum<[\"eq\", \"neq\", \"gt\", \"gte\", \"lt\", \"lte\", \"in\"]>;\n            value: z.ZodUnion<[z.ZodUnion<[z.ZodString, z.ZodNumber, z.ZodBoolean]>, z.ZodArray<z.ZodUnion<[z.ZodString, z.ZodNumber, z.ZodBoolean]>, \"many\">]>;\n        }, \"strip\", z.ZodTypeAny, {\n            value: string | number | boolean | (string | number | boolean)[];\n            field: string;\n            operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n        }, {\n            value: string | number | boolean | (string | number | boolean)[];\n            field: string;\n            operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n        }>, z.ZodArray<z.ZodObject<{\n            field: z.ZodString;\n            operator: z.ZodEnum<[\"eq\", \"neq\", \"gt\", \"gte\", \"lt\", \"lte\", \"in\"]>;\n            value: z.ZodUnion<[z.ZodUnion<[z.ZodString, z.ZodNumber, z.ZodBoolean]>, z.ZodArray<z.ZodUnion<[z.ZodString, z.ZodNumber, z.ZodBoolean]>, \"many\">]>;\n        }, \"strip\", z.ZodTypeAny, {\n            value: string | number | boolean | (string | number | boolean)[];\n            field: string;\n            operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n        }, {\n            value: string | number | boolean | (string | number | boolean)[];\n            field: string;\n            operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n        }>, \"many\">]>>;\n        enabledWhen: z.ZodOptional<z.ZodUnion<[z.ZodObject<{\n            field: z.ZodString;\n            operator: z.ZodEnum<[\"eq\", \"neq\", \"gt\", \"gte\", \"lt\", \"lte\", \"in\"]>;\n            value: z.ZodUnion<[z.ZodUnion<[z.ZodString, z.ZodNumber, z.ZodBoolean]>, z.ZodArray<z.ZodUnion<[z.ZodString, z.ZodNumber, z.ZodBoolean]>, \"many\">]>;\n        }, \"strip\", z.ZodTypeAny, {\n            value: string | number | boolean | (string | number | boolean)[];\n            field: string;\n            operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n        }, {\n            value: string | number | boolean | (string | number | boolean)[];\n            field: string;\n            operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n        }>, z.ZodArray<z.ZodObject<{\n            field: z.ZodString;\n            operator: z.ZodEnum<[\"eq\", \"neq\", \"gt\", \"gte\", \"lt\", \"lte\", \"in\"]>;\n            value: z.ZodUnion<[z.ZodUnion<[z.ZodString, z.ZodNumber, z.ZodBoolean]>, z.ZodArray<z.ZodUnion<[z.ZodString, z.ZodNumber, z.ZodBoolean]>, \"many\">]>;\n        }, \"strip\", z.ZodTypeAny, {\n            value: string | number | boolean | (string | number | boolean)[];\n            field: string;\n            operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n        }, {\n            value: string | number | boolean | (string | number | boolean)[];\n            field: string;\n            operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n        }>, \"many\">]>>;\n        warnings: z.ZodOptional<z.ZodArray<z.ZodObject<{\n            when: z.ZodUnion<[z.ZodUnion<[z.ZodString, z.ZodNumber, z.ZodBoolean]>, z.ZodArray<z.ZodUnion<[z.ZodString, z.ZodNumber, z.ZodBoolean]>, \"many\">]>;\n            message: z.ZodString;\n            severity: z.ZodOptional<z.ZodEnum<[\"info\", \"warning\", \"danger\"]>>;\n        }, \"strip\", z.ZodTypeAny, {\n            message: string;\n            when: string | number | boolean | (string | number | boolean)[];\n            severity?: \"info\" | \"warning\" | \"danger\" | undefined;\n        }, {\n            message: string;\n            when: string | number | boolean | (string | number | boolean)[];\n            severity?: \"info\" | \"warning\" | \"danger\" | undefined;\n        }>, \"many\">>;\n        language: z.ZodOptional<z.ZodString>;\n        maxHeight: z.ZodOptional<z.ZodNumber>;\n        buttonStyle: z.ZodOptional<z.ZodEnum<[\"outline\", \"solid\", \"soft\"]>>;\n        buttons: z.ZodOptional<z.ZodArray<z.ZodObject<{\n            value: z.ZodString;\n            label: z.ZodString;\n            color: z.ZodOptional<z.ZodEnum<[\"gray\", \"green\", \"red\", \"amber\"]>>;\n            description: z.ZodOptional<z.ZodString>;\n        }, \"strip\", z.ZodTypeAny, {\n            value: string;\n            label: string;\n            description?: string | undefined;\n            color?: \"gray\" | \"green\" | \"red\" | \"amber\" | undefined;\n        }, {\n            value: string;\n            label: string;\n            description?: string | undefined;\n            color?: \"gray\" | \"green\" | \"red\" | \"amber\" | undefined;\n        }>, \"many\">>;\n        submitOnSelect: z.ZodOptional<z.ZodBoolean>;\n        toolName: z.ZodOptional<z.ZodString>;\n        toolArgs: z.ZodOptional<z.ZodUnknown>;\n        agentName: z.ZodOptional<z.ZodString>;\n        displayName: z.ZodOptional<z.ZodString>;\n        isFirstTimeGrant: z.ZodOptional<z.ZodBoolean>;\n        floorLevel: z.ZodOptional<z.ZodNumber>;\n    }, \"strip\", z.ZodTypeAny, {\n        type: \"string\" | \"number\" | \"boolean\" | \"code\" | \"select\" | \"slider\" | \"segmented\" | \"toggle\" | \"readonly\" | \"buttonGroup\" | \"multiSelect\" | \"diff\" | \"toolPreview\" | \"approvalHeader\";\n        key: string;\n        description?: string | undefined;\n        required?: boolean | undefined;\n        options?: {\n            value: string;\n            label: string;\n            description?: string | undefined;\n        }[] | undefined;\n        label?: string | undefined;\n        default?: string | number | boolean | string[] | undefined;\n        placeholder?: string | undefined;\n        min?: number | undefined;\n        max?: number | undefined;\n        step?: number | undefined;\n        notches?: {\n            value: number;\n            label: string;\n            description?: string | undefined;\n        }[] | undefined;\n        sliderLabels?: {\n            min?: string | undefined;\n            max?: string | undefined;\n        } | undefined;\n        group?: string | undefined;\n        order?: number | undefined;\n        visibleWhen?: {\n            value: string | number | boolean | (string | number | boolean)[];\n            field: string;\n            operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n        } | {\n            value: string | number | boolean | (string | number | boolean)[];\n            field: string;\n            operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n        }[] | undefined;\n        enabledWhen?: {\n            value: string | number | boolean | (string | number | boolean)[];\n            field: string;\n            operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n        } | {\n            value: string | number | boolean | (string | number | boolean)[];\n            field: string;\n            operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n        }[] | undefined;\n        warnings?: {\n            message: string;\n            when: string | number | boolean | (string | number | boolean)[];\n            severity?: \"info\" | \"warning\" | \"danger\" | undefined;\n        }[] | undefined;\n        language?: string | undefined;\n        maxHeight?: number | undefined;\n        buttonStyle?: \"outline\" | \"solid\" | \"soft\" | undefined;\n        buttons?: {\n            value: string;\n            label: string;\n            description?: string | undefined;\n            color?: \"gray\" | \"green\" | \"red\" | \"amber\" | undefined;\n        }[] | undefined;\n        submitOnSelect?: boolean | undefined;\n        toolName?: string | undefined;\n        toolArgs?: unknown;\n        agentName?: string | undefined;\n        displayName?: string | undefined;\n        isFirstTimeGrant?: boolean | undefined;\n        floorLevel?: number | undefined;\n    }, {\n        type: \"string\" | \"number\" | \"boolean\" | \"code\" | \"select\" | \"slider\" | \"segmented\" | \"toggle\" | \"readonly\" | \"buttonGroup\" | \"multiSelect\" | \"diff\" | \"toolPreview\" | \"approvalHeader\";\n        key: string;\n        description?: string | undefined;\n        required?: boolean | undefined;\n        options?: {\n            value: string;\n            label: string;\n            description?: string | undefined;\n        }[] | undefined;\n        label?: string | undefined;\n        default?: string | number | boolean | string[] | undefined;\n        placeholder?: string | undefined;\n        min?: number | undefined;\n        max?: number | undefined;\n        step?: number | undefined;\n        notches?: {\n            value: number;\n            label: string;\n            description?: string | undefined;\n        }[] | undefined;\n        sliderLabels?: {\n            min?: string | undefined;\n            max?: string | undefined;\n        } | undefined;\n        group?: string | undefined;\n        order?: number | undefined;\n        visibleWhen?: {\n            value: string | number | boolean | (string | number | boolean)[];\n            field: string;\n            operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n        } | {\n            value: string | number | boolean | (string | number | boolean)[];\n            field: string;\n            operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n        }[] | undefined;\n        enabledWhen?: {\n            value: string | number | boolean | (string | number | boolean)[];\n            field: string;\n            operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n        } | {\n            value: string | number | boolean | (string | number | boolean)[];\n            field: string;\n            operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n        }[] | undefined;\n        warnings?: {\n            message: string;\n            when: string | number | boolean | (string | number | boolean)[];\n            severity?: \"info\" | \"warning\" | \"danger\" | undefined;\n        }[] | undefined;\n        language?: string | undefined;\n        maxHeight?: number | undefined;\n        buttonStyle?: \"outline\" | \"solid\" | \"soft\" | undefined;\n        buttons?: {\n            value: string;\n            label: string;\n            description?: string | undefined;\n            color?: \"gray\" | \"green\" | \"red\" | \"amber\" | undefined;\n        }[] | undefined;\n        submitOnSelect?: boolean | undefined;\n        toolName?: string | undefined;\n        toolArgs?: unknown;\n        agentName?: string | undefined;\n        displayName?: string | undefined;\n        isFirstTimeGrant?: boolean | undefined;\n        floorLevel?: number | undefined;\n    }>, \"many\">;\n    values: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnion<[z.ZodString, z.ZodNumber, z.ZodBoolean, z.ZodArray<z.ZodString, \"many\">]>>>;\n    submitLabel: z.ZodOptional<z.ZodString>;\n    cancelLabel: z.ZodOptional<z.ZodString>;\n    timeout: z.ZodOptional<z.ZodNumber>;\n    timeoutAction: z.ZodOptional<z.ZodEnum<[\"cancel\", \"submit\"]>>;\n    severity: z.ZodOptional<z.ZodEnum<[\"info\", \"warning\", \"danger\"]>>;\n    hideSubmit: z.ZodOptional<z.ZodBoolean>;\n    hideCancel: z.ZodOptional<z.ZodBoolean>;\n}, \"strip\", z.ZodTypeAny, {\n    title: string;\n    fields: {\n        type: \"string\" | \"number\" | \"boolean\" | \"code\" | \"select\" | \"slider\" | \"segmented\" | \"toggle\" | \"readonly\" | \"buttonGroup\" | \"multiSelect\" | \"diff\" | \"toolPreview\" | \"approvalHeader\";\n        key: string;\n        description?: string | undefined;\n        required?: boolean | undefined;\n        options?: {\n            value: string;\n            label: string;\n            description?: string | undefined;\n        }[] | undefined;\n        label?: string | undefined;\n        default?: string | number | boolean | string[] | undefined;\n        placeholder?: string | undefined;\n        min?: number | undefined;\n        max?: number | undefined;\n        step?: number | undefined;\n        notches?: {\n            value: number;\n            label: string;\n            description?: string | undefined;\n        }[] | undefined;\n        sliderLabels?: {\n            min?: string | undefined;\n            max?: string | undefined;\n        } | undefined;\n        group?: string | undefined;\n        order?: number | undefined;\n        visibleWhen?: {\n            value: string | number | boolean | (string | number | boolean)[];\n            field: string;\n            operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n        } | {\n            value: string | number | boolean | (string | number | boolean)[];\n            field: string;\n            operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n        }[] | undefined;\n        enabledWhen?: {\n            value: string | number | boolean | (string | number | boolean)[];\n            field: string;\n            operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n        } | {\n            value: string | number | boolean | (string | number | boolean)[];\n            field: string;\n            operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n        }[] | undefined;\n        warnings?: {\n            message: string;\n            when: string | number | boolean | (string | number | boolean)[];\n            severity?: \"info\" | \"warning\" | \"danger\" | undefined;\n        }[] | undefined;\n        language?: string | undefined;\n        maxHeight?: number | undefined;\n        buttonStyle?: \"outline\" | \"solid\" | \"soft\" | undefined;\n        buttons?: {\n            value: string;\n            label: string;\n            description?: string | undefined;\n            color?: \"gray\" | \"green\" | \"red\" | \"amber\" | undefined;\n        }[] | undefined;\n        submitOnSelect?: boolean | undefined;\n        toolName?: string | undefined;\n        toolArgs?: unknown;\n        agentName?: string | undefined;\n        displayName?: string | undefined;\n        isFirstTimeGrant?: boolean | undefined;\n        floorLevel?: number | undefined;\n    }[];\n    values?: Record<string, string | number | boolean | string[]> | undefined;\n    timeout?: number | undefined;\n    severity?: \"info\" | \"warning\" | \"danger\" | undefined;\n    submitLabel?: string | undefined;\n    cancelLabel?: string | undefined;\n    timeoutAction?: \"cancel\" | \"submit\" | undefined;\n    hideSubmit?: boolean | undefined;\n    hideCancel?: boolean | undefined;\n}, {\n    title: string;\n    fields: {\n        type: \"string\" | \"number\" | \"boolean\" | \"code\" | \"select\" | \"slider\" | \"segmented\" | \"toggle\" | \"readonly\" | \"buttonGroup\" | \"multiSelect\" | \"diff\" | \"toolPreview\" | \"approvalHeader\";\n        key: string;\n        description?: string | undefined;\n        required?: boolean | undefined;\n        options?: {\n            value: string;\n            label: string;\n            description?: string | undefined;\n        }[] | undefined;\n        label?: string | undefined;\n        default?: string | number | boolean | string[] | undefined;\n        placeholder?: string | undefined;\n        min?: number | undefined;\n        max?: number | undefined;\n        step?: number | undefined;\n        notches?: {\n            value: number;\n            label: string;\n            description?: string | undefined;\n        }[] | undefined;\n        sliderLabels?: {\n            min?: string | undefined;\n            max?: string | undefined;\n        } | undefined;\n        group?: string | undefined;\n        order?: number | undefined;\n        visibleWhen?: {\n            value: string | number | boolean | (string | number | boolean)[];\n            field: string;\n            operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n        } | {\n            value: string | number | boolean | (string | number | boolean)[];\n            field: string;\n            operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n        }[] | undefined;\n        enabledWhen?: {\n            value: string | number | boolean | (string | number | boolean)[];\n            field: string;\n            operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n        } | {\n            value: string | number | boolean | (string | number | boolean)[];\n            field: string;\n            operator: \"eq\" | \"neq\" | \"gt\" | \"gte\" | \"lt\" | \"lte\" | \"in\";\n        }[] | undefined;\n        warnings?: {\n            message: string;\n            when: string | number | boolean | (string | number | boolean)[];\n            severity?: \"info\" | \"warning\" | \"danger\" | undefined;\n        }[] | undefined;\n        language?: string | undefined;\n        maxHeight?: number | undefined;\n        buttonStyle?: \"outline\" | \"solid\" | \"soft\" | undefined;\n        buttons?: {\n            value: string;\n            label: string;\n            description?: string | undefined;\n            color?: \"gray\" | \"green\" | \"red\" | \"amber\" | undefined;\n        }[] | undefined;\n        submitOnSelect?: boolean | undefined;\n        toolName?: string | undefined;\n        toolArgs?: unknown;\n        agentName?: string | undefined;\n        displayName?: string | undefined;\n        isFirstTimeGrant?: boolean | undefined;\n        floorLevel?: number | undefined;\n    }[];\n    values?: Record<string, string | number | boolean | string[]> | undefined;\n    timeout?: number | undefined;\n    severity?: \"info\" | \"warning\" | \"danger\" | undefined;\n    submitLabel?: string | undefined;\n    cancelLabel?: string | undefined;\n    timeoutAction?: \"cancel\" | \"submit\" | undefined;\n    hideSubmit?: boolean | undefined;\n    hideCancel?: boolean | undefined;\n}>;\n/**\n * Zod schema for feedback_custom method arguments.\n */\nexport declare const FeedbackCustomArgsSchema: z.ZodObject<{\n    code: z.ZodString;\n}, \"strip\", z.ZodTypeAny, {\n    code: string;\n}, {\n    code: string;\n}>;\n//# sourceMappingURL=broker-protocol.d.ts.map",
      "broker-types.d.ts": "/**\n * @natstack/agentic-messaging broker types\n *\n * Types for agent broker discovery and invitation protocol.\n */\nimport type { AgenticParticipantMetadata, MethodAdvertisement } from \"./types.js\";\nimport type { FieldDefinition } from \"@natstack/runtime\";\n/**\n * Specification for a method that an agent requires.\n * Can match by exact name or pattern.\n */\nexport interface RequiredMethodSpec {\n    /** Method name (exact match) */\n    name?: string;\n    /** Method name pattern (regex) */\n    pattern?: string;\n    /** Description of why this method is needed */\n    description?: string;\n    /** Whether this method is required (true) or optional (false) */\n    required: boolean;\n}\n/**\n * Describes an agent type that a broker can spawn.\n * This is what brokers advertise about their capabilities.\n */\nexport interface AgentTypeAdvertisement {\n    /** Unique identifier for this agent type within the broker */\n    id: string;\n    /** Human-readable name */\n    name: string;\n    /**\n     * Proposed handle for @-mentions when this agent is spawned.\n     * Can be overridden by the invite's handleOverride field.\n     * Must be unique within the target channel.\n     */\n    proposedHandle: string;\n    /** Free-form description for LLM interpretation */\n    description: string;\n    /** Methods the spawned agent will provide */\n    providesMethods: MethodAdvertisement[];\n    /** Methods the spawned agent requires from other participants */\n    requiresMethods: RequiredMethodSpec[];\n    /** Configurable parameters for this agent type */\n    parameters?: FieldDefinition[];\n    /** Optional tags for filtering/categorization */\n    tags?: string[];\n    /** Optional version string */\n    version?: string;\n}\n/**\n * Broker participant metadata.\n * Extends AgenticParticipantMetadata with agent type advertisements.\n */\nexport interface BrokerMetadata extends AgenticParticipantMetadata {\n    /** Marker to identify this participant as a broker */\n    isBroker: true;\n    /** Agent types this broker can spawn */\n    agentTypes: AgentTypeAdvertisement[];\n    /** Broker version for compatibility checking */\n    brokerVersion?: string;\n}\n/**\n * Invite payload sent from client to broker.\n */\nexport interface Invite {\n    /** Unique invite ID for correlation */\n    inviteId: string;\n    /** Target channel where the spawned agent should connect */\n    targetChannel: string;\n    /** Which agent type to spawn (must match an advertised AgentTypeAdvertisement.id) */\n    agentTypeId: string;\n    /** Optional configuration for the spawned agent (opaque to protocol) */\n    config?: Record<string, unknown>;\n    /** Optional context/instructions for the agent */\n    context?: string;\n    /**\n     * Override the agent's handle for @-mentions.\n     * If not provided, the agent uses its AgentTypeAdvertisement.proposedHandle.\n     */\n    handleOverride?: string;\n    /** Timestamp when invite was sent */\n    ts: number;\n}\n/**\n * Decline codes for invite responses.\n */\nexport type InviteDeclineCode = \"unknown-agent-type\" | \"capacity-exceeded\" | \"invalid-config\" | \"target-unreachable\" | \"internal-error\" | \"declined-by-policy\" | \"timeout\";\n/**\n * Response to an invite from broker to client.\n */\nexport interface InviteResponse {\n    /** Invite ID being responded to */\n    inviteId: string;\n    /** Whether the invite was accepted */\n    accepted: boolean;\n    /** Reason for decline (if not accepted) */\n    declineReason?: string;\n    /** Error code for decline (if not accepted) */\n    declineCode?: InviteDeclineCode;\n    /** Agent ID on the target channel (if accepted and agent connected) */\n    agentId?: string;\n    /** Timestamp of response */\n    ts: number;\n}\n/**\n * Error codes for broker operations.\n */\nexport type BrokerErrorCode = InviteDeclineCode | \"broker-not-found\" | \"broker-offline\" | \"invite-timeout\";\n/**\n * Error class for broker operations.\n */\nexport declare class BrokerError extends Error {\n    readonly code: BrokerErrorCode;\n    readonly cause?: unknown | undefined;\n    constructor(message: string, code: BrokerErrorCode, cause?: unknown | undefined);\n}\n/**\n * A discovered broker from the availability channel roster.\n */\nexport interface DiscoveredBroker {\n    /** Broker's client ID */\n    brokerId: string;\n    /** Broker's display name */\n    name: string;\n    /** Agent types this broker offers */\n    agentTypes: AgentTypeAdvertisement[];\n    /** Full broker metadata */\n    metadata: BrokerMetadata;\n}\n/**\n * Result of an invite operation.\n */\nexport interface InviteResult {\n    /** The invite that was sent */\n    invite: Invite;\n    /** Promise that resolves with the response */\n    response: Promise<InviteResponse>;\n    /** Cancel the invite (if not yet responded) */\n    cancel(): void;\n}\n/**\n * Result from an invite handler.\n */\nexport interface InviteHandlerResult {\n    /** Whether to accept the invite */\n    accept: boolean;\n    /** Reason for decline (if not accepting) */\n    declineReason?: string;\n    /** Decline code (if not accepting) */\n    declineCode?: InviteDeclineCode;\n    /**\n     * If accept is true and this is provided, the handler has already\n     * connected an agent - include its ID. If not provided, broker will\n     * auto-connect using the spawn callback.\n     */\n    agentId?: string;\n}\n/**\n * Callback signature for handling incoming invites.\n */\nexport type InviteHandler = (invite: Invite, senderId: string) => Promise<InviteHandlerResult>;\n/**\n * Callback to spawn an agent on a target channel.\n * Called when an invite is accepted and broker should auto-connect.\n */\nexport type SpawnAgentCallback = (invite: Invite, agentType: AgentTypeAdvertisement) => Promise<{\n    agentId: string;\n}>;\n/**\n * Options for connecting as a broker.\n */\nexport interface BrokerConnectOptions {\n    /** The availability channel to advertise on */\n    availabilityChannel: string;\n    /** Broker display name */\n    name: string;\n    /** Unique handle for @-mentions (e.g., \"broker\", \"agent-manager\") */\n    handle: string;\n    /** Agent types to advertise */\n    agentTypes: AgentTypeAdvertisement[];\n    /**\n     * Invite handler. Return accept: true to accept invites.\n     * If not provided, all invites are declined.\n     */\n    onInvite?: InviteHandler;\n    /**\n     * Spawn callback. Called when invite is accepted and handler\n     * did not provide an agentId. Should connect agent to target channel\n     * and return the agent's client ID.\n     */\n    onSpawn?: SpawnAgentCallback;\n    /** Auto-reconnect configuration */\n    reconnect?: boolean | {\n        delayMs?: number;\n        maxDelayMs?: number;\n        maxAttempts?: number;\n    };\n    /** Optional custom metadata fields */\n    customMetadata?: Record<string, unknown>;\n}\n/**\n * Options for discovering and inviting brokers.\n */\nexport interface BrokerClientOptions {\n    /** The availability channel to connect to */\n    availabilityChannel: string;\n    /** Client display name */\n    name: string;\n    /** Unique handle for @-mentions */\n    handle: string;\n    /** Client type identifier */\n    type: string;\n    /** Default timeout for invite operations in ms */\n    inviteTimeoutMs?: number;\n    /** Auto-reconnect configuration */\n    reconnect?: boolean | {\n        delayMs?: number;\n        maxDelayMs?: number;\n        maxAttempts?: number;\n    };\n}\n/**\n * Query for filtering brokers by capability.\n */\nexport interface BrokerQuery {\n    /** Filter by agent type tags (OR matching) */\n    tags?: string[];\n    /** Filter by methods the agent provides (by name) */\n    providesMethods?: string[];\n    /** Filter by methods the agent requires (by name) */\n    requiresMethods?: string[];\n    /** Free-text search in descriptions */\n    descriptionContains?: string;\n}\n//# sourceMappingURL=broker-types.d.ts.map",
      "broker.d.ts": "/**\n * @natstack/agentic-messaging broker\n *\n * API for brokers to advertise agent types and handle invites.\n */\nimport type { AgenticClient } from \"./types.js\";\nimport type { AgentTypeAdvertisement, BrokerConnectOptions, BrokerMetadata } from \"./broker-types.js\";\n/**\n * Broker client for advertising agent types and handling invites.\n */\nexport interface BrokerClient {\n    /** Underlying agentic client (for advanced use) */\n    readonly client: AgenticClient<BrokerMetadata>;\n    /** This broker's client ID on the availability channel */\n    readonly brokerId: string | null;\n    /** Current agent type advertisements */\n    readonly agentTypes: AgentTypeAdvertisement[];\n    /** Update advertised agent types (updates roster metadata) */\n    updateAgentTypes(agentTypes: AgentTypeAdvertisement[]): Promise<void>;\n    /** Close the broker connection */\n    close(): Promise<void>;\n    /** Subscribe to errors */\n    onError(handler: (error: Error) => void): () => void;\n}\n/**\n * Connect as a broker to the availability channel.\n *\n * @example\n * ```ts\n * const broker = await connectAsBroker(serverUrl, token, {\n *   availabilityChannel: \"agent-availability\",\n *   name: \"My Agent Broker\",\n *   agentTypes: [{\n *     id: \"code-assistant\",\n *     name: \"Code Assistant\",\n *     description: \"An agent that helps with coding tasks\",\n *     providesMethods: [{ name: \"execute_code\", parameters: {...}, description: \"Execute code\" }],\n *     requiresMethods: [{ name: \"file_read\", required: true }],\n *   }],\n *   onInvite: async (invite, senderId) => {\n *     // Custom acceptance logic\n *     return { accept: true };\n *   },\n *   onSpawn: async (invite, agentType) => {\n *     // Spawn the agent on the target channel\n *     const agent = await spawnMyAgent(invite.targetChannel, agentType);\n *     return { agentId: agent.id };\n *   },\n * });\n * ```\n */\nexport declare function connectAsBroker(serverUrl: string, token: string, options: BrokerConnectOptions): Promise<BrokerClient>;\n/**\n * Helper to create a self-brokering agent that handles its own invites.\n * Useful for agents that can handle multiple concurrent conversations.\n *\n * @example\n * ```ts\n * const selfBroker = connectAsSelfBroker(serverUrl, token, {\n *   availabilityChannel: \"agent-availability\",\n *   name: \"Multi-conversation Agent\",\n *   agentType: {\n *     id: \"chat-agent\",\n *     name: \"Chat Agent\",\n *     description: \"A conversational agent\",\n *     providesMethods: [...],\n *     requiresMethods: [],\n *   },\n *   onInvite: async (invite) => {\n *     // Connect myself to the target channel\n *     const workClient = await connect({\n *       serverUrl,\n *       token,\n *       channel: invite.targetChannel,\n *       handle: \"chat-agent\",\n *       name: \"Chat Agent\",\n *       type: \"agent\",\n *     });\n *     return { accept: true, agentId: workClient.pubsub.clientId };\n *   },\n * });\n * ```\n */\nexport declare function connectAsSelfBroker(serverUrl: string, token: string, options: Omit<BrokerConnectOptions, \"agentTypes\" | \"onSpawn\"> & {\n    agentType: AgentTypeAdvertisement;\n}): Promise<BrokerClient>;\n//# sourceMappingURL=broker.d.ts.map",
      "client.d.ts": "import type { AgenticClient, AgenticParticipantMetadata, ConnectOptions, DiscoveredMethod, JsonSchema } from \"./types.js\";\nexport interface AgenticClientImpl<T extends AgenticParticipantMetadata = AgenticParticipantMetadata> extends AgenticClient<T> {\n}\n/**\n * Connect to an agentic messaging channel.\n *\n * This is the main entry point for the agentic messaging system. It establishes\n * a WebSocket connection to the pubsub server, registers methods, and sets up\n * session persistence using the server's contextId.\n *\n * The returned promise resolves after:\n * 1. WebSocket connection is established\n * 2. Initial replay is complete (messages collected or streamed based on replayMode)\n * 3. Session state is loaded (using server's contextId)\n *\n * @param options - Connection configuration\n * @param options.serverUrl - WebSocket server URL (e.g., \"ws://127.0.0.1:49452\")\n * @param options.token - Authentication token for the pubsub server\n * @param options.channel - Channel name to join\n * @param options.handle - Unique handle for @-mentions (must be unique within channel)\n * @param options.name - Display name for this participant\n * @param options.type - Participant type (e.g., \"panel\", \"worker\", \"agent\", \"claude-code\")\n * @param options.extraMetadata - Additional metadata to include in presence\n * @param options.contextId - Context ID for channel creators (joiners get it from server)\n * @param options.reconnect - Auto-reconnect on disconnect (boolean or ReconnectConfig)\n * @param options.replayMode - How to handle replay: \"collect\" (aggregate), \"stream\" (emit), or \"skip\"\n * @param options.methods - Methods this participant provides (auto-executed on method-call)\n * @param options.clientId - Custom client ID (defaults to random UUID)\n * @param options.skipOwnMessages - Skip messages sent by this client in events()\n *\n * @returns Promise resolving to an AgenticClient instance\n *\n * @throws {AgenticError} With code \"validation-error\" if metadata is invalid\n * @throws {AgenticError} With code \"handle-conflict\" if handle already in use\n * @throws {AgenticError} With code \"connection-error\" if connection fails\n *\n * @example\n * ```typescript\n * // Basic connection\n * const client = await connect({\n *   serverUrl: \"ws://localhost:49452\",\n *   token: \"my-token\",\n *   channel: \"my-channel\",\n *   handle: \"my-agent\",\n *   name: \"My Agent\",\n *   type: \"agent\",\n * });\n *\n * // With session persistence and tools\n * const client = await connect({\n *   serverUrl,\n *   token,\n *   channel: \"chat-room\",\n *   handle: \"assistant\",\n *   name: \"AI Assistant\",\n *   type: \"worker\",\n *   contextId: \"my-workspace-id\",\n *   reconnect: true,\n *   methods: {\n *     search: {\n *       description: \"Search for files\",\n *       parameters: z.object({ query: z.string() }),\n *       execute: async (args) => ({ results: [] }),\n *     },\n *   },\n * });\n * ```\n */\nexport declare function connect<T extends AgenticParticipantMetadata = AgenticParticipantMetadata>(options: ConnectOptions<T>): Promise<AgenticClient<T>>;\n/** Tool definition returned by createToolsForAgentSDK */\nexport interface AgentSDKToolDefinition {\n    /** Prefixed tool name for SDK consumption (e.g., \"pubsub_panelId_file_read\") */\n    name: string;\n    /** Original method name without prefix (e.g., \"file_read\") */\n    originalMethodName: string;\n    /** Provider ID that registered this method */\n    providerId: string;\n    /** Tool description */\n    description?: string;\n    /** JSON Schema for tool parameters */\n    parameters: JsonSchema;\n}\n/**\n * Create tool definitions suitable for agent SDK integration.\n * Produces stable, conflict-free tool names and a single execute() dispatcher.\n * Note: This function maintains the \"tools\" naming because it produces output\n * for LLM SDK integration where \"tools\" is the standard terminology.\n */\nexport declare function createToolsForAgentSDK(client: AgenticClient, options?: {\n    filter?: (method: DiscoveredMethod) => boolean;\n    namePrefix?: string;\n}): {\n    definitions: AgentSDKToolDefinition[];\n    execute: (name: string, args: unknown, signal?: AbortSignal) => Promise<unknown>;\n};\n//# sourceMappingURL=client.d.ts.map",
      "config-entry.d.ts": "export { CLAUDE_CODE_PARAMETERS, AI_RESPONDER_PARAMETERS, CODEX_PARAMETERS, getParameterDefaults, CLAUDE_MODEL_FALLBACKS, AI_ROLE_FALLBACKS, } from \"./agent-configs.js\";\n//# sourceMappingURL=config-entry.d.ts.map",
      "execution.d.ts": "/**\n * Execution pause/resume functionality for agents.\n *\n * This module provides a pause method that agents can use to pause execution\n * for user input or clarification.\n */\n/**\n * Factory function to create a pause method definition.\n *\n * The pause method returns successfully and signals execution to halt.\n * The calling code (responder worker) should monitor isPaused() or listen\n * for the pause event to stop processing when this method is called.\n *\n * @param publishPause - Callback to publish pause event to channel with messageId\n * @returns A method definition for pausing execution\n */\nexport declare function createPauseMethodDefinition(publishPause: (messageId: string, reason: string) => Promise<void>): {\n    description: string;\n    parameters: {\n        type: \"object\";\n        properties: {\n            reason: {\n                type: string;\n                description: string;\n            };\n        };\n        required: string[];\n    };\n    streaming: boolean;\n    execute: (args: unknown, ctx: {\n        callId: string;\n        callerId: string;\n        signal: AbortSignal;\n        stream: (content: unknown) => Promise<void>;\n    }) => Promise<{\n        content: {\n            type: \"text\";\n            text: string;\n        }[];\n    }>;\n};\n//# sourceMappingURL=execution.d.ts.map",
      "index.d.ts": "export * from \"./types.js\";\nexport * from \"./protocol.js\";\nexport { connect, createToolsForAgentSDK, type AgentSDKToolDefinition } from \"./client.js\";\nexport type { AgenticClient } from \"./types.js\";\nexport { DEFAULT_CHAT_ASSISTANT_PERSONA, COMPONENT_ENHANCED_RICH_TEXT_GUIDE, RESTRICTED_MODE_ENVIRONMENT_GUIDE, createRichTextChatSystemPrompt, createRestrictedModeSystemPrompt, } from \"./prompts.js\";\nexport type { Participant, RosterUpdate, ParticipantMetadata } from \"@natstack/pubsub\";\nexport { jsonSchemaToZod, jsonSchemaToZodRawShape, isRecord } from \"./json-schema-to-zod.js\";\nexport { type ChatParticipantMetadata, parseAgentConfig, createLogger, formatArgsForLog, isMessageTargetedAt, CONTENT_TYPE_THINKING, createThinkingTracker, type ThinkingTracker, type ThinkingTrackerClient, type ThinkingTrackerState, type ThinkingTrackerOptions, } from \"./responder-utils.js\";\nexport { createPauseMethodDefinition, } from \"./execution.js\";\nexport { createInterruptHandler, type InterruptHandlerOptions, } from \"./interrupt-handler.js\";\nexport { aggregateReplayEvents, formatMissedContext, DEFAULT_MISSED_CONTEXT_MAX_CHARS, DEFAULT_METHOD_RESULT_MAX_CHARS, } from \"./missed-context.js\";\nexport { requestToolApproval, needsApprovalForTool, extractMethodName, isReadOnlyTool, READ_ONLY_TOOLS, APPROVAL_LEVELS } from \"./tool-approval.js\";\nexport type { ApprovalOptions, ApprovalLevel } from \"./tool-approval.js\";\nexport * from \"./tool-schemas.js\";\nexport { showPermissionPrompt, findPanelParticipant, validateRestrictedMode, type PermissionPromptOptions, } from \"./worker-base.js\";\n//# sourceMappingURL=index.d.ts.map",
      "interrupt-handler.d.ts": "/**\n * Interrupt handler for agent execution.\n *\n * Monitors for RPC pause method calls and provides interrupt state.\n * Used by responder workers to support user interruption.\n */\nimport type { AgenticClient, AgenticParticipantMetadata } from \"./types.js\";\nexport interface InterruptHandlerOptions<T extends AgenticParticipantMetadata = AgenticParticipantMetadata> {\n    client: AgenticClient<T>;\n    messageId: string;\n    onPause?: (reason: string) => void | Promise<void>;\n}\n/**\n * Creates an interrupt monitor for agent execution.\n *\n * Monitors for RPC pause method calls and provides interrupt state.\n * The monitor runs concurrently with the main execution loop and can be checked\n * via isPaused() to determine when to stop processing.\n *\n * @param options - Configuration for the interrupt handler\n * @returns Object with monitor task, status check, and cleanup function\n *\n * @example\n * ```typescript\n * const handler = createInterruptHandler({\n *   client,\n *   messageId: userMessageId,\n *   onPause: async (reason) => {\n *     console.log(`Interrupted: ${reason}`);\n *     if (queryInstance) await queryInstance.interrupt();\n *   }\n * });\n *\n * // Start monitoring in background\n * void handler.monitor();\n *\n * // In main loop, check if paused\n * if (handler.isPaused()) {\n *   break; // Stop processing\n * }\n *\n * // On cleanup\n * handler.cleanup();\n * ```\n */\nexport declare function createInterruptHandler<T extends AgenticParticipantMetadata = AgenticParticipantMetadata>(options: InterruptHandlerOptions<T>): {\n    monitor: () => Promise<void>;\n    isPaused: () => boolean;\n    cleanup: () => void;\n};\n//# sourceMappingURL=interrupt-handler.d.ts.map",
      "json-schema-to-zod.d.ts": "/**\n * JSON Schema to Zod conversion utilities.\n *\n * Provides functions to convert JSON Schema definitions to Zod schemas,\n * useful for integrating with the Claude Agent SDK and other tools that\n * expect Zod schemas.\n */\nimport { z } from \"zod\";\n/**\n * Type guard for Record<string, unknown>\n */\nexport declare function isRecord(value: unknown): value is Record<string, unknown>;\n/**\n * Convert a JSON Schema to a Zod schema.\n *\n * Handles common JSON Schema patterns including:\n * - Primitive types (string, number, integer, boolean, null)\n * - Arrays with item schemas\n * - Objects with properties\n * - Enums\n * - Union types (oneOf, anyOf, allOf)\n * - Nullable types\n *\n * @param schema - The JSON Schema object to convert\n * @returns A Zod schema that validates according to the JSON Schema\n */\nexport declare function jsonSchemaToZod(schema: Record<string, unknown>): z.ZodTypeAny;\n/**\n * Convert a JSON Schema object to a Zod raw shape for use with z.object().\n *\n * This extracts the properties from a JSON Schema object definition\n * and converts each property to its corresponding Zod type.\n *\n * @param schema - The JSON Schema object to convert\n * @returns A ZodRawShape that can be passed to z.object()\n */\nexport declare function jsonSchemaToZodRawShape(schema: Record<string, unknown>): z.ZodRawShape;\n//# sourceMappingURL=json-schema-to-zod.d.ts.map",
      "missed-context.d.ts": "import type { AggregatedEvent, FormatOptions, IncomingEvent, MissedContext } from \"./types.js\";\n/** Default maximum characters for formatted missed context */\nexport declare const DEFAULT_MISSED_CONTEXT_MAX_CHARS = 20000;\n/** Default maximum characters for method result content in missed context */\nexport declare const DEFAULT_METHOD_RESULT_MAX_CHARS = 20000;\nexport declare function aggregateReplayEvents(events: IncomingEvent[]): AggregatedEvent[];\nexport declare function formatMissedContext(events: AggregatedEvent[], options?: FormatOptions): MissedContext;\n//# sourceMappingURL=missed-context.d.ts.map",
      "prompts.d.ts": "export declare const DEFAULT_CHAT_ASSISTANT_PERSONA = \"You are a helpful, concise assistant. Keep responses brief and friendly.\";\nexport declare const COMPONENT_ENHANCED_RICH_TEXT_GUIDE = \"Your messages support Markdown and MDX (Markdown with JSX). You can use:\\n- Standard Markdown: **bold**, *italic*, `code`, lists, headers, tables\\n- Radix UI components (for rich formatting): <Badge>, <Card>, <Callout>, <Flex>, <Box>\\n- Icons: <Icons.CheckIcon />, <Icons.InfoCircledIcon />, etc.\\n\\nLinks (NatStack):\\n- Markdown links are clickable in NatStack panels.\\n- `natstack-child:///panels/...` or `natstack-child:///workers/...` links create child panels/workers when clicked.\\n- Optional `#gitRef` fragment provisions a specific ref (branch/tag/commit), e.g. `natstack-child:///panels/root#HEAD`.\\n- `https://...` links opened from app panels create a browser child panel.\\n\\nExamples:\\n- `[Open Agent Manager](natstack-child:///panels/agent-manager)`\\n- `[Open Root @ HEAD](natstack-child:///panels/root#HEAD)`\\n\\nExample callout:\\n<Callout.Root color=\\\"blue\\\">\\n  <Callout.Icon><Icons.InfoCircledIcon /></Callout.Icon>\\n  <Callout.Text>This is an informational callout.</Callout.Text>\\n</Callout.Root>\\n\\nYou can use JSX components for emphasis, structured information, dynamic content and data exploration.\";\nexport declare function createRichTextChatSystemPrompt(persona?: string): string;\n/**\n * System prompt guidance for restricted environments where bash is unavailable.\n * This informs the LLM about available tools and their constraints.\n */\nexport declare const RESTRICTED_MODE_ENVIRONMENT_GUIDE = \"## Environment Constraints\\n\\nYou are running in a restricted environment without shell access. You MUST use only the tools listed below.\\n\\n### Always Available Tools\\n\\nThese tools are always available in restricted mode:\\n\\n| Tool | Purpose | Use Instead Of |\\n|------|---------|----------------|\\n| `Read` | Read file contents | `cat`, `head`, `tail`, `less` |\\n| `Write` | Create/overwrite files | `echo >`, `cat <<EOF` |\\n| `Edit` | String replacement editing | `sed`, `awk`, manual editing |\\n| `Glob` | Find files by pattern | `find`, `ls` |\\n| `Grep` | Search file contents | `grep`, `rg`, `ag` |\\n| `Tree` | Show directory structure | `tree`, `find` |\\n| `ListDirectory` | List directory contents | `ls`, `dir` |\\n| `GitStatus` | Repository status | `git status` |\\n| `GitDiff` | Show file changes | `git diff` |\\n| `GitLog` | Commit history | `git log` |\\n| `WebSearch` | Search the web | browser search |\\n| `WebFetch` | Fetch web page content | `curl`, `wget` |\\n\\n### Conditionally Available Tools\\n\\nThese tools MAY be available depending on your environment. Check if they work before relying on them:\\n\\n| Tool | Purpose | Use Instead Of |\\n|------|---------|----------------|\\n| `Remove` | Delete files/directories | `rm`, `rmdir` |\\n| `GitAdd` | Stage files | `git add` |\\n| `GitCommit` | Create commits | `git commit` |\\n| `GitCheckout` | Switch branches/restore | `git checkout`, `git switch` |\\n\\nIf a conditionally available tool is unavailable, explain to the user what manual steps they can take instead.\\n\\n### DISABLED Tools - Do NOT attempt to use these\\n\\nThe following tools/commands are NOT available in this environment. Do not try to call them:\\n\\n**Shell/Bash commands (NO Bash tool available):**\\n- `npm`, `yarn`, `pnpm`, `bun` - package managers\\n- `node`, `python`, `ruby` - interpreters\\n- `make`, `cargo`, `go build` - build tools\\n- `pytest`, `jest`, `vitest` - test runners\\n- `eslint`, `prettier`, `tsc` - linters/formatters\\n- `docker`, `kubectl` - container tools\\n- `ssh`, `scp` - remote access\\n- Any other shell command\\n\\n### Workflow Adaptations\\n\\n1. **For git operations:** Use `GitStatus`, `GitDiff`, `GitLog` (always available) and `GitAdd`, `GitCommit`, `GitCheckout` (if available)\\n2. **For file search:** Use `Glob` and `Grep` tools, not `find` or `rg`\\n3. **For file editing:** Use `Edit` for replacements, not sed/awk\\n4. **For web lookups:** Use `WebSearch` and `WebFetch` for documentation, APIs, etc.\\n5. **For build/test commands:** Inform the user they must run these manually\\n   - Example: \\\"Please run `npm test` to verify the changes\\\"\\n6. **For installations:** Inform the user to install dependencies manually\\n   - Example: \\\"Please run `npm install lodash` to add this dependency\\\"\";\n/**\n * Create a system prompt for restricted mode (no bash access).\n * Combines the rich text guide with restricted environment guidance.\n *\n * @param persona - Optional persona description\n * @returns Complete system prompt for restricted mode\n */\nexport declare function createRestrictedModeSystemPrompt(persona?: string): string;\n//# sourceMappingURL=prompts.d.ts.map",
      "protocol.d.ts": "import { z } from \"zod\";\nexport declare const NewMessageSchema: z.ZodObject<{\n    id: z.ZodString;\n    content: z.ZodString;\n    contentType: z.ZodOptional<z.ZodString>;\n    replyTo: z.ZodOptional<z.ZodString>;\n    /** IDs of intended recipients (empty = broadcast to all) */\n    at: z.ZodOptional<z.ZodArray<z.ZodString, \"many\">>;\n}, \"strip\", z.ZodTypeAny, {\n    content: string;\n    id: string;\n    contentType?: string | undefined;\n    replyTo?: string | undefined;\n    at?: string[] | undefined;\n}, {\n    content: string;\n    id: string;\n    contentType?: string | undefined;\n    replyTo?: string | undefined;\n    at?: string[] | undefined;\n}>;\nexport declare const UpdateMessageSchema: z.ZodObject<{\n    id: z.ZodString;\n    content: z.ZodOptional<z.ZodString>;\n    contentType: z.ZodOptional<z.ZodString>;\n    complete: z.ZodOptional<z.ZodBoolean>;\n}, \"strip\", z.ZodTypeAny, {\n    id: string;\n    content?: string | undefined;\n    contentType?: string | undefined;\n    complete?: boolean | undefined;\n}, {\n    id: string;\n    content?: string | undefined;\n    contentType?: string | undefined;\n    complete?: boolean | undefined;\n}>;\nexport declare const ErrorMessageSchema: z.ZodObject<{\n    id: z.ZodString;\n    error: z.ZodString;\n    code: z.ZodOptional<z.ZodString>;\n}, \"strip\", z.ZodTypeAny, {\n    error: string;\n    id: string;\n    code?: string | undefined;\n}, {\n    error: string;\n    id: string;\n    code?: string | undefined;\n}>;\nexport declare const MethodCallSchema: z.ZodObject<{\n    callId: z.ZodString;\n    methodName: z.ZodString;\n    providerId: z.ZodString;\n    args: z.ZodUnknown;\n}, \"strip\", z.ZodTypeAny, {\n    methodName: string;\n    callId: string;\n    providerId: string;\n    args?: unknown;\n}, {\n    methodName: string;\n    callId: string;\n    providerId: string;\n    args?: unknown;\n}>;\nexport declare const MethodResultSchema: z.ZodObject<{\n    callId: z.ZodString;\n    content: z.ZodOptional<z.ZodUnknown>;\n    contentType: z.ZodOptional<z.ZodString>;\n    complete: z.ZodOptional<z.ZodBoolean>;\n    isError: z.ZodOptional<z.ZodBoolean>;\n    progress: z.ZodOptional<z.ZodNumber>;\n}, \"strip\", z.ZodTypeAny, {\n    callId: string;\n    content?: unknown;\n    contentType?: string | undefined;\n    complete?: boolean | undefined;\n    isError?: boolean | undefined;\n    progress?: number | undefined;\n}, {\n    callId: string;\n    content?: unknown;\n    contentType?: string | undefined;\n    complete?: boolean | undefined;\n    isError?: boolean | undefined;\n    progress?: number | undefined;\n}>;\nexport declare const MethodCancelSchema: z.ZodObject<{\n    callId: z.ZodString;\n}, \"strip\", z.ZodTypeAny, {\n    callId: string;\n}, {\n    callId: string;\n}>;\nexport declare const ExecutionPauseSchema: z.ZodObject<{\n    messageId: z.ZodString;\n    status: z.ZodEnum<[\"paused\", \"resumed\", \"cancelled\"]>;\n    reason: z.ZodOptional<z.ZodString>;\n}, \"strip\", z.ZodTypeAny, {\n    status: \"cancelled\" | \"paused\" | \"resumed\";\n    messageId: string;\n    reason?: string | undefined;\n}, {\n    status: \"cancelled\" | \"paused\" | \"resumed\";\n    messageId: string;\n    reason?: string | undefined;\n}>;\nexport declare const ToolRoleRequestSchema: z.ZodObject<{\n    group: z.ZodEnum<[\"file-ops\", \"git-ops\"]>;\n    requesterId: z.ZodString;\n    requesterType: z.ZodString;\n}, \"strip\", z.ZodTypeAny, {\n    group: \"file-ops\" | \"git-ops\";\n    requesterId: string;\n    requesterType: string;\n}, {\n    group: \"file-ops\" | \"git-ops\";\n    requesterId: string;\n    requesterType: string;\n}>;\nexport declare const ToolRoleResponseSchema: z.ZodObject<{\n    group: z.ZodEnum<[\"file-ops\", \"git-ops\"]>;\n    accepted: z.ZodBoolean;\n    handoffTo: z.ZodOptional<z.ZodString>;\n}, \"strip\", z.ZodTypeAny, {\n    accepted: boolean;\n    group: \"file-ops\" | \"git-ops\";\n    handoffTo?: string | undefined;\n}, {\n    accepted: boolean;\n    group: \"file-ops\" | \"git-ops\";\n    handoffTo?: string | undefined;\n}>;\nexport declare const ToolRoleHandoffSchema: z.ZodObject<{\n    group: z.ZodEnum<[\"file-ops\", \"git-ops\"]>;\n    from: z.ZodString;\n    to: z.ZodString;\n}, \"strip\", z.ZodTypeAny, {\n    group: \"file-ops\" | \"git-ops\";\n    from: string;\n    to: string;\n}, {\n    group: \"file-ops\" | \"git-ops\";\n    from: string;\n    to: string;\n}>;\nexport type NewMessage = z.infer<typeof NewMessageSchema>;\nexport type UpdateMessage = z.infer<typeof UpdateMessageSchema>;\nexport type ErrorMessage = z.infer<typeof ErrorMessageSchema>;\nexport type MethodCall = z.infer<typeof MethodCallSchema>;\nexport type MethodResult = z.infer<typeof MethodResultSchema>;\nexport type MethodCancel = z.infer<typeof MethodCancelSchema>;\nexport type ExecutionPause = z.infer<typeof ExecutionPauseSchema>;\nexport type ToolRoleRequest = z.infer<typeof ToolRoleRequestSchema>;\nexport type ToolRoleResponse = z.infer<typeof ToolRoleResponseSchema>;\nexport type ToolRoleHandoff = z.infer<typeof ToolRoleHandoffSchema>;\n//# sourceMappingURL=protocol.d.ts.map",
      "responder-utils.d.ts": "/**\n * Shared utilities for AI responder workers.\n *\n * These utilities provide common functionality used across different\n * responder implementations (Claude Code, Codex, etc.).\n */\nimport type { AgenticParticipantMetadata, IncomingNewMessage } from \"./types.js\";\n/**\n * Standard participant metadata for chat-style channels.\n * Used by responder workers and panels to identify participant types.\n */\nexport interface ChatParticipantMetadata extends AgenticParticipantMetadata {\n    name: string;\n    type: \"panel\" | \"ai-responder\" | \"claude-code\" | \"codex\";\n}\n/**\n * Safely parse AGENT_CONFIG from environment.\n * Returns empty object if parsing fails or config is invalid.\n */\nexport declare function parseAgentConfig(): Record<string, unknown>;\n/**\n * Create a prefixed logger function for responder workers.\n * @param prefix - The prefix to include in log messages (e.g., \"Claude Code\", \"Codex\")\n * @param workerId - Optional worker ID to include in logs\n */\nexport declare function createLogger(prefix: string, workerId?: string): (message: string) => void;\n/**\n * Format arguments for logging, handling circular references and truncating long output.\n * @param args - The arguments to format\n * @param maxLen - Maximum length of the output string (default: 2000)\n */\nexport declare function formatArgsForLog(args: unknown, maxLen?: number): string;\n/**\n * Check if a message is targeted at a specific participant.\n * Returns true if:\n * - `at` is undefined or empty (broadcast to all)\n * - `at` includes the given participantId\n */\nexport declare function isMessageTargetedAt(msg: IncomingNewMessage, participantId: string): boolean;\n/**\n * Content type constant for thinking/reasoning messages.\n * Use this when sending messages with `contentType` to ensure consistency.\n */\nexport declare const CONTENT_TYPE_THINKING: \"thinking\";\n/**\n * Interface for the client methods needed by ThinkingTracker.\n * This allows the tracker to work with any AgenticClient implementation.\n */\nexport interface ThinkingTrackerClient {\n    send(content: string, options?: {\n        replyTo?: string;\n        contentType?: string;\n    }): Promise<{\n        messageId: string;\n    }>;\n    update(messageId: string, content: string): Promise<void>;\n    complete(messageId: string): Promise<void>;\n}\n/**\n * State managed by the thinking tracker.\n */\nexport interface ThinkingTrackerState {\n    /** Current content type being streamed */\n    currentContentType: \"thinking\" | \"text\" | null;\n    /** Message ID for the current thinking message, if any */\n    thinkingMessageId: string | null;\n    /** Item ID for the current thinking block (for Codex SDK) */\n    thinkingItemId: string | null;\n}\n/**\n * Options for creating a thinking tracker.\n */\nexport interface ThinkingTrackerOptions {\n    /** Client to use for sending/updating messages */\n    client: ThinkingTrackerClient;\n    /** Logger function for debug output */\n    log?: (message: string) => void;\n    /** Message ID to use as replyTo for thinking messages */\n    replyTo?: string;\n}\n/**\n * ThinkingTracker manages the state of thinking/reasoning messages.\n *\n * This utility provides a consistent way to handle thinking content across\n * different responder implementations (Claude Code, Codex, pubsub-chat).\n *\n * It handles:\n * - Starting new thinking messages with proper contentType\n * - Streaming thinking content\n * - Completing thinking messages when transitioning to text\n * - Cleaning up orphaned thinking messages on error\n *\n * @example\n * ```typescript\n * const tracker = createThinkingTracker({ client, log, replyTo: incoming.id });\n *\n * // When thinking starts\n * await tracker.startThinking();\n *\n * // When thinking content arrives\n * await tracker.updateThinking(\"some reasoning...\");\n *\n * // When transitioning to text\n * await tracker.endThinking();\n *\n * // In catch block\n * } catch (err) {\n *   await tracker.cleanup();\n *   // ... handle error\n * }\n * ```\n */\nexport interface ThinkingTracker {\n    /** Current state of the tracker */\n    readonly state: ThinkingTrackerState;\n    /**\n     * Start a new thinking message.\n     * @param itemId - Optional item ID for tracking (used by Codex SDK)\n     * @returns The message ID of the created thinking message\n     */\n    startThinking(itemId?: string): Promise<string>;\n    /**\n     * Update the current thinking message with new content.\n     * @param content - Content to append to the thinking message\n     */\n    updateThinking(content: string): Promise<void>;\n    /**\n     * End the current thinking message and transition to text mode.\n     * Safe to call even if not currently in thinking mode.\n     */\n    endThinking(): Promise<void>;\n    /**\n     * Check if we're currently in thinking mode.\n     */\n    isThinking(): boolean;\n    /**\n     * Check if an item ID matches the current thinking item.\n     * Useful for Codex SDK where items have unique IDs.\n     */\n    isThinkingItem(itemId: string): boolean;\n    /**\n     * Set the current content type to text (without ending thinking).\n     * Use this when starting text output that doesn't follow thinking.\n     */\n    setTextMode(): void;\n    /**\n     * Cleanup any pending thinking message.\n     * Call this in error handlers to ensure thinking messages are completed.\n     */\n    cleanup(): Promise<void>;\n}\n/**\n * Create a ThinkingTracker for managing thinking/reasoning message state.\n */\nexport declare function createThinkingTracker(options: ThinkingTrackerOptions): ThinkingTracker;\n//# sourceMappingURL=responder-utils.d.ts.map",
      "session-db.d.ts": "export interface SessionRow {\n    sessionKey: string;\n    checkpointPubsubId: number | undefined;\n    sdkSessionId: string | undefined;\n    status: \"active\" | \"interrupted\";\n    settings: Record<string, unknown> | undefined;\n}\nexport declare class SessionDb {\n    private contextId;\n    private channel;\n    private handle;\n    private db;\n    private sessionKey;\n    private sessionRow;\n    constructor(contextId: string, channel: string, handle: string);\n    getSessionKey(): string;\n    initialize(): Promise<void>;\n    getOrCreateSession(): Promise<SessionRow>;\n    commitCheckpoint(pubsubId: number): Promise<void>;\n    updateSdkSession(sessionId: string): Promise<void>;\n    clearSdkSession(): Promise<void>;\n    updateSettings(settings: Record<string, unknown>): Promise<void>;\n    getSettings<T = Record<string, unknown>>(): Promise<T | null>;\n    markInterrupted(): Promise<void>;\n    close(): Promise<void>;\n    private initializeSchema;\n}\n//# sourceMappingURL=session-db.d.ts.map",
      "session-entry.d.ts": "export { SessionDb, type SessionRow } from \"./session-db.js\";\n//# sourceMappingURL=session-entry.d.ts.map",
      "settings-ui-generator.d.ts": "/**\n * Settings UI Generator\n *\n * Generates TSX form code from FieldDefinition arrays.\n * Used by workers to create settings forms for the feedback_ui method.\n */\nimport type { FieldDefinition } from \"@natstack/runtime\";\n/**\n * Options for generating settings form TSX\n */\nexport interface SettingsFormOptions {\n    /** Title displayed at the top of the form */\n    title: string;\n    /** Parameter definitions to render */\n    parameters: FieldDefinition[];\n    /** Current values for each parameter (used as defaults) */\n    currentValues: Record<string, unknown>;\n    /** Dynamic options to override static ones (e.g., model lists from SDK) */\n    dynamicOptions?: Record<string, Array<{\n        value: string;\n        label: string;\n        description?: string;\n    }>>;\n}\n/**\n * Generate a complete settings form TSX component from parameter definitions.\n *\n * @deprecated Use schema-based feedback_ui format instead.\n * This function generates TSX strings which require runtime compilation.\n * The schema format is simpler, more secure, and supports all FieldDefinition features.\n *\n * Only use this for UIs that need custom layout, validation, or interactions\n * that can't be expressed with FieldDefinition[].\n *\n * @example\n * // New preferred way (schema format):\n * client.callMethod(panel.id, \"feedback_ui\", {\n *   schema: {\n *     title: \"Settings\",\n *     fields: PARAMETERS,\n *     values: currentSettings,\n *   },\n * });\n *\n * // Old way (deprecated):\n * const tsx = generateSettingsFormTsx({\n *   title: \"Settings\",\n *   parameters: PARAMETERS,\n *   currentValues: currentSettings,\n * });\n * client.callMethod(panel.id, \"feedback_ui\", { code: tsx });\n */\nexport declare function generateSettingsFormTsx(options: SettingsFormOptions): string;\n//# sourceMappingURL=settings-ui-generator.d.ts.map",
      "settings-ui.d.ts": "/**\n * Settings UI Generator\n *\n * Provides types and utilities for generating settings forms that workers\n * can display via the feedback_ui method. Each worker defines its own\n * settings schema and builds fields dynamically.\n */\n/** Field definition for dynamically-generated settings forms */\nexport interface SettingsField {\n    /** Property key in the settings object */\n    key: string;\n    /** Display label for the field */\n    label: string;\n    /** Field type determines the input control */\n    type: \"text\" | \"number\" | \"boolean\" | \"select\" | \"textarea\";\n    /** Options for select fields */\n    options?: Array<{\n        value: string;\n        label: string;\n    }>;\n    /** Help text shown below the field */\n    description?: string;\n    /** Whether the field is disabled (e.g., init-time-only after session starts) */\n    disabled?: boolean;\n    /** Default value for the field */\n    defaultValue?: unknown;\n    /** Validation constraints */\n    validation?: {\n        min?: number;\n        max?: number;\n        required?: boolean;\n    };\n}\n/** Options for generating a settings form */\nexport interface SettingsFormOptions {\n    /** Form title */\n    title: string;\n    /** Optional description shown below title */\n    description?: string;\n    /** Field definitions */\n    fields: SettingsField[];\n    /** Current values to populate the form */\n    currentValues: Record<string, unknown>;\n    /** Whether to show a \"Use Defaults\" / skip button */\n    showSkipButton?: boolean;\n}\n/**\n * Generate TSX code for a settings form component.\n *\n * The generated component uses Radix UI Themes components and expects\n * to be rendered in a feedback_ui context with onSubmit callback.\n */\nexport declare function generateSettingsFormTsx(options: SettingsFormOptions): string;\n//# sourceMappingURL=settings-ui.d.ts.map",
      "tool-approval.d.ts": "/**\n * Tool Approval Utilities\n *\n * Functions for requesting user approval before executing tools\n * in an agentic workflow using feedback_form.\n */\nimport type { AgenticClient } from \"./types.js\";\nimport { extractMethodName } from \"./tool-schemas.js\";\nexport { extractMethodName };\n/**\n * Approval level constants for tool execution.\n *\n * These define how much autonomy the agent has when executing tools:\n * - ASK_ALL: Always prompt user for approval before any tool execution\n * - AUTO_SAFE: Auto-approve read-only operations, prompt for write operations\n * - FULL_AUTO: Execute all tools without prompting (use with caution)\n */\nexport declare const APPROVAL_LEVELS: {\n    /** Always ask for approval before executing any tool */\n    readonly ASK_ALL: 0;\n    /** Auto-approve read-only operations, ask for write operations */\n    readonly AUTO_SAFE: 1;\n    /** Never ask, execute all tools automatically */\n    readonly FULL_AUTO: 2;\n};\nexport type ApprovalLevel = typeof APPROVAL_LEVELS[keyof typeof APPROVAL_LEVELS];\n/**\n * Read-only tools set including both naming conventions.\n * Derived from READ_ONLY_BASE_TOOLS using canonical mappings.\n */\nexport declare const READ_ONLY_TOOLS: Set<string>;\nexport interface ApprovalOptions {\n    title?: string;\n    severity?: \"info\" | \"warning\" | \"danger\";\n    showArgs?: boolean;\n    /** Abort signal to cancel the approval request */\n    signal?: AbortSignal;\n}\n/**\n * Show tool approval UI via feedback_form and wait for user decision.\n * Returns false if cancelled or aborted.\n */\nexport declare function requestToolApproval(client: AgenticClient, panelId: string, toolName: string, args: Record<string, unknown>, options?: ApprovalOptions): Promise<boolean>;\n/**\n * Check if a tool is read-only (safe for auto-approval at level 1).\n * Uses both the explicit READ_ONLY_TOOLS set and pattern matching.\n */\nexport declare function isReadOnlyTool(methodName: string): boolean;\n/**\n * Determine if a tool needs approval based on approval level.\n *\n * @param toolName - The tool name (may be prefixed)\n * @param approvalLevel - One of APPROVAL_LEVELS (ASK_ALL, AUTO_SAFE, FULL_AUTO)\n * @returns true if user approval is required, false if auto-approved\n *\n * @see APPROVAL_LEVELS for level definitions\n */\nexport declare function needsApprovalForTool(toolName: string, approvalLevel: ApprovalLevel | number): boolean;\n//# sourceMappingURL=tool-approval.d.ts.map",
      "tool-schemas.d.ts": "/**\n * Shared Zod schemas for standard agentic tools.\n *\n * These schemas define the API contract for file, search, directory, and git tools\n * that can be exposed via pubsub RPC. They ensure compatibility between:\n * - Panel implementations (providers)\n * - Worker tool definitions (consumers)\n * - Claude Code expected tool APIs\n */\nimport { z } from \"zod\";\n/**\n * file_read - Read file contents with optional pagination\n * Matches Claude Code `Read` tool behavior\n */\nexport declare const FileReadArgsSchema: z.ZodObject<{\n    file_path: z.ZodString;\n    offset: z.ZodOptional<z.ZodNumber>;\n    limit: z.ZodOptional<z.ZodNumber>;\n}, \"strip\", z.ZodTypeAny, {\n    file_path: string;\n    offset?: number | undefined;\n    limit?: number | undefined;\n}, {\n    file_path: string;\n    offset?: number | undefined;\n    limit?: number | undefined;\n}>;\nexport type FileReadArgs = z.infer<typeof FileReadArgsSchema>;\n/**\n * file_write - Create or overwrite a file\n * Matches Claude Code `Write` tool behavior\n */\nexport declare const FileWriteArgsSchema: z.ZodObject<{\n    file_path: z.ZodString;\n    content: z.ZodString;\n}, \"strip\", z.ZodTypeAny, {\n    file_path: string;\n    content: string;\n}, {\n    file_path: string;\n    content: string;\n}>;\nexport type FileWriteArgs = z.infer<typeof FileWriteArgsSchema>;\n/**\n * file_edit - String replacement editing\n * Matches Claude Code `Edit` tool behavior\n */\nexport declare const FileEditArgsSchema: z.ZodObject<{\n    file_path: z.ZodString;\n    old_string: z.ZodString;\n    new_string: z.ZodString;\n    replace_all: z.ZodDefault<z.ZodOptional<z.ZodBoolean>>;\n}, \"strip\", z.ZodTypeAny, {\n    file_path: string;\n    old_string: string;\n    new_string: string;\n    replace_all: boolean;\n}, {\n    file_path: string;\n    old_string: string;\n    new_string: string;\n    replace_all?: boolean | undefined;\n}>;\nexport type FileEditArgs = z.infer<typeof FileEditArgsSchema>;\n/**\n * rm - Delete files or directories\n */\nexport declare const RmArgsSchema: z.ZodObject<{\n    path: z.ZodString;\n    recursive: z.ZodDefault<z.ZodOptional<z.ZodBoolean>>;\n}, \"strip\", z.ZodTypeAny, {\n    path: string;\n    recursive: boolean;\n}, {\n    path: string;\n    recursive?: boolean | undefined;\n}>;\nexport type RmArgs = z.infer<typeof RmArgsSchema>;\n/**\n * glob - Find files by pattern\n * Matches Claude Code `Glob` tool behavior\n */\nexport declare const GlobArgsSchema: z.ZodObject<{\n    pattern: z.ZodString;\n    path: z.ZodOptional<z.ZodString>;\n}, \"strip\", z.ZodTypeAny, {\n    pattern: string;\n    path?: string | undefined;\n}, {\n    pattern: string;\n    path?: string | undefined;\n}>;\nexport type GlobArgs = z.infer<typeof GlobArgsSchema>;\n/**\n * grep - Search file contents\n * Matches Claude Code `Grep` tool behavior (ripgrep-compatible)\n */\nexport declare const GrepArgsSchema: z.ZodObject<{\n    pattern: z.ZodString;\n    path: z.ZodOptional<z.ZodString>;\n    output_mode: z.ZodDefault<z.ZodOptional<z.ZodEnum<[\"content\", \"files_with_matches\", \"count\"]>>>;\n    glob: z.ZodOptional<z.ZodString>;\n    type: z.ZodOptional<z.ZodString>;\n    \"-i\": z.ZodOptional<z.ZodBoolean>;\n    \"-n\": z.ZodDefault<z.ZodOptional<z.ZodBoolean>>;\n    \"-A\": z.ZodOptional<z.ZodNumber>;\n    \"-B\": z.ZodOptional<z.ZodNumber>;\n    \"-C\": z.ZodOptional<z.ZodNumber>;\n    head_limit: z.ZodOptional<z.ZodNumber>;\n    offset: z.ZodOptional<z.ZodNumber>;\n    multiline: z.ZodOptional<z.ZodBoolean>;\n}, \"strip\", z.ZodTypeAny, {\n    pattern: string;\n    output_mode: \"content\" | \"files_with_matches\" | \"count\";\n    \"-n\": boolean;\n    offset?: number | undefined;\n    path?: string | undefined;\n    type?: string | undefined;\n    glob?: string | undefined;\n    \"-i\"?: boolean | undefined;\n    \"-A\"?: number | undefined;\n    \"-B\"?: number | undefined;\n    \"-C\"?: number | undefined;\n    head_limit?: number | undefined;\n    multiline?: boolean | undefined;\n}, {\n    pattern: string;\n    offset?: number | undefined;\n    path?: string | undefined;\n    type?: string | undefined;\n    output_mode?: \"content\" | \"files_with_matches\" | \"count\" | undefined;\n    glob?: string | undefined;\n    \"-i\"?: boolean | undefined;\n    \"-n\"?: boolean | undefined;\n    \"-A\"?: number | undefined;\n    \"-B\"?: number | undefined;\n    \"-C\"?: number | undefined;\n    head_limit?: number | undefined;\n    multiline?: boolean | undefined;\n}>;\nexport type GrepArgs = z.infer<typeof GrepArgsSchema>;\n/**\n * tree - Show directory structure\n */\nexport declare const TreeArgsSchema: z.ZodObject<{\n    path: z.ZodOptional<z.ZodString>;\n    depth: z.ZodDefault<z.ZodOptional<z.ZodNumber>>;\n    show_hidden: z.ZodDefault<z.ZodOptional<z.ZodBoolean>>;\n    dirs_only: z.ZodDefault<z.ZodOptional<z.ZodBoolean>>;\n}, \"strip\", z.ZodTypeAny, {\n    depth: number;\n    show_hidden: boolean;\n    dirs_only: boolean;\n    path?: string | undefined;\n}, {\n    path?: string | undefined;\n    depth?: number | undefined;\n    show_hidden?: boolean | undefined;\n    dirs_only?: boolean | undefined;\n}>;\nexport type TreeArgs = z.infer<typeof TreeArgsSchema>;\n/**\n * list_directory - List directory contents\n * Matches `ls -la` output format\n */\nexport declare const ListDirectoryArgsSchema: z.ZodObject<{\n    path: z.ZodString;\n}, \"strip\", z.ZodTypeAny, {\n    path: string;\n}, {\n    path: string;\n}>;\nexport type ListDirectoryArgs = z.infer<typeof ListDirectoryArgsSchema>;\n/**\n * git_status - Repository status\n */\nexport declare const GitStatusArgsSchema: z.ZodObject<{\n    path: z.ZodOptional<z.ZodString>;\n}, \"strip\", z.ZodTypeAny, {\n    path?: string | undefined;\n}, {\n    path?: string | undefined;\n}>;\nexport type GitStatusArgs = z.infer<typeof GitStatusArgsSchema>;\n/**\n * git_diff - Show file changes\n */\nexport declare const GitDiffArgsSchema: z.ZodObject<{\n    path: z.ZodOptional<z.ZodString>;\n    staged: z.ZodOptional<z.ZodBoolean>;\n    file: z.ZodOptional<z.ZodString>;\n}, \"strip\", z.ZodTypeAny, {\n    path?: string | undefined;\n    staged?: boolean | undefined;\n    file?: string | undefined;\n}, {\n    path?: string | undefined;\n    staged?: boolean | undefined;\n    file?: string | undefined;\n}>;\nexport type GitDiffArgs = z.infer<typeof GitDiffArgsSchema>;\n/**\n * git_log - Commit history\n */\nexport declare const GitLogArgsSchema: z.ZodObject<{\n    path: z.ZodOptional<z.ZodString>;\n    limit: z.ZodDefault<z.ZodOptional<z.ZodNumber>>;\n    format: z.ZodDefault<z.ZodOptional<z.ZodEnum<[\"oneline\", \"full\"]>>>;\n}, \"strip\", z.ZodTypeAny, {\n    limit: number;\n    format: \"oneline\" | \"full\";\n    path?: string | undefined;\n}, {\n    limit?: number | undefined;\n    path?: string | undefined;\n    format?: \"oneline\" | \"full\" | undefined;\n}>;\nexport type GitLogArgs = z.infer<typeof GitLogArgsSchema>;\n/**\n * git_add - Stage files\n */\nexport declare const GitAddArgsSchema: z.ZodObject<{\n    files: z.ZodArray<z.ZodString, \"many\">;\n    path: z.ZodOptional<z.ZodString>;\n}, \"strip\", z.ZodTypeAny, {\n    files: string[];\n    path?: string | undefined;\n}, {\n    files: string[];\n    path?: string | undefined;\n}>;\nexport type GitAddArgs = z.infer<typeof GitAddArgsSchema>;\n/**\n * git_commit - Create commits\n */\nexport declare const GitCommitArgsSchema: z.ZodObject<{\n    message: z.ZodString;\n    path: z.ZodOptional<z.ZodString>;\n}, \"strip\", z.ZodTypeAny, {\n    message: string;\n    path?: string | undefined;\n}, {\n    message: string;\n    path?: string | undefined;\n}>;\nexport type GitCommitArgs = z.infer<typeof GitCommitArgsSchema>;\n/**\n * git_checkout - Switch branches or restore files\n */\nexport declare const GitCheckoutArgsSchema: z.ZodObject<{\n    branch: z.ZodOptional<z.ZodString>;\n    file: z.ZodOptional<z.ZodString>;\n    create: z.ZodOptional<z.ZodBoolean>;\n    path: z.ZodOptional<z.ZodString>;\n}, \"strip\", z.ZodTypeAny, {\n    path?: string | undefined;\n    file?: string | undefined;\n    branch?: string | undefined;\n    create?: boolean | undefined;\n}, {\n    path?: string | undefined;\n    file?: string | undefined;\n    branch?: string | undefined;\n    create?: boolean | undefined;\n}>;\nexport type GitCheckoutArgs = z.infer<typeof GitCheckoutArgsSchema>;\n/**\n * check_types - Run TypeScript type checking on panel/worker files\n * Returns diagnostics (errors, warnings) from the TypeScript compiler\n */\nexport declare const CheckTypesArgsSchema: z.ZodObject<{\n    panel_path: z.ZodString;\n    file_path: z.ZodOptional<z.ZodString>;\n}, \"strip\", z.ZodTypeAny, {\n    panel_path: string;\n    file_path?: string | undefined;\n}, {\n    panel_path: string;\n    file_path?: string | undefined;\n}>;\nexport type CheckTypesArgs = z.infer<typeof CheckTypesArgsSchema>;\n/**\n * get_type_info - Get TypeScript type information at a position\n * Useful for understanding types and getting documentation\n */\nexport declare const GetTypeInfoArgsSchema: z.ZodObject<{\n    panel_path: z.ZodString;\n    file_path: z.ZodString;\n    line: z.ZodNumber;\n    column: z.ZodNumber;\n}, \"strip\", z.ZodTypeAny, {\n    file_path: string;\n    panel_path: string;\n    line: number;\n    column: number;\n}, {\n    file_path: string;\n    panel_path: string;\n    line: number;\n    column: number;\n}>;\nexport type GetTypeInfoArgs = z.infer<typeof GetTypeInfoArgsSchema>;\n/**\n * get_completions - Get code completions at a position\n */\nexport declare const GetCompletionsArgsSchema: z.ZodObject<{\n    panel_path: z.ZodString;\n    file_path: z.ZodString;\n    line: z.ZodNumber;\n    column: z.ZodNumber;\n}, \"strip\", z.ZodTypeAny, {\n    file_path: string;\n    panel_path: string;\n    line: number;\n    column: number;\n}, {\n    file_path: string;\n    panel_path: string;\n    line: number;\n    column: number;\n}>;\nexport type GetCompletionsArgs = z.infer<typeof GetCompletionsArgsSchema>;\nexport declare const FILE_TYPE_MAPPINGS: Record<string, string[]>;\n/**\n * Mapping from pubsub tool names to Claude Code canonical tool names.\n * Used to provide familiar tool names to the LLM while using pubsub RPC underneath.\n */\nexport declare const CANONICAL_TOOL_MAPPINGS: Record<string, string>;\n/**\n * Reverse mapping from canonical names to pubsub tool names.\n */\nexport declare const REVERSE_CANONICAL_MAPPINGS: Record<string, string>;\n/**\n * Extract the actual method name from a prefixed tool name.\n * Tool names are formatted as: prefix_providerId_methodName\n * e.g., \"pubsub_abc123_settings\" -> \"settings\"\n *\n * This function is defined here (not in tool-approval.ts) to avoid\n * circular dependencies, since tool-approval imports from tool-schemas.\n */\nexport declare function extractMethodName(toolName: string): string;\n/**\n * Required methods for restricted mode (no bash access).\n * These are the minimum set of methods needed for file operations without shell.\n */\nexport declare const RESTRICTED_MODE_REQUIRED_METHODS: readonly [\"file_read\", \"file_write\", \"file_edit\", \"glob\", \"grep\", \"tree\", \"list_directory\", \"git_status\", \"git_diff\", \"git_log\"];\n/**\n * Optional methods that enhance restricted mode functionality.\n */\nexport declare const RESTRICTED_MODE_OPTIONAL_METHODS: readonly [\"rm\", \"git_add\", \"git_commit\", \"git_checkout\"];\n/**\n * All file/search/git tools that can be exposed via pubsub RPC.\n * These are the canonical tool names used across all workers in restricted mode.\n */\nexport declare const CANONICAL_PUBSUB_TOOL_NAMES: readonly [\"file_read\", \"file_write\", \"file_edit\", \"glob\", \"grep\", \"tree\", \"list_directory\", \"git_status\", \"git_diff\", \"git_log\", \"rm\", \"git_add\", \"git_commit\", \"git_checkout\"];\nexport type PubsubToolName = typeof CANONICAL_PUBSUB_TOOL_NAMES[number];\nimport type { ToolGroup } from \"./types.js\";\n/**\n * Tool groups - each is atomic for conflict resolution.\n * Providers claim entire groups, not individual tools.\n */\nexport declare const TOOL_GROUPS: Record<ToolGroup, readonly string[]>;\n/** List of all tool group names for iteration */\nexport declare const ALL_TOOL_GROUPS: ToolGroup[];\n/**\n * Get all tools belonging to the specified groups.\n */\nexport declare function getToolsForGroups(groups: ToolGroup[]): string[];\n/**\n * Get which groups a tool belongs to.\n * Uses pre-computed lookup for O(1) access.\n */\nexport declare function getGroupsForTool(toolName: string): ToolGroup[];\n/**\n * Result of validating required methods.\n */\nexport interface MethodValidationResult {\n    /** Whether all required methods are available */\n    ok: boolean;\n    /** List of missing required method names */\n    missing: string[];\n    /** List of available method names */\n    available: string[];\n    /** Map of method name to provider ID for available methods */\n    providers: Record<string, string>;\n}\n/**\n * Discovered method info (minimal interface for validation).\n */\nexport interface DiscoveredMethodInfo {\n    name: string;\n    providerId: string;\n}\n/**\n * Validate that required methods are available from discovered methods.\n *\n * @param discoveredMethods - Array of discovered method definitions\n * @param requiredMethods - Array of required method names (defaults to CLAUDE_CODE_REQUIRED_METHODS)\n * @returns Validation result with missing/available methods\n *\n * @example\n * ```typescript\n * const methods = client.discoverMethodDefs();\n * const result = validateRequiredMethods(methods);\n * if (!result.ok) {\n *   console.error(`Missing methods: ${result.missing.join(\", \")}`);\n * }\n * ```\n */\nexport declare function validateRequiredMethods(discoveredMethods: DiscoveredMethodInfo[], requiredMethods?: readonly string[]): MethodValidationResult;\n/**\n * Get the canonical tool name for a pubsub method name.\n * Returns the original name if no mapping exists.\n */\nexport declare function getCanonicalToolName(pubsubName: string): string;\n/**\n * Get the pubsub method name for a canonical tool name.\n * Returns the original name if no mapping exists.\n */\nexport declare function getPubsubMethodName(canonicalName: string): string;\n/**\n * Normalize any tool name format to pubsub snake_case format.\n *\n * Handles:\n * - Prefixed names: \"pubsub_abc123_file_edit\"  \"file_edit\"\n * - PascalCase: \"Edit\"  \"file_edit\"\n * - Already normalized: \"file_edit\"  \"file_edit\"\n *\n * @param toolName - Tool name in any format\n * @returns Normalized snake_case pubsub method name\n */\nexport declare function normalizeToolName(toolName: string): string;\n/**\n * Tools that have rich preview support in the UI (snake_case pubsub format).\n * Used by worker-base.ts to determine whether to use toolPreview or code field.\n */\nexport declare const RICH_PREVIEW_TOOLS: readonly [\"file_edit\", \"file_write\", \"rm\", \"git_commit\", \"git_checkout\", \"git_add\"];\nexport type RichPreviewToolName = (typeof RICH_PREVIEW_TOOLS)[number];\n/**\n * Check if a tool has rich preview support.\n * Accepts any naming format and normalizes before checking.\n *\n * @param toolName - Tool name in any format (prefixed, PascalCase, or snake_case)\n * @returns True if the tool has rich preview support\n */\nexport declare function hasRichPreview(toolName: string): boolean;\n/**\n * Type guards for rich preview tool arguments.\n * These use Zod schemas for validation, ensuring consistency with the schema definitions.\n */\nexport declare function isFileEditArgs(args: unknown): args is FileEditArgs;\nexport declare function isFileWriteArgs(args: unknown): args is FileWriteArgs;\nexport declare function isRmArgs(args: unknown): args is RmArgs;\nexport declare function isGitCommitArgs(args: unknown): args is GitCommitArgs;\nexport declare function isGitCheckoutArgs(args: unknown): args is GitCheckoutArgs;\nexport declare function isGitAddArgs(args: unknown): args is GitAddArgs;\n//# sourceMappingURL=tool-schemas.d.ts.map",
      "types.d.ts": "/**\n * @natstack/agentic-messaging types\n *\n * Agentic messaging protocol for method discovery, invocation, and streaming\n * results between distributed participants over pubsub.\n */\nimport type { Participant, ParticipantMetadata, PubSubClient, RosterUpdate } from \"@natstack/pubsub\";\nimport type { z } from \"zod\";\n/** JSON Schema representation for method parameters/returns. */\nexport type JsonSchema = Record<string, unknown>;\n/**\n * Standard participant type constants.\n * Use these instead of magic strings for participant type checks.\n */\nexport declare const PARTICIPANT_TYPES: {\n    readonly PANEL: \"panel\";\n    readonly WORKER: \"worker\";\n    readonly CLAUDE_CODE: \"claude-code\";\n    readonly CODEX: \"codex\";\n    readonly AI_RESPONDER: \"ai-responder\";\n};\nexport type ParticipantType = typeof PARTICIPANT_TYPES[keyof typeof PARTICIPANT_TYPES];\n/**\n * Tool groups for conflict detection.\n * Each group is atomic - providers claim entire groups, not individual tools.\n */\nexport type ToolGroup = \"file-ops\" | \"git-ops\";\n/**\n * Tool role declaration for a participant.\n * Indicates whether this participant provides tools for a group.\n */\nexport interface ToolRoleDeclaration {\n    /** Whether this participant is providing tools for this group */\n    providing: boolean;\n    /** Priority for conflict resolution (lower = higher priority, default: Infinity) */\n    priority?: number;\n}\n/**\n * Tool role conflict information.\n * Emitted when multiple participants claim the same tool group.\n */\nexport interface ToolRoleConflict {\n    /** The tool group with a conflict */\n    group: ToolGroup;\n    /** All participants claiming this group */\n    providers: Array<{\n        id: string;\n        name: string;\n        joinedAt: number;\n        priority?: number;\n    }>;\n    /** The resolved provider (based on priority, joinedAt, then id) */\n    resolvedProvider: string;\n}\n/**\n * Participant metadata for agentic messaging.\n * Extends base pubsub metadata with name, type, handle, and optional method advertisements.\n */\nexport interface AgenticParticipantMetadata extends ParticipantMetadata {\n    /** Display name for this participant */\n    name: string;\n    /** Participant type (e.g., \"panel\", \"worker\", \"agent\") */\n    type: string;\n    /**\n     * Unique handle for @-mentions (e.g., \"claude\", \"codex\", \"user\").\n     * Must be unique within the channel. Conflicts cause connection errors.\n     */\n    handle: string;\n    /** Methods this participant provides (auto-populated from ConnectOptions.methods) */\n    methods?: MethodAdvertisement[];\n    /** Tool roles this participant provides (for conflict detection) */\n    toolRoles?: Partial<Record<ToolGroup, ToolRoleDeclaration>>;\n}\n/**\n * Method advertisement in participant metadata.\n * Describes a method that can be invoked on this participant.\n */\nexport interface MethodAdvertisement {\n    /** Method name (unique within this provider) */\n    name: string;\n    /** Human-readable description */\n    description?: string;\n    /** JSON Schema for method arguments */\n    parameters: JsonSchema;\n    /** JSON Schema for return value */\n    returns?: JsonSchema;\n    /** Whether this method can stream partial results */\n    streaming?: boolean;\n    /** Suggested timeout in milliseconds */\n    timeout?: number;\n    /** Whether to show this method in participant menu UI */\n    menu?: boolean;\n}\n/**\n * Error codes for agentic operations.\n */\nexport type AgenticErrorCode = \"method-not-found\" | \"provider-not-found\" | \"provider-offline\" | \"execution-error\" | \"timeout\" | \"cancelled\" | \"validation-error\" | \"connection-error\" | \"handle-conflict\";\n/**\n * Error class for agentic messaging operations.\n * Includes a machine-readable error code for programmatic handling.\n */\nexport declare class AgenticError extends Error {\n    readonly code: AgenticErrorCode;\n    readonly cause?: unknown | undefined;\n    constructor(message: string, code: AgenticErrorCode, cause?: unknown | undefined);\n}\n/**\n * Error thrown when message validation fails.\n * Includes direction (send/receive) and validation details.\n */\nexport declare class ValidationError extends Error {\n    readonly direction: \"send\" | \"receive\";\n    readonly details?: unknown | undefined;\n    constructor(message: string, direction: \"send\" | \"receive\", details?: unknown | undefined);\n}\n/**\n * Union type for all incoming message types.\n */\nexport type IncomingMessage = IncomingNewMessage | IncomingUpdateMessage | IncomingErrorMessage;\n/**\n * Execution pause event with discriminant type field.\n */\nexport interface IncomingExecutionPauseEvent {\n    type: \"execution-pause\";\n    /** Message ID being paused */\n    messageId: string;\n    /** Current pause status */\n    status: PauseStatus;\n    /** Optional reason for the pause */\n    reason?: string;\n    /** Message kind */\n    kind: \"replay\" | \"persisted\" | \"ephemeral\";\n    /** ID of the sender */\n    senderId: string;\n    /** Timestamp in milliseconds */\n    ts: number;\n    /** Server-assigned ID for checkpointing */\n    pubsubId?: number;\n    /** Sender metadata snapshot (if available) */\n    senderMetadata?: {\n        name?: string;\n        type?: string;\n        handle?: string;\n    };\n}\n/**\n * Union type for all incoming event types (messages, method calls, method results, presence).\n * Use the `type` field to discriminate between event types.\n */\nexport type IncomingEvent = IncomingNewMessage | IncomingUpdateMessage | IncomingErrorMessage | IncomingMethodCallEvent | IncomingMethodResultEvent | IncomingPresenceEventWithType | IncomingExecutionPauseEvent | IncomingToolRoleRequestEvent | IncomingToolRoleResponseEvent | IncomingToolRoleHandoffEvent;\n/**\n * Method call event with discriminant type field.\n */\nexport interface IncomingMethodCallEvent extends IncomingMethodCall {\n    type: \"method-call\";\n}\n/**\n * Method result event with discriminant type field.\n */\nexport interface IncomingMethodResultEvent extends IncomingMethodResult {\n    type: \"method-result\";\n}\n/**\n * Presence event with discriminant type field.\n */\nexport interface IncomingPresenceEventWithType extends IncomingPresenceEvent {\n    type: \"presence\";\n}\n/**\n * Tool role request event - participant wants to take over a tool group.\n */\nexport interface IncomingToolRoleRequestEvent {\n    type: \"tool-role-request\";\n    kind: \"replay\" | \"persisted\" | \"ephemeral\";\n    senderId: string;\n    ts: number;\n    pubsubId?: number;\n    senderMetadata?: {\n        name?: string;\n        type?: string;\n        handle?: string;\n    };\n    /** Tool group being requested */\n    group: ToolGroup;\n    /** ID of the requester */\n    requesterId: string;\n    /** Type of the requester (used for auto-accept logic) */\n    requesterType: string;\n}\n/**\n * Tool role response event - current provider responds to request.\n */\nexport interface IncomingToolRoleResponseEvent {\n    type: \"tool-role-response\";\n    kind: \"replay\" | \"persisted\" | \"ephemeral\";\n    senderId: string;\n    ts: number;\n    pubsubId?: number;\n    senderMetadata?: {\n        name?: string;\n        type?: string;\n        handle?: string;\n    };\n    /** Tool group being responded to */\n    group: ToolGroup;\n    /** Whether the handoff was accepted */\n    accepted: boolean;\n    /** ID of the new provider (if accepted) */\n    handoffTo?: string;\n}\n/**\n * Tool role handoff event - announces completion of handoff.\n */\nexport interface IncomingToolRoleHandoffEvent {\n    type: \"tool-role-handoff\";\n    kind: \"replay\" | \"persisted\" | \"ephemeral\";\n    senderId: string;\n    ts: number;\n    pubsubId?: number;\n    senderMetadata?: {\n        name?: string;\n        type?: string;\n        handle?: string;\n    };\n    /** Tool group being handed off */\n    group: ToolGroup;\n    /** Previous provider ID */\n    from: string;\n    /** New provider ID */\n    to: string;\n}\n/**\n * Options for filtering events in the events() iterator.\n */\nexport interface EventFilterOptions {\n    /**\n     * Only yield message events where `at` includes this client's ID, or `at` is undefined (broadcast).\n     * When false/undefined, all events are yielded regardless of `at`.\n     * Note: Non-message events (method-call, method-result, presence) are always yielded.\n     */\n    targetedOnly?: boolean;\n    /**\n     * When targetedOnly is true, also yield non-targeted messages if this client\n     * is the only non-panel participant in the channel.\n     * Useful for agents that should respond when they're the sole responder.\n     */\n    respondWhenSolo?: boolean;\n    /**\n     * Callback invoked for events that are filtered out.\n     * Useful for logging or debugging filtered events.\n     */\n    onFiltered?: (event: IncomingEvent) => void;\n}\n/**\n * Base properties shared by all incoming messages.\n */\nexport interface IncomingBase {\n    /** Message kind: replay (historical), persisted (new + saved), or ephemeral */\n    kind: \"replay\" | \"persisted\" | \"ephemeral\";\n    /** ID of the sender */\n    senderId: string;\n    /** Timestamp in milliseconds */\n    ts: number;\n    /** Binary attachment (optional) */\n    attachment?: Uint8Array;\n    /** Server-assigned ID for checkpointing */\n    pubsubId?: number;\n    /** Sender metadata snapshot (if available) */\n    senderMetadata?: {\n        name?: string;\n        type?: string;\n        handle?: string;\n    };\n}\n/**\n * A new message in the conversation.\n */\nexport interface IncomingNewMessage extends IncomingBase {\n    type: \"message\";\n    /** Unique message ID */\n    id: string;\n    /** Message content */\n    content: string;\n    /** ID of message being replied to */\n    replyTo?: string;\n    /** MIME type for attachment */\n    contentType?: string;\n    /** IDs of intended recipients (empty/undefined = broadcast to all) */\n    at?: string[];\n}\n/**\n * An update to an existing message (for streaming).\n */\nexport interface IncomingUpdateMessage extends IncomingBase {\n    type: \"update-message\";\n    /** ID of the message being updated */\n    id: string;\n    /** Content to append (if any) */\n    content?: string;\n    /** Whether the message is now complete */\n    complete?: boolean;\n    /** MIME type for attachment */\n    contentType?: string;\n}\n/**\n * An error marker for a message.\n */\nexport interface IncomingErrorMessage extends IncomingBase {\n    type: \"error\";\n    /** ID of the message that errored */\n    id: string;\n    /** Error message */\n    error: string;\n    /** Machine-readable error code */\n    code?: string;\n}\n/**\n * Presence event actions.\n */\nexport type PresenceAction = \"join\" | \"leave\" | \"update\";\n/**\n * An incoming presence event (join/leave/update).\n * These events are persisted and replayed to reconstruct participant history.\n */\nexport interface IncomingPresenceEvent {\n    /** Message kind */\n    kind: \"replay\" | \"persisted\" | \"ephemeral\";\n    /** ID of the participant */\n    senderId: string;\n    /** Timestamp */\n    ts: number;\n    /** Server-assigned ID for checkpointing */\n    pubsubId?: number;\n    /** Sender metadata snapshot (if available) */\n    senderMetadata?: {\n        name?: string;\n        type?: string;\n        handle?: string;\n    };\n    /** The action */\n    action: PresenceAction;\n    /** Participant metadata at the time of the event */\n    metadata: ParticipantMetadata;\n}\n/**\n * An incoming method call (for method providers).\n */\nexport interface IncomingMethodCall {\n    /** Message kind */\n    kind: \"replay\" | \"persisted\" | \"ephemeral\";\n    /** ID of the caller */\n    senderId: string;\n    /** Timestamp */\n    ts: number;\n    /** Server-assigned ID for checkpointing */\n    pubsubId?: number;\n    /** Sender metadata snapshot (if available) */\n    senderMetadata?: {\n        name?: string;\n        type?: string;\n        handle?: string;\n    };\n    /** Unique call ID for correlation */\n    callId: string;\n    /** Name of the method being called */\n    methodName: string;\n    /** Target provider ID (this client) */\n    providerId: string;\n    /** Method arguments */\n    args: unknown;\n}\n/**\n * An incoming method result chunk.\n */\nexport interface IncomingMethodResult {\n    /** Message kind */\n    kind: \"replay\" | \"persisted\" | \"ephemeral\";\n    /** ID of the sender */\n    senderId: string;\n    /** Timestamp */\n    ts: number;\n    /** Server-assigned ID for checkpointing */\n    pubsubId?: number;\n    /** Sender metadata snapshot (if available) */\n    senderMetadata?: {\n        name?: string;\n        type?: string;\n        handle?: string;\n    };\n    /** Call ID for correlation */\n    callId: string;\n    /** Result content */\n    content?: unknown;\n    /** MIME type for attachment */\n    contentType?: string;\n    /** Whether this is the final chunk */\n    complete: boolean;\n    /** Whether this chunk represents an error */\n    isError: boolean;\n    /** Progress percentage (0-100) */\n    progress?: number;\n    /** Binary attachment (optional) */\n    attachment?: Uint8Array;\n}\n/**\n * Aggregated replay event base.\n */\nexport interface AggregatedEventBase {\n    pubsubId: number;\n    senderId: string;\n    senderName?: string;\n    senderType?: string;\n    senderHandle?: string;\n    ts: number;\n}\nexport interface AggregatedMessage extends AggregatedEventBase {\n    type: \"message\";\n    id: string;\n    content: string;\n    complete: boolean;\n    incomplete: boolean;\n    replyTo?: string;\n}\nexport interface AggregatedMethodCall extends AggregatedEventBase {\n    type: \"method-call\";\n    callId: string;\n    methodName: string;\n    providerId: string;\n    providerName?: string;\n    args: unknown;\n}\nexport interface AggregatedMethodResult extends AggregatedEventBase {\n    type: \"method-result\";\n    callId: string;\n    methodName?: string;\n    status: \"success\" | \"error\" | \"incomplete\";\n    content?: unknown;\n    errorMessage?: string;\n}\nexport type AggregatedEvent = AggregatedMessage | AggregatedMethodCall | AggregatedMethodResult;\nexport interface FormatOptions {\n    maxChars?: number;\n    format?: \"yaml\" | \"markdown\";\n    includeMethodArgs?: boolean;\n    includeMethodResults?: boolean;\n    maxMethodResultChars?: number;\n}\nexport interface MissedContext {\n    count: number;\n    formatted: string;\n    lastPubsubId: number;\n    wasElided: boolean;\n    events: AggregatedEvent[];\n}\n/**\n * Final value from a method call.\n */\nexport interface MethodResultValue {\n    /** Result content (JSON-serializable) */\n    content: unknown;\n    /** Binary attachment */\n    attachment?: Uint8Array;\n    /** MIME type for attachment */\n    contentType?: string;\n}\n/**\n * A chunk from a streaming method result.\n */\nexport interface MethodResultChunk extends MethodResultValue {\n    /** Whether this is the final chunk */\n    complete: boolean;\n    /** Whether this chunk represents an error */\n    isError: boolean;\n    /** Progress percentage (0-100) */\n    progress?: number;\n}\n/**\n * Handle for an in-flight method call.\n * Provides access to the result, streaming chunks, and cancellation.\n */\nexport interface MethodCallHandle {\n    /** Unique call ID */\n    readonly callId: string;\n    /** Promise that resolves with the final result */\n    readonly result: Promise<MethodResultValue>;\n    /** Async iterator for streaming chunks */\n    readonly stream: AsyncIterable<MethodResultChunk>;\n    /** Cancel the method call */\n    cancel(): Promise<void>;\n    /** Whether the call has completed */\n    readonly complete: boolean;\n    /** Whether the call resulted in an error */\n    readonly isError: boolean;\n}\n/**\n * A discovered method from the roster.\n * Contains all information needed to invoke the method.\n */\nexport interface DiscoveredMethod {\n    /** Provider's client ID */\n    providerId: string;\n    /** Provider's display name */\n    providerName: string;\n    /** Method name */\n    name: string;\n    /** Method description */\n    description?: string;\n    /** JSON Schema for arguments */\n    parameters: JsonSchema;\n    /** JSON Schema for return value */\n    returns?: JsonSchema;\n    /** Whether method supports streaming */\n    streaming: boolean;\n    /** Suggested timeout in ms */\n    timeout?: number;\n    /** Whether this method should only appear in menus, not be used as an AI tool */\n    menu?: boolean;\n}\n/**\n * Context provided to method execute functions.\n * Includes utilities for streaming results, progress, and cancellation.\n */\nexport interface MethodExecutionContext {\n    /** Unique call ID */\n    callId: string;\n    /** Caller's client ID */\n    callerId: string;\n    /** Abort signal (aborted when caller cancels) */\n    signal: AbortSignal;\n    /** Stream a partial result */\n    stream(content: unknown): Promise<void>;\n    /** Stream a partial result with binary attachment */\n    streamWithAttachment(content: unknown, attachment: Uint8Array, options?: {\n        contentType?: string;\n    }): Promise<void>;\n    /** Create a final result with binary attachment */\n    resultWithAttachment<T>(content: T, attachment: Uint8Array, options?: {\n        contentType?: string;\n    }): MethodResultWithAttachment<T>;\n    /** Report progress (0-100) */\n    progress(percent: number): Promise<void>;\n}\n/**\n * A method result with an attached binary payload.\n * Returned from context.resultWithAttachment().\n */\nexport interface MethodResultWithAttachment<T> {\n    content: T;\n    attachment: Uint8Array;\n    contentType?: string;\n}\n/**\n * Definition for a method this client provides.\n * Methods are registered at connection time via ConnectOptions.methods.\n */\nexport interface MethodDefinition<TArgs extends z.ZodTypeAny = z.ZodTypeAny, TResult = unknown> {\n    /** Human-readable description */\n    description?: string;\n    /** Zod schema for argument validation */\n    parameters: TArgs;\n    /** Zod schema for result validation (optional) */\n    returns?: z.ZodTypeAny;\n    /** Whether this method streams partial results */\n    streaming?: boolean;\n    /** Suggested timeout in milliseconds */\n    timeout?: number;\n    /** Whether to show this method in participant menu UI */\n    menu?: boolean;\n    /** Execute the method. Automatically called when method is invoked. */\n    execute: (args: z.infer<TArgs>, context: MethodExecutionContext) => Promise<TResult>;\n}\n/**\n * Options for connecting to an agentic messaging channel.\n */\nexport interface ConnectOptions<T extends AgenticParticipantMetadata = AgenticParticipantMetadata> {\n    /** Pubsub server URL */\n    serverUrl: string;\n    /** Authentication token */\n    token: string;\n    /** Channel name to connect to */\n    channel: string;\n    /** Unique handle for @-mentions */\n    handle: string;\n    /** Display name */\n    name: string;\n    /** Participant type */\n    type: string;\n    /** Additional metadata (optional) */\n    extraMetadata?: Record<string, unknown>;\n    /** Context ID for session persistence (for channel creators; joiners get it from server) */\n    contextId?: string;\n    /** Methods this participant provides. Automatically executed when called. */\n    methods?: Record<string, MethodDefinition>;\n    /** Enable auto-reconnection. Pass true for defaults, or a config object. */\n    reconnect?: boolean | {\n        delayMs?: number;\n        maxDelayMs?: number;\n        maxAttempts?: number;\n    };\n    /** Replay behavior: collect (default), stream, or skip */\n    replayMode?: \"collect\" | \"stream\" | \"skip\";\n    /** This client's ID (for skipOwnMessages filtering) */\n    clientId?: string;\n    /** Skip messages sent by this client (echo suppression) */\n    skipOwnMessages?: boolean;\n}\nexport interface SendResult {\n    /** UUID for message correlation */\n    messageId: string;\n    /** Server-assigned ID for checkpointing */\n    pubsubId: number | undefined;\n}\nexport interface EventStreamOptions extends EventFilterOptions {\n    includeReplay?: boolean;\n    includeEphemeral?: boolean;\n}\nexport type EventStreamItem = IncomingEvent | AggregatedEvent;\nexport interface ConversationMessage {\n    role: \"user\" | \"assistant\";\n    content: string;\n}\n/**\n * Agentic messaging client.\n * Provides messaging, tool discovery, and tool invocation APIs.\n */\nexport interface AgenticClient<T extends AgenticParticipantMetadata = AgenticParticipantMetadata> {\n    readonly handle: string;\n    readonly clientId: string | null;\n    /** Whether session persistence is enabled and operational */\n    readonly sessionEnabled: boolean;\n    readonly sessionKey: string | undefined;\n    readonly checkpoint: number | undefined;\n    readonly sdkSessionId: string | undefined;\n    readonly status: \"active\" | \"interrupted\" | undefined;\n    readonly missedMessages: AggregatedEvent[];\n    formatMissedContext(options?: FormatOptions): MissedContext;\n    getMissedByType<K extends AggregatedEvent[\"type\"]>(type: K): Extract<AggregatedEvent, {\n        type: K;\n    }>[];\n    events(options?: EventStreamOptions): AsyncIterableIterator<EventStreamItem>;\n    commitCheckpoint(pubsubId: number): Promise<void>;\n    updateSdkSession(sessionId: string): Promise<void>;\n    clearSdkSession(): Promise<void>;\n    send(content: string, options?: {\n        replyTo?: string;\n        persist?: boolean;\n        attachment?: Uint8Array;\n        contentType?: string;\n        /** IDs of intended recipients (omit for broadcast to all) */\n        at?: string[];\n        /** Resolve @handle mentions to participant IDs */\n        resolveHandles?: boolean;\n    }): Promise<SendResult>;\n    update(id: string, content: string, options?: {\n        complete?: boolean;\n        persist?: boolean;\n        attachment?: Uint8Array;\n        contentType?: string;\n    }): Promise<number | undefined>;\n    complete(id: string): Promise<number | undefined>;\n    error(id: string, error: string, code?: string): Promise<number | undefined>;\n    getConversationHistory(): ConversationMessage[];\n    updateSettings(settings: Record<string, unknown>): Promise<void>;\n    getSettings<T = Record<string, unknown>>(): Promise<T | null>;\n    discoverMethodDefs(): DiscoveredMethod[];\n    discoverMethodDefsFrom(providerId: string): DiscoveredMethod[];\n    callMethod(providerId: string, methodName: string, args: unknown, options?: {\n        signal?: AbortSignal;\n        validateArgs?: z.ZodTypeAny;\n        timeoutMs?: number;\n    }): MethodCallHandle;\n    readonly roster: Record<string, Participant<T>>;\n    resolveHandles(handles: string[]): string[];\n    getParticipantByHandle(handle: string): string | undefined;\n    onRoster(handler: (roster: RosterUpdate<T>) => void): () => void;\n    /** Subscribe to tool role conflict events */\n    onToolRoleConflict(handler: (conflicts: ToolRoleConflict[]) => void): () => void;\n    /** Request to take over a tool group from current provider */\n    requestToolRole(group: ToolGroup): Promise<void>;\n    /** Respond to a tool role request (accept/reject handoff) */\n    respondToolRole(group: ToolGroup, accepted: boolean, handoffTo?: string): Promise<void>;\n    /** Announce completion of a tool role handoff */\n    announceToolRoleHandoff(group: ToolGroup, from: string, to: string): Promise<void>;\n    readonly connected: boolean;\n    readonly reconnecting: boolean;\n    close(): Promise<void>;\n    onError(handler: (error: Error) => void): () => void;\n    onDisconnect(handler: () => void): () => void;\n    onReconnect(handler: () => void): () => void;\n    readonly pubsub: PubSubClient<T>;\n    sendMethodResult(callId: string, content: unknown, options?: {\n        complete?: boolean;\n        isError?: boolean;\n        progress?: number;\n        attachment?: Uint8Array;\n        contentType?: string;\n    }): Promise<void>;\n}\n/**\n * Status of an execution pause.\n */\nexport type PauseStatus = \"paused\" | \"resumed\" | \"cancelled\";\n//# sourceMappingURL=types.d.ts.map",
      "worker-base.d.ts": "/**\n * Worker Base Utilities\n *\n * Shared utilities for LLM worker implementations (claude-code, codex, pubsub-chat).\n * Provides common patterns for permission prompts via feedback_form.\n */\nimport type { AgenticClient } from \"./types.js\";\nimport type { ChatParticipantMetadata } from \"./responder-utils.js\";\n/**\n * Options for permission prompts.\n */\nexport interface PermissionPromptOptions {\n    /** Reason for the permission request (shown to user) */\n    decisionReason?: string;\n    /** Abort signal to cancel the prompt */\n    signal?: AbortSignal;\n}\n/**\n * Show a permission prompt using feedback_form with the unified approval schema.\n * This is the pattern for tool approval in unrestricted mode (worker-side).\n *\n * Uses the same approvalHeader + toolPreview + buttonGroup pattern as restricted mode,\n * ensuring consistent UI regardless of where the approval check happens.\n *\n * @param client - Connected agentic client\n * @param panelId - ID of the panel participant to show the prompt\n * @param toolName - Name of the tool requesting permission\n * @param input - Tool input arguments\n * @param options - Prompt options\n * @returns Promise resolving to allow/deny decision\n *\n * @example\n * ```typescript\n * const { allow } = await showPermissionPrompt(\n *   client,\n *   panel.id,\n *   \"file_write\",\n *   { path: \"/etc/config\", content: \"...\" },\n *   { decisionReason: \"Auto-safe mode requires approval for write operations\" }\n * );\n * if (allow) {\n *   // Execute the tool\n * }\n * ```\n */\nexport declare function showPermissionPrompt(client: AgenticClient<ChatParticipantMetadata>, panelId: string, toolName: string, input: Record<string, unknown>, options?: PermissionPromptOptions): Promise<{\n    allow: boolean;\n}>;\n/**\n * Find the chat panel participant in the roster.\n *\n * @param client - Connected agentic client\n * @returns Panel participant or undefined if not found\n */\nexport declare function findPanelParticipant(client: AgenticClient<ChatParticipantMetadata>): {\n    id: string;\n    metadata: ChatParticipantMetadata;\n} | undefined;\n/**\n * Validate required methods for restricted mode and send warning if missing.\n *\n * @param client - Connected agentic client\n * @param log - Optional logging function\n * @returns Validation result with warningSent flag\n */\nexport declare function validateRestrictedMode(client: AgenticClient<ChatParticipantMetadata>, log?: (message: string) => void): Promise<{\n    ok: boolean;\n    missing: string[];\n    warningSent: boolean;\n}>;\n//# sourceMappingURL=worker-base.d.ts.map"
    },
    "subpaths": {
      "./broker": "broker-entry.d.ts",
      "./config": "config-entry.d.ts",
      "./session": "session-entry.d.ts"
    }
  },
  "@natstack/playwright-client": {
    "files": {
      "index.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { Browser } from '@natstack/playwright-core';\nexport type Options = {\n    headless?: boolean;\n};\nexport declare function connect(wsEndpoint: string, browserName: string, options: Options): Promise<Browser>;\n//# sourceMappingURL=index.d.ts.map",
      "webPlatform.d.ts": "export { webPlatform } from '@natstack/playwright-core';\n//# sourceMappingURL=webPlatform.d.ts.map"
    },
    "subpaths": {}
  },
  "@natstack/playwright-core": {
    "files": {
      "androidServerImpl.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { BrowserServer } from './client/browserType';\nimport type { LaunchAndroidServerOptions } from './client/types';\nexport declare class AndroidServerLauncherImpl {\n    launchServer(options?: LaunchAndroidServerOptions): Promise<BrowserServer>;\n}\n//# sourceMappingURL=androidServerImpl.d.ts.map",
      "browser-stubs/async_hooks.d.ts": "export declare class AsyncLocalStorage<T> {\n    private _value;\n    run<R>(store: T, callback: (...args: any[]) => R, ...args: any[]): R;\n    getStore(): T | undefined;\n    exit<R>(callback: (...args: any[]) => R, ...args: any[]): R;\n}\ndeclare const _default: {\n    AsyncLocalStorage: typeof AsyncLocalStorage;\n};\nexport default _default;\n//# sourceMappingURL=async_hooks.d.ts.map",
      "browser-stubs/child_process.d.ts": "declare const _default: {};\nexport default _default;\nexport declare const exec: () => never;\nexport declare const execSync: () => string;\nexport declare const spawn: () => never;\nexport declare const spawnSync: () => {\n    pid: number;\n};\n//# sourceMappingURL=child_process.d.ts.map",
      "browser-stubs/crypto.d.ts": "export declare function randomBytes(size: number): {\n    toString: (encoding?: string) => string;\n};\ndeclare const _default: {\n    randomBytes: typeof randomBytes;\n};\nexport default _default;\n//# sourceMappingURL=crypto.d.ts.map",
      "browser-stubs/dns.d.ts": "declare const _default: {};\nexport default _default;\nexport declare const lookup: () => never;\n//# sourceMappingURL=dns.d.ts.map",
      "browser-stubs/electron.d.ts": "declare const _default: {};\nexport default _default;\n//# sourceMappingURL=electron.d.ts.map",
      "browser-stubs/events.d.ts": "export declare class EventEmitter {\n    static defaultMaxListeners: number;\n    private _listeners;\n    private _maxListeners;\n    on(event: string | symbol, listener: (...args: any[]) => void): this;\n    addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n    once(event: string | symbol, listener: (...args: any[]) => void): this;\n    off(event: string | symbol, listener: (...args: any[]) => void): this;\n    removeListener(event: string | symbol, listener: (...args: any[]) => void): this;\n    removeAllListeners(event?: string | symbol): this;\n    emit(event: string | symbol, ...args: any[]): boolean;\n    setMaxListeners(n: number): this;\n    getMaxListeners(): number;\n    listenerCount(event: string | symbol): number;\n    listeners(event: string | symbol): ((...args: any[]) => void)[];\n}\nexport default EventEmitter;\n//# sourceMappingURL=events.d.ts.map",
      "browser-stubs/http.d.ts": "export declare class Agent {\n    constructor(_options?: any);\n    createConnection(_options: any, _callback?: any): any;\n    destroy(): void;\n}\ndeclare const _default: {\n    Agent: typeof Agent;\n};\nexport default _default;\nexport declare const request: () => never;\nexport declare const get: () => never;\n//# sourceMappingURL=http.d.ts.map",
      "browser-stubs/http2.d.ts": "declare const _default: {};\nexport default _default;\nexport declare const connect: () => never;\nexport declare const createServer: () => never;\n//# sourceMappingURL=http2.d.ts.map",
      "browser-stubs/https.d.ts": "export declare class Agent {\n    constructor(_options?: any);\n    createConnection(_options: any, _callback?: any): any;\n    destroy(): void;\n}\ndeclare const _default: {\n    Agent: typeof Agent;\n};\nexport default _default;\nexport declare const request: () => never;\nexport declare const get: () => never;\n//# sourceMappingURL=https.d.ts.map",
      "browser-stubs/net.d.ts": "declare const _default: {};\nexport default _default;\nexport declare const createConnection: () => never;\n//# sourceMappingURL=net.d.ts.map",
      "browser-stubs/os.d.ts": "export declare const platform: () => string;\nexport declare const tmpdir: () => string;\nexport declare const homedir: () => string;\ndeclare const _default: {\n    platform: () => string;\n    tmpdir: () => string;\n    homedir: () => string;\n};\nexport default _default;\n//# sourceMappingURL=os.d.ts.map",
      "browser-stubs/path.d.ts": "export declare const join: (...segments: string[]) => string;\nexport declare const dirname: (p: string) => string;\nexport declare const basename: (p: string) => string;\nexport declare const extname: (p: string) => string;\ndeclare const _default: {\n    join: (...segments: string[]) => string;\n    dirname: (p: string) => string;\n    basename: (p: string) => string;\n    extname: (p: string) => string;\n};\nexport default _default;\n//# sourceMappingURL=path.d.ts.map",
      "browser-stubs/readline.d.ts": "declare const _default: {};\nexport default _default;\nexport declare const createInterface: () => never;\n//# sourceMappingURL=readline.d.ts.map",
      "browser-stubs/stream.d.ts": "import { EventEmitter } from './events';\ndeclare class SimpleStream extends EventEmitter {\n    pipe(): this;\n}\nexport declare class Readable extends SimpleStream {\n}\nexport declare class Writable extends SimpleStream {\n    write(): boolean;\n    end(): void;\n}\nexport declare const pipeline: (..._args: any[]) => never;\ndeclare const _default: {\n    Readable: typeof Readable;\n    Writable: typeof Writable;\n    pipeline: (..._args: any[]) => never;\n};\nexport default _default;\n//# sourceMappingURL=stream.d.ts.map",
      "browser-stubs/tls.d.ts": "declare const _default: {};\nexport default _default;\nexport declare const connect: () => never;\n//# sourceMappingURL=tls.d.ts.map",
      "browser-stubs/url.d.ts": "export declare const URL: {\n    new (url: string | URL, base?: string | URL): URL;\n    prototype: URL;\n    canParse(url: string | URL, base?: string | URL): boolean;\n    createObjectURL(obj: Blob | MediaSource): string;\n    parse(url: string | URL, base?: string | URL): URL | null;\n    revokeObjectURL(url: string): void;\n};\nexport declare const URLSearchParams: {\n    new (init?: string[][] | Record<string, string> | string | URLSearchParams): URLSearchParams;\n    prototype: URLSearchParams;\n};\ndeclare const _default: {\n    URL: {\n        new (url: string | URL, base?: string | URL): URL;\n        prototype: URL;\n        canParse(url: string | URL, base?: string | URL): boolean;\n        createObjectURL(obj: Blob | MediaSource): string;\n        parse(url: string | URL, base?: string | URL): URL | null;\n        revokeObjectURL(url: string): void;\n    };\n    URLSearchParams: {\n        new (init?: string[][] | Record<string, string> | string | URLSearchParams): URLSearchParams;\n        prototype: URLSearchParams;\n    };\n};\nexport default _default;\n//# sourceMappingURL=url.d.ts.map",
      "browser-stubs/util.d.ts": "export declare const promisify: (fn: any) => (...args: any[]) => Promise<unknown>;\nexport declare const inspect: {\n    custom: symbol;\n};\ndeclare const _default: {\n    promisify: (fn: any) => (...args: any[]) => Promise<unknown>;\n    inspect: {\n        custom: symbol;\n    };\n};\nexport default _default;\n//# sourceMappingURL=util.d.ts.map",
      "browserServerImpl.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { BrowserServer, BrowserServerLauncher } from './client/browserType';\nimport type { LaunchServerOptions } from './client/types';\nexport declare class BrowserServerLauncherImpl implements BrowserServerLauncher {\n    private _browserName;\n    constructor(browserName: 'chromium' | 'firefox' | 'webkit');\n    launchServer(options?: LaunchServerOptions & {\n        _sharedBrowser?: boolean;\n        _userDataDir?: string;\n    }): Promise<BrowserServer>;\n}\n//# sourceMappingURL=browserServerImpl.d.ts.map",
      "cli/driver.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport declare function printApiJson(): void;\nexport declare function runDriver(): void;\nexport type RunServerOptions = {\n    port?: number;\n    host?: string;\n    path?: string;\n    extension?: boolean;\n    maxConnections?: number;\n    browserProxyMode?: 'client' | 'tether';\n    ownedByTetherClient?: boolean;\n};\nexport declare function runServer(options: RunServerOptions): Promise<void>;\nexport declare function launchBrowserServer(browserName: string, configFile?: string): Promise<void>;\n//# sourceMappingURL=driver.d.ts.map",
      "cli/program.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport { program } from '../utilsBundle';\n//# sourceMappingURL=program.d.ts.map",
      "cli/programWithTestStub.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport { program } from './program';\n//# sourceMappingURL=programWithTestStub.d.ts.map",
      "client/android.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { EventEmitter } from './eventEmitter';\nimport { BrowserContext } from './browserContext';\nimport { ChannelOwner } from './channelOwner';\nimport { TimeoutSettings } from './timeoutSettings';\nimport type { Page } from './page';\nimport type * as types from './types';\nimport type * as api from '../../types/types';\nimport type { AndroidServerLauncherImpl } from '../androidServerImpl';\nimport type * as channels from '@protocol/channels';\nimport type { Playwright } from './playwright';\ntype Direction = 'down' | 'up' | 'left' | 'right';\ntype SpeedOptions = {\n    speed?: number;\n};\nexport declare class Android extends ChannelOwner<channels.AndroidChannel> implements api.Android {\n    _playwright: Playwright;\n    readonly _timeoutSettings: TimeoutSettings;\n    _serverLauncher?: AndroidServerLauncherImpl;\n    static from(android: channels.AndroidChannel): Android;\n    constructor(parent: ChannelOwner, type: string, guid: string, initializer: channels.AndroidInitializer);\n    setDefaultTimeout(timeout: number): void;\n    devices(options?: {\n        port?: number;\n    }): Promise<AndroidDevice[]>;\n    launchServer(options?: types.LaunchServerOptions): Promise<api.BrowserServer>;\n    connect(wsEndpoint: string, options?: Parameters<api.Android['connect']>[1]): Promise<api.AndroidDevice>;\n}\nexport declare class AndroidDevice extends ChannelOwner<channels.AndroidDeviceChannel> implements api.AndroidDevice {\n    readonly _timeoutSettings: TimeoutSettings;\n    private _webViews;\n    private _android;\n    _shouldCloseConnectionOnClose: boolean;\n    static from(androidDevice: channels.AndroidDeviceChannel): AndroidDevice;\n    input: AndroidInput;\n    constructor(parent: ChannelOwner, type: string, guid: string, initializer: channels.AndroidDeviceInitializer);\n    private _onWebViewAdded;\n    private _onWebViewRemoved;\n    setDefaultTimeout(timeout: number): void;\n    serial(): string;\n    model(): string;\n    webViews(): AndroidWebView[];\n    webView(selector: {\n        pkg?: string;\n        socketName?: string;\n    }, options?: types.TimeoutOptions): Promise<AndroidWebView>;\n    wait(selector: api.AndroidSelector, options?: {\n        state?: 'gone';\n    } & types.TimeoutOptions): Promise<void>;\n    fill(selector: api.AndroidSelector, text: string, options?: types.TimeoutOptions): Promise<void>;\n    press(selector: api.AndroidSelector, key: api.AndroidKey, options?: types.TimeoutOptions): Promise<void>;\n    tap(selector: api.AndroidSelector, options?: {\n        duration?: number;\n    } & types.TimeoutOptions): Promise<void>;\n    drag(selector: api.AndroidSelector, dest: types.Point, options?: SpeedOptions & types.TimeoutOptions): Promise<void>;\n    fling(selector: api.AndroidSelector, direction: Direction, options?: SpeedOptions & types.TimeoutOptions): Promise<void>;\n    longTap(selector: api.AndroidSelector, options?: types.TimeoutOptions): Promise<void>;\n    pinchClose(selector: api.AndroidSelector, percent: number, options?: SpeedOptions & types.TimeoutOptions): Promise<void>;\n    pinchOpen(selector: api.AndroidSelector, percent: number, options?: SpeedOptions & types.TimeoutOptions): Promise<void>;\n    scroll(selector: api.AndroidSelector, direction: Direction, percent: number, options?: SpeedOptions & types.TimeoutOptions): Promise<void>;\n    swipe(selector: api.AndroidSelector, direction: Direction, percent: number, options?: SpeedOptions & types.TimeoutOptions): Promise<void>;\n    info(selector: api.AndroidSelector): Promise<api.AndroidElementInfo>;\n    screenshot(options?: {\n        path?: string;\n    }): Promise<Buffer>;\n    [Symbol.asyncDispose](): Promise<void>;\n    close(): Promise<void>;\n    _didClose(): void;\n    shell(command: string): Promise<Buffer>;\n    open(command: string): Promise<AndroidSocket>;\n    installApk(file: string | Buffer, options?: {\n        args: string[];\n    }): Promise<void>;\n    push(file: string | Buffer, path: string, options?: {\n        mode: number;\n    }): Promise<void>;\n    launchBrowser(options?: types.BrowserContextOptions & {\n        pkg?: string;\n    }): Promise<BrowserContext>;\n    waitForEvent(event: string, optionsOrPredicate?: types.WaitForEventOptions): Promise<any>;\n}\nexport declare class AndroidSocket extends ChannelOwner<channels.AndroidSocketChannel> implements api.AndroidSocket {\n    static from(androidDevice: channels.AndroidSocketChannel): AndroidSocket;\n    constructor(parent: ChannelOwner, type: string, guid: string, initializer: channels.AndroidSocketInitializer);\n    write(data: Buffer): Promise<void>;\n    close(): Promise<void>;\n    [Symbol.asyncDispose](): Promise<void>;\n}\nexport declare class AndroidInput implements api.AndroidInput {\n    private _device;\n    constructor(device: AndroidDevice);\n    type(text: string): Promise<void>;\n    press(key: api.AndroidKey): Promise<void>;\n    tap(point: types.Point): Promise<void>;\n    swipe(from: types.Point, segments: types.Point[], steps: number): Promise<void>;\n    drag(from: types.Point, to: types.Point, steps: number): Promise<void>;\n}\nexport declare class AndroidWebView extends EventEmitter implements api.AndroidWebView {\n    private _device;\n    private _data;\n    private _pagePromise;\n    constructor(device: AndroidDevice, data: channels.AndroidWebView);\n    pid(): number;\n    pkg(): string;\n    _socketName(): string;\n    page(): Promise<Page>;\n    private _fetchPage;\n}\nexport {};\n//# sourceMappingURL=android.d.ts.map",
      "client/api.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport { Android, AndroidDevice, AndroidInput, AndroidSocket, AndroidWebView } from './android';\nexport { Browser } from './browser';\nexport { BrowserContext } from './browserContext';\nexport type { BrowserServer } from './browserType';\nexport { BrowserType } from './browserType';\nexport { Clock } from './clock';\nexport { ConsoleMessage } from './consoleMessage';\nexport { Coverage } from './coverage';\nexport { Dialog } from './dialog';\nexport { Download } from './download';\nexport { Electron, ElectronApplication } from './electron';\nexport { FrameLocator, Locator } from './locator';\nexport { ElementHandle } from './elementHandle';\nexport { FileChooser } from './fileChooser';\nexport type { Logger } from './types';\nexport { TimeoutError } from './errors';\nexport { Frame } from './frame';\nexport { Keyboard, Mouse, Touchscreen } from './input';\nexport { JSHandle } from './jsHandle';\nexport { Request, Response, Route, WebSocket, WebSocketRoute } from './network';\nexport { APIRequest, APIRequestContext, APIResponse } from './fetch';\nexport { Page } from './page';\nexport { Selectors } from './selectors';\nexport { Tracing } from './tracing';\nexport { Video } from './video';\nexport { Worker } from './worker';\nexport { CDPSession } from './cdpSession';\nexport { Playwright } from './playwright';\nexport { WebError } from './webError';\n//# sourceMappingURL=api.d.ts.map",
      "client/artifact.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ChannelOwner } from './channelOwner';\nimport type * as channels from '@protocol/channels';\nimport type { Readable } from 'stream';\nexport declare class Artifact extends ChannelOwner<channels.ArtifactChannel> {\n    static from(channel: channels.ArtifactChannel): Artifact;\n    pathAfterFinished(): Promise<string>;\n    saveAs(path: string): Promise<void>;\n    failure(): Promise<string | null>;\n    createReadStream(): Promise<Readable>;\n    readIntoBuffer(): Promise<Buffer>;\n    cancel(): Promise<void>;\n    delete(): Promise<void>;\n}\n//# sourceMappingURL=artifact.d.ts.map",
      "client/browser.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { BrowserContext } from './browserContext';\nimport { ChannelOwner } from './channelOwner';\nimport type { BrowserType } from './browserType';\nimport type { Page } from './page';\nimport type { BrowserContextOptions, LaunchOptions, Logger } from './types';\nimport type * as api from '../../types/types';\nimport type * as channels from '@protocol/channels';\nexport declare class Browser extends ChannelOwner<channels.BrowserChannel> implements api.Browser {\n    readonly _contexts: Set<BrowserContext>;\n    private _isConnected;\n    private _closedPromise;\n    _shouldCloseConnectionOnClose: boolean;\n    _browserType: BrowserType;\n    _options: LaunchOptions;\n    readonly _name: string;\n    private _path;\n    _closeReason: string | undefined;\n    static from(browser: channels.BrowserChannel): Browser;\n    constructor(parent: ChannelOwner, type: string, guid: string, initializer: channels.BrowserInitializer);\n    browserType(): BrowserType;\n    newContext(options?: BrowserContextOptions): Promise<BrowserContext>;\n    _newContextForReuse(options?: BrowserContextOptions): Promise<BrowserContext>;\n    _disconnectFromReusedContext(reason: string): Promise<void>;\n    _innerNewContext(options: BrowserContextOptions, forReuse: boolean): Promise<BrowserContext>;\n    _connectToBrowserType(browserType: BrowserType, browserOptions: LaunchOptions, logger: Logger | undefined): void;\n    private _didCreateContext;\n    private _setupBrowserContext;\n    contexts(): BrowserContext[];\n    version(): string;\n    newPage(options?: BrowserContextOptions): Promise<Page>;\n    isConnected(): boolean;\n    newBrowserCDPSession(): Promise<api.CDPSession>;\n    startTracing(page?: Page, options?: {\n        path?: string;\n        screenshots?: boolean;\n        categories?: string[];\n    }): Promise<void>;\n    stopTracing(): Promise<Buffer>;\n    [Symbol.asyncDispose](): Promise<void>;\n    close(options?: {\n        reason?: string;\n    }): Promise<void>;\n    _didClose(): void;\n}\n//# sourceMappingURL=browser.d.ts.map",
      "client/browserContext.d.ts": "/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Browser } from './browser';\nimport { ChannelOwner } from './channelOwner';\nimport { Clock } from './clock';\nimport { APIRequestContext } from './fetch';\nimport { Frame } from './frame';\nimport * as network from './network';\nimport { BindingCall, Page } from './page';\nimport { Tracing } from './tracing';\nimport { Worker } from './worker';\nimport { TimeoutSettings } from './timeoutSettings';\nimport type { BrowserContextOptions, Headers, StorageState, WaitForEventOptions } from './types';\nimport type * as structs from '../../types/structs';\nimport type * as api from '../../types/types';\nimport type { URLMatch } from '../utils/isomorphic/urlMatch';\nimport type { Platform } from './platform';\nimport type * as channels from '@protocol/channels';\nimport type * as actions from '@recorder/actions';\ninterface RecorderEventSink {\n    actionAdded?(page: Page, actionInContext: actions.ActionInContext, code: string): void;\n    actionUpdated?(page: Page, actionInContext: actions.ActionInContext, code: string): void;\n    signalAdded?(page: Page, signal: actions.SignalInContext): void;\n}\nexport declare class BrowserContext extends ChannelOwner<channels.BrowserContextChannel> implements api.BrowserContext {\n    _pages: Set<Page>;\n    _routes: network.RouteHandler[];\n    _webSocketRoutes: network.WebSocketRouteHandler[];\n    _browser: Browser | null;\n    readonly _bindings: Map<string, (source: structs.BindingSource, ...args: any[]) => any>;\n    _timeoutSettings: TimeoutSettings;\n    _ownerPage: Page | undefined;\n    _forReuse: boolean;\n    private _closedPromise;\n    readonly _options: channels.BrowserNewContextParams;\n    readonly request: APIRequestContext;\n    readonly tracing: Tracing;\n    readonly clock: Clock;\n    readonly _serviceWorkers: Set<Worker>;\n    private _harRecorders;\n    _closingStatus: 'none' | 'closing' | 'closed';\n    private _closeReason;\n    private _harRouters;\n    private _onRecorderEventSink;\n    static from(context: channels.BrowserContextChannel): BrowserContext;\n    static fromNullable(context: channels.BrowserContextChannel | null): BrowserContext | null;\n    constructor(parent: ChannelOwner, type: string, guid: string, initializer: channels.BrowserContextInitializer);\n    _initializeHarFromOptions(recordHar: BrowserContextOptions['recordHar']): Promise<void>;\n    private _onPage;\n    private _onRequest;\n    private _onResponse;\n    private _onRequestFailed;\n    private _onRequestFinished;\n    _onRoute(route: network.Route): Promise<void>;\n    _onWebSocketRoute(webSocketRoute: network.WebSocketRoute): Promise<void>;\n    _onBinding(bindingCall: BindingCall): Promise<void>;\n    private _serviceWorkerScope;\n    setDefaultNavigationTimeout(timeout: number | undefined): void;\n    setDefaultTimeout(timeout: number | undefined): void;\n    browser(): Browser | null;\n    pages(): Page[];\n    newPage(): Promise<Page>;\n    cookies(urls?: string | string[]): Promise<network.NetworkCookie[]>;\n    addCookies(cookies: network.SetNetworkCookieParam[]): Promise<void>;\n    clearCookies(options?: network.ClearNetworkCookieOptions): Promise<void>;\n    grantPermissions(permissions: string[], options?: {\n        origin?: string;\n    }): Promise<void>;\n    clearPermissions(): Promise<void>;\n    setGeolocation(geolocation: {\n        longitude: number;\n        latitude: number;\n        accuracy?: number;\n    } | null): Promise<void>;\n    setExtraHTTPHeaders(headers: Headers): Promise<void>;\n    setOffline(offline: boolean): Promise<void>;\n    setHTTPCredentials(httpCredentials: {\n        username: string;\n        password: string;\n    } | null): Promise<void>;\n    addInitScript(script: Function | string | {\n        path?: string;\n        content?: string;\n    }, arg?: any): Promise<void>;\n    exposeBinding(name: string, callback: (source: structs.BindingSource, ...args: any[]) => any, options?: {\n        handle?: boolean;\n    }): Promise<void>;\n    exposeFunction(name: string, callback: Function): Promise<void>;\n    route(url: URLMatch, handler: network.RouteHandlerCallback, options?: {\n        times?: number;\n    }): Promise<void>;\n    routeWebSocket(url: URLMatch, handler: network.WebSocketRouteHandlerCallback): Promise<void>;\n    _recordIntoHAR(har: string, page: Page | null, options?: {\n        url?: string | RegExp;\n        updateContent?: 'attach' | 'embed' | 'omit';\n        updateMode?: 'minimal' | 'full';\n    }): Promise<void>;\n    routeFromHAR(har: string, options?: {\n        url?: string | RegExp;\n        notFound?: 'abort' | 'fallback';\n        update?: boolean;\n        updateContent?: 'attach' | 'embed';\n        updateMode?: 'minimal' | 'full';\n    }): Promise<void>;\n    private _disposeHarRouters;\n    unrouteAll(options?: {\n        behavior?: 'wait' | 'ignoreErrors' | 'default';\n    }): Promise<void>;\n    unroute(url: URLMatch, handler?: network.RouteHandlerCallback): Promise<void>;\n    private _unrouteInternal;\n    private _updateInterceptionPatterns;\n    private _updateWebSocketInterceptionPatterns;\n    _effectiveCloseReason(): string | undefined;\n    waitForEvent(event: string, optionsOrPredicate?: WaitForEventOptions): Promise<any>;\n    storageState(options?: {\n        path?: string;\n        indexedDB?: boolean;\n    }): Promise<StorageState>;\n    backgroundPages(): Page[];\n    serviceWorkers(): Worker[];\n    newCDPSession(page: Page | Frame): Promise<api.CDPSession>;\n    _onClose(): void;\n    [Symbol.asyncDispose](): Promise<void>;\n    close(options?: {\n        reason?: string;\n    }): Promise<void>;\n    _enableRecorder(params: channels.BrowserContextEnableRecorderParams, eventSink?: RecorderEventSink): Promise<void>;\n    _disableRecorder(): Promise<void>;\n}\nexport declare function prepareBrowserContextParams(platform: Platform, options: BrowserContextOptions): Promise<channels.BrowserNewContextParams>;\nexport declare function toClientCertificatesProtocol(platform: Platform, certs?: BrowserContextOptions['clientCertificates']): Promise<channels.PlaywrightNewRequestParams['clientCertificates']>;\nexport {};\n//# sourceMappingURL=browserContext.d.ts.map",
      "client/browserContextImpl.d.ts": "/**\n * BrowserContextImpl - CDP-direct BrowserContext implementation\n * Simplified for single-session use case\n */\nimport type { BrowserImpl } from './browserImpl';\nimport type { PageImpl } from './pageImpl';\n/**\n * CDP-direct BrowserContext implementation\n * Manages pages within a browsing context\n */\nexport declare class BrowserContextImpl {\n    private _browser;\n    private _contextId?;\n    private _pages;\n    constructor(browser: BrowserImpl, contextId?: string);\n    /**\n     * Get all pages in this context\n     */\n    pages(): PageImpl[];\n    /**\n     * Add a page to this context (internal)\n     */\n    _addPage(page: PageImpl): void;\n    /**\n     * Remove a page from this context (internal)\n     */\n    _removePage(page: PageImpl): void;\n    /**\n     * Create a new page in this context\n     */\n    newPage(): Promise<PageImpl>;\n    /**\n     * Close this browser context\n     */\n    close(): Promise<void>;\n    /**\n     * Get the browser that owns this context\n     */\n    browser(): BrowserImpl;\n    /**\n     * Get the context ID\n     */\n    _getContextId(): string | undefined;\n}\n//# sourceMappingURL=browserContextImpl.d.ts.map",
      "client/browserImpl.d.ts": "/**\n * BrowserImpl - CDP-direct Browser implementation\n * Provides Playwright Browser API using direct CDP calls instead of RPC\n */\nimport { CDPAdapter } from './cdpAdapter';\nimport { PageImpl } from './pageImpl';\nimport { BrowserContextImpl } from './browserContextImpl';\nimport { EventEmitter } from './eventEmitter';\nimport { CRConnection } from '../server/chromium/crConnection';\nimport type { BrowserWebSocketTransportOptions } from '../server/browserTransport';\nexport interface BrowserConnectOptions {\n    transportOptions?: BrowserWebSocketTransportOptions;\n    /**\n     * When true, treats the CDP endpoint as an Electron webview where the root\n     * session IS the page (no Target.getTargets/attachToTarget needed).\n     * Default: true (optimized for natstack browser panels)\n     */\n    isElectronWebview?: boolean;\n}\n/**\n * CDP-direct Browser implementation\n * Maintains Playwright Browser API while using direct CDP protocol\n */\nexport declare class BrowserImpl {\n    private _connection;\n    private _adapter;\n    private _version;\n    private _defaultContext;\n    private _contexts;\n    private _pages;\n    private _closed;\n    private _eventEmitter;\n    private constructor();\n    /**\n     * Connect to a Chrome instance via CDP WebSocket\n     * Main entry point for CDP-direct usage\n     */\n    static connect(wsEndpoint: string, options?: BrowserConnectOptions): Promise<BrowserImpl>;\n    /**\n     * Attach to a target and create a PageImpl\n     */\n    _attachToTarget(targetId: string): Promise<PageImpl>;\n    /**\n     * Get browser version string\n     */\n    version(): string;\n    /**\n     * Get the default browser context\n     */\n    defaultContext(): BrowserContextImpl;\n    /**\n     * Get all browser contexts\n     */\n    contexts(): BrowserContextImpl[];\n    /**\n     * Create a new browser context\n     */\n    newContext(): Promise<BrowserContextImpl>;\n    /**\n     * Create a new page in the default context\n     */\n    newPage(): Promise<PageImpl>;\n    /**\n     * Check if browser is connected\n     */\n    isConnected(): boolean;\n    /**\n     * Close the browser connection\n     */\n    close(): Promise<void>;\n    /**\n     * Get the CDP connection\n     */\n    _getConnection(): CRConnection;\n    /**\n     * Get the CDP adapter\n     */\n    _getAdapter(): CDPAdapter;\n    /**\n     * Get the event emitter\n     */\n    _getEventEmitter(): EventEmitter;\n}\n//# sourceMappingURL=browserImpl.d.ts.map",
      "client/browserType.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Browser } from './browser';\nimport { BrowserContext } from './browserContext';\nimport { ChannelOwner } from './channelOwner';\nimport type { Playwright } from './playwright';\nimport type { ConnectOptions, LaunchOptions, LaunchPersistentContextOptions, LaunchServerOptions } from './types';\nimport type * as api from '../../types/types';\nimport type * as channels from '@protocol/channels';\nimport type { ChildProcess } from 'child_process';\nexport interface BrowserServerLauncher {\n    launchServer(options?: LaunchServerOptions): Promise<api.BrowserServer>;\n}\nexport interface BrowserServer extends api.BrowserServer {\n    process(): ChildProcess;\n    wsEndpoint(): string;\n    close(): Promise<void>;\n    kill(): Promise<void>;\n}\nexport declare class BrowserType extends ChannelOwner<channels.BrowserTypeChannel> implements api.BrowserType {\n    _serverLauncher?: BrowserServerLauncher;\n    _contexts: Set<BrowserContext>;\n    _playwright: Playwright;\n    static from(browserType: channels.BrowserTypeChannel): BrowserType;\n    executablePath(): string;\n    name(): string;\n    launch(options?: LaunchOptions): Promise<Browser>;\n    launchServer(options?: LaunchServerOptions): Promise<api.BrowserServer>;\n    launchPersistentContext(userDataDir: string, options?: LaunchPersistentContextOptions): Promise<BrowserContext>;\n    connect(options: api.ConnectOptions & {\n        wsEndpoint: string;\n    }): Promise<Browser>;\n    connect(wsEndpoint: string, options?: api.ConnectOptions): Promise<Browser>;\n    _connect(params: ConnectOptions): Promise<Browser>;\n    connectOverCDP(options: api.ConnectOverCDPOptions & {\n        wsEndpoint?: string;\n    }): Promise<api.Browser>;\n    connectOverCDP(endpointURL: string, options?: api.ConnectOverCDPOptions): Promise<api.Browser>;\n    _connectOverCDP(endpointURL: string, params?: api.ConnectOverCDPOptions): Promise<Browser>;\n}\n//# sourceMappingURL=browserType.d.ts.map",
      "client/cdpAdapter.d.ts": "/**\n * CDP Adapter - bridges Playwright API to direct CDP calls\n * Replaces ChannelOwner RPC pattern for browser-based CDP client\n */\nimport { InjectedScriptLoader } from './injectedScriptLoader';\nimport type { CRSession } from '../server/chromium/crConnection';\nimport type { Protocol } from '../server/chromium/protocol';\nexport interface EvaluateOptions {\n    expression: string;\n    returnByValue?: boolean;\n    awaitPromise?: boolean;\n    args?: any[];\n}\nexport interface EvaluateResult<T = any> {\n    result?: {\n        type: string;\n        value?: T;\n        objectId?: string;\n        description?: string;\n    };\n    exceptionDetails?: Protocol.Runtime.ExceptionDetails;\n}\nexport declare class CDPAdapter {\n    private session;\n    private injectedScriptLoader;\n    constructor(session: CRSession);\n    /**\n     * Evaluate JavaScript expression in the page context\n     */\n    evaluate<T = any>(options: EvaluateOptions): Promise<T>;\n    /**\n     * Evaluate expression with a specific argument\n     */\n    evaluateWithArg<T = any>(expression: string, arg: any): Promise<T>;\n    /**\n     * Get the injected script loader\n     */\n    getInjectedScriptLoader(): InjectedScriptLoader;\n    /**\n     * Enable required CDP domains for browser-level session\n     * Note: Input domain is page-level only, enabled per-page in PageImpl\n     */\n    enableDomains(): Promise<void>;\n    /**\n     * Get the current execution context ID\n     */\n    getContextId(): Promise<number>;\n    /**\n     * Get the root document element\n     */\n    getDocumentElement(): Promise<string>;\n    /**\n     * Query selector and get node ID\n     */\n    querySelector(selector: string): Promise<string | null>;\n    /**\n     * Get the backing object ID for a node ID\n     */\n    getObjectIdForNode(nodeId: number): Promise<string | null>;\n    /**\n     * Release a remote object reference\n     */\n    releaseObject(objectId: string): Promise<void>;\n    /**\n     * Get the CDP session\n     */\n    getSession(): CRSession;\n}\n//# sourceMappingURL=cdpAdapter.d.ts.map",
      "client/cdpSession.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ChannelOwner } from './channelOwner';\nimport type * as api from '../../types/types';\nimport type { Protocol } from '../server/chromium/protocol';\nimport type * as channels from '@protocol/channels';\nexport declare class CDPSession extends ChannelOwner<channels.CDPSessionChannel> implements api.CDPSession {\n    static from(cdpSession: channels.CDPSessionChannel): CDPSession;\n    constructor(parent: ChannelOwner, type: string, guid: string, initializer: channels.CDPSessionInitializer);\n    send<T extends keyof Protocol.CommandParameters>(method: T, params?: Protocol.CommandParameters[T]): Promise<Protocol.CommandReturnValues[T]>;\n    detach(): Promise<any>;\n}\n//# sourceMappingURL=cdpSession.d.ts.map",
      "client/channelOwner.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { EventEmitter } from './eventEmitter';\nimport type { ClientInstrumentation } from './clientInstrumentation';\nimport type { Connection } from './connection';\nimport type { Logger } from './types';\nimport type * as channels from '@protocol/channels';\ntype Listener = (...args: any[]) => void;\nexport declare abstract class ChannelOwner<T extends channels.Channel = channels.Channel> extends EventEmitter {\n    readonly _connection: Connection;\n    private _parent;\n    private _objects;\n    readonly _type: string;\n    readonly _guid: string;\n    readonly _channel: T;\n    readonly _initializer: channels.InitializerTraits<T>;\n    _logger: Logger | undefined;\n    readonly _instrumentation: ClientInstrumentation;\n    private _eventToSubscriptionMapping;\n    _wasCollected: boolean;\n    constructor(parent: ChannelOwner | Connection, type: string, guid: string, initializer: channels.InitializerTraits<T>);\n    _setEventToSubscriptionMapping(mapping: Map<string, string>): void;\n    private _updateSubscription;\n    on(event: string | symbol, listener: Listener): this;\n    addListener(event: string | symbol, listener: Listener): this;\n    prependListener(event: string | symbol, listener: Listener): this;\n    off(event: string | symbol, listener: Listener): this;\n    removeListener(event: string | symbol, listener: Listener): this;\n    _adopt(child: ChannelOwner<any>): void;\n    _dispose(reason: 'gc' | undefined): void;\n    _debugScopeState(): any;\n    private _validatorToWireContext;\n    private _createChannel;\n    _wrapApiCall<R>(func: (apiZone: ApiZone) => Promise<R>, options?: {\n        internal?: boolean;\n        title?: string;\n    }): Promise<R>;\n    private toJSON;\n}\ntype ApiZone = {\n    apiName: string;\n    frames: channels.StackFrame[];\n    title?: string;\n    internal?: boolean;\n    reported: boolean;\n    userData: any;\n    stepId?: string;\n    error?: Error;\n};\nexport {};\n//# sourceMappingURL=channelOwner.d.ts.map",
      "client/clientHelper.d.ts": "/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { Platform } from './platform';\nexport declare function envObjectToArray(env: NodeJS.ProcessEnv): {\n    name: string;\n    value: string;\n}[];\nexport declare function evaluationScript(platform: Platform, fun: Function | string | {\n    path?: string;\n    content?: string;\n}, arg?: any, addSourceUrl?: boolean): Promise<string>;\nexport declare function addSourceUrlToScript(source: string, path: string): string;\n//# sourceMappingURL=clientHelper.d.ts.map",
      "client/clientInstrumentation.d.ts": "/**\n * Copyright (c) Microsoft Corporation. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { BrowserContext } from './browserContext';\nimport type { APIRequestContext } from './fetch';\nimport type { StackFrame } from '@protocol/channels';\nexport interface ApiCallData {\n    apiName: string;\n    title?: string;\n    frames: StackFrame[];\n    userData: any;\n    stepId?: string;\n    error?: Error;\n}\nexport interface ClientInstrumentation {\n    addListener(listener: ClientInstrumentationListener): void;\n    removeListener(listener: ClientInstrumentationListener): void;\n    removeAllListeners(): void;\n    onApiCallBegin(apiCall: ApiCallData, channel: {\n        type: string;\n        method: string;\n        params?: Record<string, any>;\n    }): void;\n    onApiCallEnd(apiCall: ApiCallData): void;\n    onWillPause(options: {\n        keepTestTimeout: boolean;\n    }): void;\n    runAfterCreateBrowserContext(context: BrowserContext): Promise<void>;\n    runAfterCreateRequestContext(context: APIRequestContext): Promise<void>;\n    runBeforeCloseBrowserContext(context: BrowserContext): Promise<void>;\n    runBeforeCloseRequestContext(context: APIRequestContext): Promise<void>;\n}\nexport interface ClientInstrumentationListener {\n    onApiCallBegin?(apiCall: ApiCallData, channel: {\n        type: string;\n        method: string;\n        params?: Record<string, any>;\n    }): void;\n    onApiCallEnd?(apiCall: ApiCallData): void;\n    onWillPause?(options: {\n        keepTestTimeout: boolean;\n    }): void;\n    runAfterCreateBrowserContext?(context: BrowserContext): Promise<void>;\n    runAfterCreateRequestContext?(context: APIRequestContext): Promise<void>;\n    runBeforeCloseBrowserContext?(context: BrowserContext): Promise<void>;\n    runBeforeCloseRequestContext?(context: APIRequestContext): Promise<void>;\n}\nexport declare function createInstrumentation(): ClientInstrumentation;\n//# sourceMappingURL=clientInstrumentation.d.ts.map",
      "client/clientStackTrace.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { Platform } from './platform';\nimport type { StackFrame } from '@isomorphic/stackTrace';\nexport declare function captureLibraryStackTrace(platform: Platform): {\n    frames: StackFrame[];\n    apiName: string;\n};\n//# sourceMappingURL=clientStackTrace.d.ts.map",
      "client/clock.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { BrowserContext } from './browserContext';\nimport type * as api from '../../types/types';\nexport declare class Clock implements api.Clock {\n    private _browserContext;\n    constructor(browserContext: BrowserContext);\n    install(options?: {\n        time?: number | string | Date;\n    }): Promise<void>;\n    fastForward(ticks: number | string): Promise<void>;\n    pauseAt(time: number | string | Date): Promise<void>;\n    resume(): Promise<void>;\n    runFor(ticks: number | string): Promise<void>;\n    setFixedTime(time: string | number | Date): Promise<void>;\n    setSystemTime(time: string | number | Date): Promise<void>;\n}\n//# sourceMappingURL=clock.d.ts.map",
      "client/connection.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { EventEmitter } from './eventEmitter';\nimport { ChannelOwner } from './channelOwner';\nimport { LocalUtils } from './localUtils';\nimport { Playwright } from './playwright';\nimport type { ClientInstrumentation } from './clientInstrumentation';\nimport type { HeadersArray } from './types';\nimport type { Platform } from './platform';\nimport type * as channels from '@protocol/channels';\nexport declare class Connection extends EventEmitter {\n    readonly _objects: Map<string, ChannelOwner<channels.Channel>>;\n    onmessage: (message: object) => void;\n    private _lastId;\n    private _callbacks;\n    private _rootObject;\n    private _closedError;\n    private _isRemote;\n    private _localUtils?;\n    private _rawBuffers;\n    toImpl: ((client: ChannelOwner | Connection) => any) | undefined;\n    private _tracingCount;\n    readonly _instrumentation: ClientInstrumentation;\n    readonly headers: HeadersArray;\n    constructor(platform: Platform, localUtils?: LocalUtils, instrumentation?: ClientInstrumentation, headers?: HeadersArray);\n    markAsRemote(): void;\n    isRemote(): boolean;\n    useRawBuffers(): void;\n    rawBuffers(): boolean;\n    localUtils(): LocalUtils | undefined;\n    initializePlaywright(): Promise<Playwright>;\n    getObjectWithKnownName(guid: string): any;\n    setIsTracing(isTracing: boolean): void;\n    sendMessageToServer(object: ChannelOwner, method: string, params: any, options: {\n        apiName?: string;\n        title?: string;\n        internal?: boolean;\n        frames?: channels.StackFrame[];\n        stepId?: string;\n    }): Promise<any>;\n    private _validatorFromWireContext;\n    dispatch(message: object): void;\n    close(cause?: string): void;\n    private _tChannelImplFromWire;\n    private _createRemoteObject;\n}\n//# sourceMappingURL=connection.d.ts.map",
      "client/consoleMessage.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { JSHandle } from './jsHandle';\nimport type * as api from '../../types/types';\nimport type { Platform } from './platform';\nimport type * as channels from '@protocol/channels';\nimport type { Page } from './page';\nimport type { Worker } from './worker';\ntype ConsoleMessageLocation = channels.BrowserContextConsoleEvent['location'];\nexport declare class ConsoleMessage implements api.ConsoleMessage {\n    private _page;\n    private _worker;\n    private _event;\n    constructor(platform: Platform, event: channels.BrowserContextConsoleEvent | channels.ElectronApplicationConsoleEvent, page: Page | null, worker: Worker | null);\n    worker(): Worker;\n    page(): Page;\n    type(): ReturnType<api.ConsoleMessage['type']>;\n    text(): string;\n    args(): JSHandle[];\n    location(): ConsoleMessageLocation;\n    private _inspect;\n}\nexport {};\n//# sourceMappingURL=consoleMessage.d.ts.map",
      "client/coverage.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type * as api from '../../types/types';\nimport type * as channels from '@protocol/channels';\nexport declare class Coverage implements api.Coverage {\n    private _channel;\n    constructor(channel: channels.PageChannel);\n    startJSCoverage(options?: channels.PageStartJSCoverageOptions): Promise<void>;\n    stopJSCoverage(): Promise<channels.PageStopJSCoverageResult['entries']>;\n    startCSSCoverage(options?: channels.PageStartCSSCoverageOptions): Promise<void>;\n    stopCSSCoverage(): Promise<channels.PageStopCSSCoverageResult['entries']>;\n}\n//# sourceMappingURL=coverage.d.ts.map",
      "client/dialog.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ChannelOwner } from './channelOwner';\nimport { Page } from './page';\nimport type * as api from '../../types/types';\nimport type * as channels from '@protocol/channels';\nexport declare class Dialog extends ChannelOwner<channels.DialogChannel> implements api.Dialog {\n    static from(dialog: channels.DialogChannel): Dialog;\n    private _page;\n    constructor(parent: ChannelOwner, type: string, guid: string, initializer: channels.DialogInitializer);\n    page(): Page;\n    type(): string;\n    message(): string;\n    defaultValue(): string;\n    accept(promptText: string | undefined): Promise<void>;\n    dismiss(): Promise<void>;\n}\n//# sourceMappingURL=dialog.d.ts.map",
      "client/download.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { Artifact } from './artifact';\nimport type { Page } from './page';\nimport type * as api from '../../types/types';\nimport type { Readable } from 'stream';\nexport declare class Download implements api.Download {\n    private _page;\n    private _url;\n    private _suggestedFilename;\n    private _artifact;\n    constructor(page: Page, url: string, suggestedFilename: string, artifact: Artifact);\n    page(): Page;\n    url(): string;\n    suggestedFilename(): string;\n    path(): Promise<string>;\n    saveAs(path: string): Promise<void>;\n    failure(): Promise<string | null>;\n    createReadStream(): Promise<Readable>;\n    cancel(): Promise<void>;\n    delete(): Promise<void>;\n}\n//# sourceMappingURL=download.d.ts.map",
      "client/electron.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { BrowserContext } from './browserContext';\nimport { ChannelOwner } from './channelOwner';\nimport { JSHandle } from './jsHandle';\nimport type { Page } from './page';\nimport type { BrowserContextOptions, Headers, WaitForEventOptions } from './types';\nimport type * as structs from '../../types/structs';\nimport type * as api from '../../types/types';\nimport type * as channels from '@protocol/channels';\nimport type * as childProcess from 'child_process';\nimport type { BrowserWindow } from 'electron';\nimport type { Playwright } from './playwright';\ntype ElectronOptions = Omit<channels.ElectronLaunchOptions, 'env' | 'extraHTTPHeaders' | 'recordHar' | 'colorScheme' | 'acceptDownloads'> & {\n    env?: NodeJS.ProcessEnv;\n    extraHTTPHeaders?: Headers;\n    recordHar?: BrowserContextOptions['recordHar'];\n    colorScheme?: 'dark' | 'light' | 'no-preference' | null;\n    acceptDownloads?: boolean;\n    timeout?: number;\n};\ntype ElectronAppType = typeof import('electron');\nexport declare class Electron extends ChannelOwner<channels.ElectronChannel> implements api.Electron {\n    _playwright: Playwright;\n    static from(electron: channels.ElectronChannel): Electron;\n    constructor(parent: ChannelOwner, type: string, guid: string, initializer: channels.ElectronInitializer);\n    launch(options?: ElectronOptions): Promise<ElectronApplication>;\n}\nexport declare class ElectronApplication extends ChannelOwner<channels.ElectronApplicationChannel> implements api.ElectronApplication {\n    readonly _context: BrowserContext;\n    private _windows;\n    private _timeoutSettings;\n    static from(electronApplication: channels.ElectronApplicationChannel): ElectronApplication;\n    constructor(parent: ChannelOwner, type: string, guid: string, initializer: channels.ElectronApplicationInitializer);\n    process(): childProcess.ChildProcess;\n    _onPage(page: Page): void;\n    windows(): Page[];\n    firstWindow(options?: {\n        timeout?: number;\n    }): Promise<Page>;\n    context(): BrowserContext;\n    [Symbol.asyncDispose](): Promise<void>;\n    close(): Promise<void>;\n    waitForEvent(event: string, optionsOrPredicate?: WaitForEventOptions): Promise<any>;\n    browserWindow(page: Page): Promise<JSHandle<BrowserWindow>>;\n    evaluate<R, Arg>(pageFunction: structs.PageFunctionOn<ElectronAppType, Arg, R>, arg: Arg): Promise<R>;\n    evaluateHandle<R, Arg>(pageFunction: structs.PageFunctionOn<ElectronAppType, Arg, R>, arg: Arg): Promise<structs.SmartHandle<R>>;\n}\nexport {};\n//# sourceMappingURL=electron.d.ts.map",
      "client/elementHandle.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Frame } from './frame';\nimport { JSHandle } from './jsHandle';\nimport type { BrowserContext } from './browserContext';\nimport type { ChannelOwner } from './channelOwner';\nimport type { FilePayload, Rect, SelectOption, SelectOptionOptions, TimeoutOptions } from './types';\nimport type * as structs from '../../types/structs';\nimport type * as api from '../../types/types';\nimport type { Platform } from './platform';\nimport type * as channels from '@protocol/channels';\nexport declare class ElementHandle<T extends Node = Node> extends JSHandle<T> implements api.ElementHandle {\n    private _frame;\n    readonly _elementChannel: channels.ElementHandleChannel;\n    static from(handle: channels.ElementHandleChannel): ElementHandle;\n    static fromNullable(handle: channels.ElementHandleChannel | undefined): ElementHandle | null;\n    constructor(parent: ChannelOwner, type: string, guid: string, initializer: channels.JSHandleInitializer);\n    asElement(): T extends Node ? ElementHandle<T> : null;\n    ownerFrame(): Promise<Frame | null>;\n    contentFrame(): Promise<Frame | null>;\n    getAttribute(name: string): Promise<string | null>;\n    inputValue(): Promise<string>;\n    textContent(): Promise<string | null>;\n    innerText(): Promise<string>;\n    innerHTML(): Promise<string>;\n    isChecked(): Promise<boolean>;\n    isDisabled(): Promise<boolean>;\n    isEditable(): Promise<boolean>;\n    isEnabled(): Promise<boolean>;\n    isHidden(): Promise<boolean>;\n    isVisible(): Promise<boolean>;\n    dispatchEvent(type: string, eventInit?: Object): Promise<void>;\n    scrollIntoViewIfNeeded(options?: channels.ElementHandleScrollIntoViewIfNeededOptions & TimeoutOptions): Promise<void>;\n    hover(options?: channels.ElementHandleHoverOptions & TimeoutOptions): Promise<void>;\n    click(options?: channels.ElementHandleClickOptions & TimeoutOptions): Promise<void>;\n    dblclick(options?: channels.ElementHandleDblclickOptions & TimeoutOptions): Promise<void>;\n    tap(options?: channels.ElementHandleTapOptions & TimeoutOptions): Promise<void>;\n    selectOption(values: string | api.ElementHandle | SelectOption | string[] | api.ElementHandle[] | SelectOption[] | null, options?: SelectOptionOptions): Promise<string[]>;\n    fill(value: string, options?: channels.ElementHandleFillOptions & TimeoutOptions): Promise<void>;\n    selectText(options?: channels.ElementHandleSelectTextOptions & TimeoutOptions): Promise<void>;\n    setInputFiles(files: string | FilePayload | string[] | FilePayload[], options?: channels.ElementHandleSetInputFilesOptions & TimeoutOptions): Promise<void>;\n    focus(): Promise<void>;\n    type(text: string, options?: channels.ElementHandleTypeOptions & TimeoutOptions): Promise<void>;\n    press(key: string, options?: channels.ElementHandlePressOptions & TimeoutOptions): Promise<void>;\n    check(options?: channels.ElementHandleCheckOptions & TimeoutOptions): Promise<any>;\n    uncheck(options?: channels.ElementHandleUncheckOptions & TimeoutOptions): Promise<any>;\n    setChecked(checked: boolean, options?: channels.ElementHandleCheckOptions): Promise<void>;\n    boundingBox(): Promise<Rect | null>;\n    screenshot(options?: Omit<channels.ElementHandleScreenshotOptions, 'mask'> & TimeoutOptions & {\n        path?: string;\n        mask?: api.Locator[];\n    }): Promise<Buffer>;\n    $(selector: string): Promise<ElementHandle<SVGElement | HTMLElement> | null>;\n    $$(selector: string): Promise<ElementHandle<SVGElement | HTMLElement>[]>;\n    $eval<R, Arg>(selector: string, pageFunction: structs.PageFunctionOn<Element, Arg, R>, arg?: Arg): Promise<R>;\n    $$eval<R, Arg>(selector: string, pageFunction: structs.PageFunctionOn<Element[], Arg, R>, arg?: Arg): Promise<R>;\n    waitForElementState(state: 'visible' | 'hidden' | 'stable' | 'enabled' | 'disabled', options?: TimeoutOptions): Promise<void>;\n    waitForSelector(selector: string, options: channels.ElementHandleWaitForSelectorOptions & TimeoutOptions & {\n        state: 'attached' | 'visible';\n    }): Promise<ElementHandle<SVGElement | HTMLElement>>;\n    waitForSelector(selector: string, options?: channels.ElementHandleWaitForSelectorOptions & TimeoutOptions): Promise<ElementHandle<SVGElement | HTMLElement> | null>;\n}\nexport declare function convertSelectOptionValues(values: string | api.ElementHandle | SelectOption | string[] | api.ElementHandle[] | SelectOption[] | null): {\n    elements?: channels.ElementHandleChannel[];\n    options?: SelectOption[];\n};\ntype SetInputFilesFiles = Pick<channels.ElementHandleSetInputFilesParams, 'payloads' | 'localPaths' | 'localDirectory' | 'streams' | 'directoryStream'>;\nexport declare function convertInputFiles(platform: Platform, files: string | FilePayload | string[] | FilePayload[], context: BrowserContext): Promise<SetInputFilesFiles>;\nexport declare function determineScreenshotType(options: {\n    path?: string;\n    type?: 'png' | 'jpeg';\n}): 'png' | 'jpeg' | undefined;\nexport {};\n//# sourceMappingURL=elementHandle.d.ts.map",
      "client/errors.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { SerializedError } from '@protocol/channels';\nexport declare class TimeoutError extends Error {\n    constructor(message: string);\n}\nexport declare class TargetClosedError extends Error {\n    constructor(cause?: string);\n}\nexport declare function isTargetClosedError(error: Error): error is TargetClosedError;\nexport declare function serializeError(e: any): SerializedError;\nexport declare function parseError(error: SerializedError): Error;\n//# sourceMappingURL=errors.d.ts.map",
      "client/eventEmitter.d.ts": "/**\n * Copyright Joyent, Inc. and other Node contributors.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n * USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\nimport type { EventEmitter as EventEmitterType } from 'events';\nimport type { Platform } from './platform';\ntype EventType = string | symbol;\ntype Listener = (...args: any[]) => any;\nexport declare class EventEmitter implements EventEmitterType {\n    private _events;\n    private _eventsCount;\n    private _maxListeners;\n    readonly _pendingHandlers: Map<EventType, Set<Promise<void>>>;\n    private _rejectionHandler;\n    readonly _platform: Platform;\n    constructor(platform: Platform);\n    setMaxListeners(n: number): this;\n    getMaxListeners(): number;\n    emit(type: EventType, ...args: any[]): boolean;\n    private _callHandler;\n    addListener(type: EventType, listener: Listener): this;\n    on(type: EventType, listener: Listener): this;\n    private _addListener;\n    prependListener(type: EventType, listener: Listener): this;\n    once(type: EventType, listener: Listener): this;\n    prependOnceListener(type: EventType, listener: Listener): this;\n    removeListener(type: EventType, listener: Listener): this;\n    off(type: EventType, listener: Listener): this;\n    removeAllListeners(type?: EventType): this;\n    removeAllListeners(type: EventType | undefined, options: {\n        behavior?: 'wait' | 'ignoreErrors' | 'default';\n    }): Promise<void>;\n    private _removeAllListeners;\n    listeners(type: EventType): Listener[];\n    rawListeners(type: EventType): Listener[];\n    listenerCount(type: EventType): number;\n    eventNames(): Array<string | symbol>;\n    private _waitFor;\n    private _listeners;\n}\nexport {};\n//# sourceMappingURL=eventEmitter.d.ts.map",
      "client/events.d.ts": "/**\n * Copyright 2019 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport declare const Events: {\n    AndroidDevice: {\n        WebView: string;\n        Close: string;\n    };\n    AndroidSocket: {\n        Data: string;\n        Close: string;\n    };\n    AndroidWebView: {\n        Close: string;\n    };\n    Browser: {\n        Disconnected: string;\n    };\n    BrowserContext: {\n        Console: string;\n        Close: string;\n        Dialog: string;\n        Page: string;\n        WebError: string;\n        BackgroundPage: string;\n        ServiceWorker: string;\n        Request: string;\n        Response: string;\n        RequestFailed: string;\n        RequestFinished: string;\n    };\n    BrowserServer: {\n        Close: string;\n    };\n    Page: {\n        Close: string;\n        Crash: string;\n        Console: string;\n        Dialog: string;\n        Download: string;\n        FileChooser: string;\n        DOMContentLoaded: string;\n        PageError: string;\n        Request: string;\n        Response: string;\n        RequestFailed: string;\n        RequestFinished: string;\n        FrameAttached: string;\n        FrameDetached: string;\n        FrameNavigated: string;\n        Load: string;\n        Popup: string;\n        WebSocket: string;\n        Worker: string;\n    };\n    WebSocket: {\n        Close: string;\n        Error: string;\n        FrameReceived: string;\n        FrameSent: string;\n    };\n    Worker: {\n        Close: string;\n        Console: string;\n    };\n    ElectronApplication: {\n        Close: string;\n        Console: string;\n        Window: string;\n    };\n};\n//# sourceMappingURL=events.d.ts.map",
      "client/fetch.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ChannelOwner } from './channelOwner';\nimport { Tracing } from './tracing';\nimport { TimeoutSettings } from './timeoutSettings';\nimport type { Playwright } from './playwright';\nimport type { ClientCertificate, FilePayload, Headers, SetStorageState, StorageState, TimeoutOptions } from './types';\nimport type { Serializable } from '../../types/structs';\nimport type * as api from '../../types/types';\nimport type { HeadersArray } from '../utils/isomorphic/types';\nimport type * as channels from '@protocol/channels';\nimport type * as fs from 'fs';\nexport type FetchOptions = {\n    params?: {\n        [key: string]: string | number | boolean;\n    } | URLSearchParams | string;\n    method?: string;\n    headers?: Headers;\n    data?: string | Buffer | Serializable;\n    form?: {\n        [key: string]: string | number | boolean;\n    } | FormData;\n    multipart?: {\n        [key: string]: string | number | boolean | fs.ReadStream | FilePayload;\n    } | FormData;\n    timeout?: number;\n    failOnStatusCode?: boolean;\n    ignoreHTTPSErrors?: boolean;\n    maxRedirects?: number;\n    maxRetries?: number;\n};\ntype NewContextOptions = Omit<channels.PlaywrightNewRequestOptions, 'extraHTTPHeaders' | 'clientCertificates' | 'storageState' | 'tracesDir'> & {\n    extraHTTPHeaders?: Headers;\n    storageState?: string | SetStorageState;\n    clientCertificates?: ClientCertificate[];\n};\ntype RequestWithBodyOptions = Omit<FetchOptions, 'method'>;\nexport declare class APIRequest implements api.APIRequest {\n    private _playwright;\n    readonly _contexts: Set<APIRequestContext>;\n    constructor(playwright: Playwright);\n    newContext(options?: NewContextOptions & TimeoutOptions): Promise<APIRequestContext>;\n}\nexport declare class APIRequestContext extends ChannelOwner<channels.APIRequestContextChannel> implements api.APIRequestContext {\n    _request?: APIRequest;\n    readonly _tracing: Tracing;\n    private _closeReason;\n    _timeoutSettings: TimeoutSettings;\n    static from(channel: channels.APIRequestContextChannel): APIRequestContext;\n    constructor(parent: ChannelOwner, type: string, guid: string, initializer: channels.APIRequestContextInitializer);\n    [Symbol.asyncDispose](): Promise<void>;\n    dispose(options?: {\n        reason?: string;\n    }): Promise<void>;\n    delete(url: string, options?: RequestWithBodyOptions): Promise<APIResponse>;\n    head(url: string, options?: RequestWithBodyOptions): Promise<APIResponse>;\n    get(url: string, options?: RequestWithBodyOptions): Promise<APIResponse>;\n    patch(url: string, options?: RequestWithBodyOptions): Promise<APIResponse>;\n    post(url: string, options?: RequestWithBodyOptions): Promise<APIResponse>;\n    put(url: string, options?: RequestWithBodyOptions): Promise<APIResponse>;\n    fetch(urlOrRequest: string | api.Request, options?: FetchOptions): Promise<APIResponse>;\n    _innerFetch(options?: FetchOptions & {\n        url?: string;\n        request?: api.Request;\n    }): Promise<APIResponse>;\n    storageState(options?: {\n        path?: string;\n        indexedDB?: boolean;\n    }): Promise<StorageState>;\n}\nexport declare class APIResponse implements api.APIResponse {\n    private readonly _initializer;\n    private readonly _headers;\n    readonly _request: APIRequestContext;\n    constructor(context: APIRequestContext, initializer: channels.APIResponse);\n    ok(): boolean;\n    url(): string;\n    status(): number;\n    statusText(): string;\n    headers(): Headers;\n    headersArray(): HeadersArray;\n    body(): Promise<Buffer>;\n    text(): Promise<string>;\n    json(): Promise<object>;\n    [Symbol.asyncDispose](): Promise<void>;\n    dispose(): Promise<void>;\n    private _inspect;\n    _fetchUid(): string;\n    _fetchLog(): Promise<string[]>;\n}\nexport {};\n//# sourceMappingURL=fetch.d.ts.map",
      "client/fileChooser.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { ElementHandle } from './elementHandle';\nimport type { Page } from './page';\nimport type { FilePayload, TimeoutOptions } from './types';\nimport type * as api from '../../types/types';\nimport type * as channels from '@protocol/channels';\nexport declare class FileChooser implements api.FileChooser {\n    private _page;\n    private _elementHandle;\n    private _isMultiple;\n    constructor(page: Page, elementHandle: ElementHandle, isMultiple: boolean);\n    element(): ElementHandle;\n    isMultiple(): boolean;\n    page(): Page;\n    setFiles(files: string | FilePayload | string[] | FilePayload[], options?: channels.ElementHandleSetInputFilesOptions & TimeoutOptions): Promise<void>;\n}\n//# sourceMappingURL=fileChooser.d.ts.map",
      "client/fileUtils.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { Platform } from './platform';\nexport declare const fileUploadSizeLimit: number;\nexport declare function mkdirIfNeeded(platform: Platform, filePath: string): Promise<void>;\n//# sourceMappingURL=fileUtils.d.ts.map",
      "client/frame.d.ts": "/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { EventEmitter } from './eventEmitter';\nimport { ChannelOwner } from './channelOwner';\nimport { ElementHandle } from './elementHandle';\nimport { FrameLocator, Locator } from './locator';\nimport * as network from './network';\nimport type { LocatorOptions } from './locator';\nimport type { Page } from './page';\nimport type { FilePayload, LifecycleEvent, SelectOption, SelectOptionOptions, StrictOptions, TimeoutOptions, WaitForFunctionOptions } from './types';\nimport type * as structs from '../../types/structs';\nimport type * as api from '../../types/types';\nimport type { ByRoleOptions } from '../utils/isomorphic/locatorUtils';\nimport type { URLMatch } from '../utils/isomorphic/urlMatch';\nimport type * as channels from '@protocol/channels';\nexport type WaitForNavigationOptions = {\n    timeout?: number;\n    waitUntil?: LifecycleEvent;\n    url?: URLMatch;\n};\nexport declare class Frame extends ChannelOwner<channels.FrameChannel> implements api.Frame {\n    _eventEmitter: EventEmitter;\n    _loadStates: Set<LifecycleEvent>;\n    _parentFrame: Frame | null;\n    _url: string;\n    _name: string;\n    _detached: boolean;\n    _childFrames: Set<Frame>;\n    _page: Page | undefined;\n    static from(frame: channels.FrameChannel): Frame;\n    static fromNullable(frame: channels.FrameChannel | undefined): Frame | null;\n    constructor(parent: ChannelOwner, type: string, guid: string, initializer: channels.FrameInitializer);\n    page(): Page;\n    _timeout(options?: TimeoutOptions): number;\n    _navigationTimeout(options?: TimeoutOptions): number;\n    goto(url: string, options?: channels.FrameGotoOptions & TimeoutOptions): Promise<network.Response | null>;\n    private _setupNavigationWaiter;\n    waitForNavigation(options?: WaitForNavigationOptions): Promise<network.Response | null>;\n    waitForLoadState(state?: LifecycleEvent, options?: {\n        timeout?: number;\n    }): Promise<void>;\n    waitForURL(url: URLMatch, options?: {\n        waitUntil?: LifecycleEvent;\n        timeout?: number;\n    }): Promise<void>;\n    frameElement(): Promise<ElementHandle>;\n    evaluateHandle<R, Arg>(pageFunction: structs.PageFunction<Arg, R>, arg?: Arg): Promise<structs.SmartHandle<R>>;\n    evaluate<R, Arg>(pageFunction: structs.PageFunction<Arg, R>, arg?: Arg): Promise<R>;\n    _evaluateFunction(functionDeclaration: string): Promise<any>;\n    _evaluateExposeUtilityScript<R, Arg>(pageFunction: structs.PageFunction<Arg, R>, arg?: Arg): Promise<R>;\n    $(selector: string, options?: {\n        strict?: boolean;\n    }): Promise<ElementHandle<SVGElement | HTMLElement> | null>;\n    waitForSelector(selector: string, options: channels.FrameWaitForSelectorOptions & TimeoutOptions & {\n        state: 'attached' | 'visible';\n    }): Promise<ElementHandle<SVGElement | HTMLElement>>;\n    waitForSelector(selector: string, options?: channels.FrameWaitForSelectorOptions & TimeoutOptions): Promise<ElementHandle<SVGElement | HTMLElement> | null>;\n    dispatchEvent(selector: string, type: string, eventInit?: any, options?: channels.FrameDispatchEventOptions & TimeoutOptions): Promise<void>;\n    $eval<R, Arg>(selector: string, pageFunction: structs.PageFunctionOn<Element, Arg, R>, arg?: Arg): Promise<R>;\n    $$eval<R, Arg>(selector: string, pageFunction: structs.PageFunctionOn<Element[], Arg, R>, arg?: Arg): Promise<R>;\n    $$(selector: string): Promise<ElementHandle<SVGElement | HTMLElement>[]>;\n    _queryCount(selector: string, options?: {}): Promise<number>;\n    content(): Promise<string>;\n    setContent(html: string, options?: channels.FrameSetContentOptions & TimeoutOptions): Promise<void>;\n    name(): string;\n    url(): string;\n    parentFrame(): Frame | null;\n    childFrames(): Frame[];\n    isDetached(): boolean;\n    addScriptTag(options?: {\n        url?: string;\n        path?: string;\n        content?: string;\n        type?: string;\n    }): Promise<ElementHandle>;\n    addStyleTag(options?: {\n        url?: string;\n        path?: string;\n        content?: string;\n    }): Promise<ElementHandle>;\n    click(selector: string, options?: channels.FrameClickOptions & TimeoutOptions): Promise<any>;\n    dblclick(selector: string, options?: channels.FrameDblclickOptions & TimeoutOptions): Promise<any>;\n    dragAndDrop(source: string, target: string, options?: channels.FrameDragAndDropOptions & TimeoutOptions): Promise<any>;\n    tap(selector: string, options?: channels.FrameTapOptions & TimeoutOptions): Promise<any>;\n    fill(selector: string, value: string, options?: channels.FrameFillOptions & TimeoutOptions): Promise<any>;\n    _highlight(selector: string): Promise<any>;\n    locator(selector: string, options?: LocatorOptions): Locator;\n    getByTestId(testId: string | RegExp): Locator;\n    getByAltText(text: string | RegExp, options?: {\n        exact?: boolean;\n    }): Locator;\n    getByLabel(text: string | RegExp, options?: {\n        exact?: boolean;\n    }): Locator;\n    getByPlaceholder(text: string | RegExp, options?: {\n        exact?: boolean;\n    }): Locator;\n    getByText(text: string | RegExp, options?: {\n        exact?: boolean;\n    }): Locator;\n    getByTitle(text: string | RegExp, options?: {\n        exact?: boolean;\n    }): Locator;\n    getByRole(role: string, options?: ByRoleOptions): Locator;\n    frameLocator(selector: string): FrameLocator;\n    focus(selector: string, options?: channels.FrameFocusOptions & TimeoutOptions): Promise<void>;\n    textContent(selector: string, options?: channels.FrameTextContentOptions & TimeoutOptions): Promise<null | string>;\n    innerText(selector: string, options?: channels.FrameInnerTextOptions & TimeoutOptions): Promise<string>;\n    innerHTML(selector: string, options?: channels.FrameInnerHTMLOptions & TimeoutOptions): Promise<string>;\n    getAttribute(selector: string, name: string, options?: channels.FrameGetAttributeOptions & TimeoutOptions): Promise<string | null>;\n    inputValue(selector: string, options?: channels.FrameInputValueOptions & TimeoutOptions): Promise<string>;\n    isChecked(selector: string, options?: channels.FrameIsCheckedOptions & TimeoutOptions): Promise<boolean>;\n    isDisabled(selector: string, options?: channels.FrameIsDisabledOptions & TimeoutOptions): Promise<boolean>;\n    isEditable(selector: string, options?: channels.FrameIsEditableOptions & TimeoutOptions): Promise<boolean>;\n    isEnabled(selector: string, options?: channels.FrameIsEnabledOptions & TimeoutOptions): Promise<boolean>;\n    isHidden(selector: string, options?: channels.FrameIsHiddenOptions & TimeoutOptions): Promise<boolean>;\n    isVisible(selector: string, options?: channels.FrameIsVisibleOptions & TimeoutOptions): Promise<boolean>;\n    hover(selector: string, options?: channels.FrameHoverOptions & TimeoutOptions): Promise<void>;\n    selectOption(selector: string, values: string | api.ElementHandle | SelectOption | string[] | api.ElementHandle[] | SelectOption[] | null, options?: SelectOptionOptions & StrictOptions): Promise<string[]>;\n    setInputFiles(selector: string, files: string | FilePayload | string[] | FilePayload[], options?: channels.FrameSetInputFilesOptions & TimeoutOptions): Promise<void>;\n    type(selector: string, text: string, options?: channels.FrameTypeOptions & TimeoutOptions): Promise<void>;\n    press(selector: string, key: string, options?: channels.FramePressOptions & TimeoutOptions): Promise<void>;\n    check(selector: string, options?: channels.FrameCheckOptions & TimeoutOptions): Promise<void>;\n    uncheck(selector: string, options?: channels.FrameUncheckOptions & TimeoutOptions): Promise<void>;\n    setChecked(selector: string, checked: boolean, options?: channels.FrameCheckOptions): Promise<void>;\n    waitForTimeout(timeout: number): Promise<void>;\n    waitForFunction<R, Arg>(pageFunction: structs.PageFunction<Arg, R>, arg?: Arg, options?: WaitForFunctionOptions): Promise<structs.SmartHandle<R>>;\n    title(): Promise<string>;\n    _expect(expression: string, options: Omit<channels.FrameExpectParams, 'expression'>): Promise<{\n        matches: boolean;\n        received?: any;\n        log?: string[];\n        timedOut?: boolean;\n        errorMessage?: string;\n    }>;\n}\nexport declare function verifyLoadState(name: string, waitUntil: LifecycleEvent): LifecycleEvent;\n//# sourceMappingURL=frame.d.ts.map",
      "client/frameAdapter.d.ts": "/**\n * Frame Adapter - bridges Frame API to direct CDP calls\n * Provides core waiting and selector evaluation logic ported from server-side frames.ts\n */\nimport { CDPAdapter } from './cdpAdapter';\nimport type { CRSession } from '../server/chromium/crConnection';\nexport interface WaitForSelectorOptions {\n    timeout?: number;\n    state?: 'attached' | 'detached' | 'visible' | 'hidden';\n}\nexport interface QueryOptions {\n    strict?: boolean;\n}\n/**\n * Frame adapter that implements waiting and selector logic for direct CDP\n */\nexport declare class FrameAdapter {\n    private adapter;\n    private defaultTimeout;\n    private retryDelays;\n    constructor(session: CRSession);\n    /**\n     * Evaluate selector using InjectedScript\n     * Returns elements matching the selector\n     */\n    evaluateSelector(selector: string, options?: QueryOptions): Promise<any[]>;\n    /**\n     * Wait for selector with polling and timeout\n     * Implements core polling logic from server-side waitForSelector\n     */\n    waitForSelector(selector: string, options?: WaitForSelectorOptions): Promise<boolean>;\n    /**\n     * Query selector once (no polling)\n     */\n    querySelector(selector: string, options?: QueryOptions): Promise<boolean>;\n    /**\n     * Get the CDP adapter for direct access to lower-level operations\n     */\n    getAdapter(): CDPAdapter;\n    /**\n     * Set default timeout for operations\n     */\n    setDefaultTimeout(ms: number): void;\n}\n//# sourceMappingURL=frameAdapter.d.ts.map",
      "client/frameImpl.d.ts": "/**\n * FrameImpl - CDP-direct Frame implementation\n * Provides Playwright Frame API using FrameAdapter\n */\nimport { CDPAdapter } from './cdpAdapter';\nimport { WaitForSelectorOptions } from './frameAdapter';\nimport type { PageImpl } from './pageImpl';\n/**\n * CDP-direct Frame implementation\n * Wraps FrameAdapter and provides Playwright-compatible API\n */\nexport declare class FrameImpl {\n    private _page;\n    private _adapter;\n    private _cdpAdapter;\n    constructor(page: PageImpl, cdpAdapter: CDPAdapter);\n    /**\n     * Wait for selector with auto-waiting\n     */\n    waitForSelector(selector: string, options?: WaitForSelectorOptions): Promise<boolean>;\n    /**\n     * Query selector (no waiting)\n     */\n    querySelector(selector: string): Promise<boolean>;\n    /**\n     * Click an element\n     */\n    click(selector: string, options?: any): Promise<void>;\n    /**\n     * Fill an input element\n     */\n    fill(selector: string, value: string, options?: any): Promise<void>;\n    /**\n     * Type text into an element\n     */\n    type(selector: string, text: string, options?: any): Promise<void>;\n    /**\n     * Evaluate JavaScript in frame context\n     */\n    evaluate<T>(pageFunction: string | ((...args: any[]) => T), ...args: any[]): Promise<T>;\n    /**\n     * Get frame URL\n     */\n    url(): string;\n    /**\n     * Get the page that owns this frame\n     */\n    page(): PageImpl;\n    /**\n     * Set default timeout\n     */\n    setDefaultTimeout(timeout: number): void;\n}\n//# sourceMappingURL=frameImpl.d.ts.map",
      "client/harRouter.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { BrowserContext } from './browserContext';\nimport type { LocalUtils } from './localUtils';\nimport type { Page } from './page';\nimport type { URLMatch } from '../utils/isomorphic/urlMatch';\ntype HarNotFoundAction = 'abort' | 'fallback';\nexport declare class HarRouter {\n    private _localUtils;\n    private _harId;\n    private _notFoundAction;\n    private _options;\n    static create(localUtils: LocalUtils, file: string, notFoundAction: HarNotFoundAction, options: {\n        urlMatch?: URLMatch;\n    }): Promise<HarRouter>;\n    private constructor();\n    private _handle;\n    addContextRoute(context: BrowserContext): Promise<void>;\n    addPageRoute(page: Page): Promise<void>;\n    [Symbol.asyncDispose](): Promise<void>;\n    dispose(): void;\n}\nexport {};\n//# sourceMappingURL=harRouter.d.ts.map",
      "client/injectedScriptLoader.d.ts": "/**\n * InjectedScript Loader - manages loading and caching of InjectedScript in page context\n *\n * The InjectedScript needs to be evaluated once per execution context and cached,\n * then reused for all selector queries and element operations.\n */\nimport type { CDPAdapter } from './cdpAdapter';\nexport interface InjectedScriptAPI {\n    querySelector: (selector: any, root: Node, strict: boolean) => Element | undefined;\n    querySelectorAll: (selector: any, root: Node) => Element[];\n    utils: {\n        isElementVisible: (element: Element) => boolean;\n    };\n}\n/**\n * Manages InjectedScript lifecycle per CDP session\n */\nexport declare class InjectedScriptLoader {\n    private adapter;\n    private contextToScript;\n    private contextToModulePromise;\n    constructor(adapter: CDPAdapter);\n    /**\n     * Get or load InjectedScript for a given execution context\n     */\n    getInjectedScript(contextId: number): Promise<InjectedScriptAPI>;\n    /**\n     * Load InjectedScript for a context by evaluating the module\n     */\n    private loadInjectedScript;\n    /**\n     * Clear cached scripts (e.g., when context is destroyed)\n     */\n    clearContext(contextId: number): void;\n    /**\n     * Clear all cached scripts\n     */\n    clearAll(): void;\n}\n//# sourceMappingURL=injectedScriptLoader.d.ts.map",
      "client/input.d.ts": "/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { Page } from './page';\nimport type * as api from '../../types/types';\nimport type * as channels from '@protocol/channels';\nexport declare class Keyboard implements api.Keyboard {\n    private _page;\n    constructor(page: Page);\n    down(key: string): Promise<void>;\n    up(key: string): Promise<void>;\n    insertText(text: string): Promise<void>;\n    type(text: string, options?: channels.PageKeyboardTypeOptions): Promise<void>;\n    press(key: string, options?: channels.PageKeyboardPressOptions): Promise<void>;\n}\nexport declare class Mouse implements api.Mouse {\n    private _page;\n    constructor(page: Page);\n    move(x: number, y: number, options?: {\n        steps?: number;\n    }): Promise<void>;\n    down(options?: channels.PageMouseDownOptions): Promise<void>;\n    up(options?: channels.PageMouseUpOptions): Promise<void>;\n    click(x: number, y: number, options?: channels.PageMouseClickOptions): Promise<void>;\n    dblclick(x: number, y: number, options?: Omit<channels.PageMouseClickOptions, 'clickCount'>): Promise<void>;\n    wheel(deltaX: number, deltaY: number): Promise<void>;\n}\nexport declare class Touchscreen implements api.Touchscreen {\n    private _page;\n    constructor(page: Page);\n    tap(x: number, y: number): Promise<void>;\n}\n//# sourceMappingURL=input.d.ts.map",
      "client/jsHandle.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ChannelOwner } from './channelOwner';\nimport type * as structs from '../../types/structs';\nimport type * as api from '../../types/types';\nimport type * as channels from '@protocol/channels';\nexport declare class JSHandle<T = any> extends ChannelOwner<channels.JSHandleChannel> implements api.JSHandle {\n    private _preview;\n    static from(handle: channels.JSHandleChannel): JSHandle;\n    constructor(parent: ChannelOwner, type: string, guid: string, initializer: channels.JSHandleInitializer);\n    evaluate<R, Arg>(pageFunction: structs.PageFunctionOn<T, Arg, R>, arg?: Arg): Promise<R>;\n    _evaluateFunction(functionDeclaration: string): Promise<any>;\n    evaluateHandle<R, Arg>(pageFunction: structs.PageFunctionOn<T, Arg, R>, arg?: Arg): Promise<structs.SmartHandle<R>>;\n    getProperty(propertyName: string): Promise<JSHandle>;\n    getProperties(): Promise<Map<string, JSHandle>>;\n    jsonValue(): Promise<T>;\n    asElement(): T extends Node ? api.ElementHandle<T> : null;\n    [Symbol.asyncDispose](): Promise<void>;\n    dispose(): Promise<void>;\n    toString(): string;\n}\nexport declare function serializeArgument(arg: any): channels.SerializedArgument;\nexport declare function parseResult(value: channels.SerializedValue): any;\nexport declare function assertMaxArguments(count: number, max: number): asserts count;\n//# sourceMappingURL=jsHandle.d.ts.map",
      "client/jsonPipe.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ChannelOwner } from './channelOwner';\nimport type * as channels from '@protocol/channels';\nexport declare class JsonPipe extends ChannelOwner<channels.JsonPipeChannel> {\n    static from(jsonPipe: channels.JsonPipeChannel): JsonPipe;\n    constructor(parent: ChannelOwner, type: string, guid: string, initializer: channels.JsonPipeInitializer);\n    channel(): channels.JsonPipeChannel;\n}\n//# sourceMappingURL=jsonPipe.d.ts.map",
      "client/localUtils.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ChannelOwner } from './channelOwner';\nimport type { Size } from './types';\nimport type * as channels from '@protocol/channels';\ntype DeviceDescriptor = {\n    userAgent: string;\n    viewport: Size;\n    deviceScaleFactor: number;\n    isMobile: boolean;\n    hasTouch: boolean;\n    defaultBrowserType: 'chromium' | 'firefox' | 'webkit';\n};\ntype Devices = {\n    [name: string]: DeviceDescriptor;\n};\nexport declare class LocalUtils extends ChannelOwner<channels.LocalUtilsChannel> {\n    readonly devices: Devices;\n    constructor(parent: ChannelOwner, type: string, guid: string, initializer: channels.LocalUtilsInitializer);\n    zip(params: channels.LocalUtilsZipParams): Promise<void>;\n    harOpen(params: channels.LocalUtilsHarOpenParams): Promise<channels.LocalUtilsHarOpenResult>;\n    harLookup(params: channels.LocalUtilsHarLookupParams): Promise<channels.LocalUtilsHarLookupResult>;\n    harClose(params: channels.LocalUtilsHarCloseParams): Promise<void>;\n    harUnzip(params: channels.LocalUtilsHarUnzipParams): Promise<void>;\n    tracingStarted(params: channels.LocalUtilsTracingStartedParams): Promise<channels.LocalUtilsTracingStartedResult>;\n    traceDiscarded(params: channels.LocalUtilsTraceDiscardedParams): Promise<void>;\n    addStackToTracingNoReply(params: channels.LocalUtilsAddStackToTracingNoReplyParams): Promise<void>;\n}\nexport {};\n//# sourceMappingURL=localUtils.d.ts.map",
      "client/locator.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ElementHandle } from './elementHandle';\nimport type { Frame } from './frame';\nimport type { FilePayload, FrameExpectParams, Rect, SelectOption, SelectOptionOptions, TimeoutOptions } from './types';\nimport type * as structs from '../../types/structs';\nimport type * as api from '../../types/types';\nimport type { ByRoleOptions } from '../utils/isomorphic/locatorUtils';\nimport type * as channels from '@protocol/channels';\nexport type LocatorOptions = {\n    hasText?: string | RegExp;\n    hasNotText?: string | RegExp;\n    has?: Locator;\n    hasNot?: Locator;\n    visible?: boolean;\n};\nexport declare class Locator implements api.Locator {\n    _frame: Frame;\n    _selector: string;\n    constructor(frame: Frame, selector: string, options?: LocatorOptions);\n    private _withElement;\n    _equals(locator: Locator): boolean;\n    page(): import(\"./page\").Page;\n    boundingBox(options?: TimeoutOptions): Promise<Rect | null>;\n    check(options?: channels.ElementHandleCheckOptions & TimeoutOptions): Promise<void>;\n    click(options?: channels.ElementHandleClickOptions & TimeoutOptions): Promise<void>;\n    dblclick(options?: channels.ElementHandleDblclickOptions & TimeoutOptions): Promise<void>;\n    dispatchEvent(type: string, eventInit?: Object, options?: TimeoutOptions): Promise<void>;\n    dragTo(target: Locator, options?: channels.FrameDragAndDropOptions & TimeoutOptions): Promise<any>;\n    evaluate<R, Arg>(pageFunction: structs.PageFunctionOn<SVGElement | HTMLElement, Arg, R>, arg?: Arg, options?: TimeoutOptions): Promise<R>;\n    _evaluateFunction(functionDeclaration: string, options?: TimeoutOptions): Promise<any>;\n    evaluateAll<R, Arg>(pageFunction: structs.PageFunctionOn<Element[], Arg, R>, arg?: Arg): Promise<R>;\n    evaluateHandle<R, Arg>(pageFunction: structs.PageFunctionOn<any, Arg, R>, arg?: Arg, options?: TimeoutOptions): Promise<structs.SmartHandle<R>>;\n    fill(value: string, options?: channels.ElementHandleFillOptions & TimeoutOptions): Promise<void>;\n    clear(options?: channels.ElementHandleFillOptions): Promise<void>;\n    _highlight(): Promise<any>;\n    highlight(): Promise<any>;\n    locator(selectorOrLocator: string | Locator, options?: Omit<LocatorOptions, 'visible'>): Locator;\n    getByTestId(testId: string | RegExp): Locator;\n    getByAltText(text: string | RegExp, options?: {\n        exact?: boolean;\n    }): Locator;\n    getByLabel(text: string | RegExp, options?: {\n        exact?: boolean;\n    }): Locator;\n    getByPlaceholder(text: string | RegExp, options?: {\n        exact?: boolean;\n    }): Locator;\n    getByText(text: string | RegExp, options?: {\n        exact?: boolean;\n    }): Locator;\n    getByTitle(text: string | RegExp, options?: {\n        exact?: boolean;\n    }): Locator;\n    getByRole(role: string, options?: ByRoleOptions): Locator;\n    frameLocator(selector: string): FrameLocator;\n    filter(options?: LocatorOptions): Locator;\n    elementHandle(options?: TimeoutOptions): Promise<ElementHandle<SVGElement | HTMLElement>>;\n    elementHandles(): Promise<api.ElementHandle<SVGElement | HTMLElement>[]>;\n    contentFrame(): FrameLocator;\n    describe(description: string): Locator;\n    description(): string | null;\n    first(): Locator;\n    last(): Locator;\n    nth(index: number): Locator;\n    and(locator: Locator): Locator;\n    or(locator: Locator): Locator;\n    focus(options?: TimeoutOptions): Promise<void>;\n    blur(options?: TimeoutOptions): Promise<void>;\n    count(_options?: {}): Promise<number>;\n    _resolveSelector(): Promise<{\n        resolvedSelector: string;\n    }>;\n    getAttribute(name: string, options?: TimeoutOptions): Promise<string | null>;\n    hover(options?: channels.ElementHandleHoverOptions & TimeoutOptions): Promise<void>;\n    innerHTML(options?: TimeoutOptions): Promise<string>;\n    innerText(options?: TimeoutOptions): Promise<string>;\n    inputValue(options?: TimeoutOptions): Promise<string>;\n    isChecked(options?: TimeoutOptions): Promise<boolean>;\n    isDisabled(options?: TimeoutOptions): Promise<boolean>;\n    isEditable(options?: TimeoutOptions): Promise<boolean>;\n    isEnabled(options?: TimeoutOptions): Promise<boolean>;\n    isHidden(options?: TimeoutOptions): Promise<boolean>;\n    isVisible(options?: TimeoutOptions): Promise<boolean>;\n    press(key: string, options?: channels.ElementHandlePressOptions & TimeoutOptions): Promise<void>;\n    screenshot(options?: Omit<channels.ElementHandleScreenshotOptions, 'mask'> & TimeoutOptions & {\n        path?: string;\n        mask?: api.Locator[];\n    }): Promise<Buffer>;\n    ariaSnapshot(options?: TimeoutOptions): Promise<string>;\n    scrollIntoViewIfNeeded(options?: channels.ElementHandleScrollIntoViewIfNeededOptions & TimeoutOptions): Promise<void>;\n    selectOption(values: string | api.ElementHandle | SelectOption | string[] | api.ElementHandle[] | SelectOption[] | null, options?: SelectOptionOptions): Promise<string[]>;\n    selectText(options?: channels.ElementHandleSelectTextOptions & TimeoutOptions): Promise<void>;\n    setChecked(checked: boolean, options?: channels.ElementHandleCheckOptions & TimeoutOptions): Promise<void>;\n    setInputFiles(files: string | FilePayload | string[] | FilePayload[], options?: channels.ElementHandleSetInputFilesOptions & TimeoutOptions): Promise<void>;\n    tap(options?: channels.ElementHandleTapOptions & TimeoutOptions): Promise<void>;\n    textContent(options?: TimeoutOptions): Promise<string | null>;\n    type(text: string, options?: channels.ElementHandleTypeOptions & TimeoutOptions): Promise<void>;\n    pressSequentially(text: string, options?: channels.ElementHandleTypeOptions & TimeoutOptions): Promise<void>;\n    uncheck(options?: channels.ElementHandleUncheckOptions & TimeoutOptions): Promise<void>;\n    all(): Promise<Locator[]>;\n    allInnerTexts(): Promise<string[]>;\n    allTextContents(): Promise<string[]>;\n    waitFor(options: channels.FrameWaitForSelectorOptions & TimeoutOptions & {\n        state: 'attached' | 'visible';\n    }): Promise<void>;\n    waitFor(options?: channels.FrameWaitForSelectorOptions & TimeoutOptions): Promise<void>;\n    _expect(expression: string, options: FrameExpectParams): Promise<{\n        matches: boolean;\n        received?: any;\n        log?: string[];\n        timedOut?: boolean;\n        errorMessage?: string;\n    }>;\n    private _inspect;\n    toString(): string;\n}\nexport declare class FrameLocator implements api.FrameLocator {\n    private _frame;\n    private _frameSelector;\n    constructor(frame: Frame, selector: string);\n    locator(selectorOrLocator: string | Locator, options?: LocatorOptions): Locator;\n    getByTestId(testId: string | RegExp): Locator;\n    getByAltText(text: string | RegExp, options?: {\n        exact?: boolean;\n    }): Locator;\n    getByLabel(text: string | RegExp, options?: {\n        exact?: boolean;\n    }): Locator;\n    getByPlaceholder(text: string | RegExp, options?: {\n        exact?: boolean;\n    }): Locator;\n    getByText(text: string | RegExp, options?: {\n        exact?: boolean;\n    }): Locator;\n    getByTitle(text: string | RegExp, options?: {\n        exact?: boolean;\n    }): Locator;\n    getByRole(role: string, options?: ByRoleOptions): Locator;\n    owner(): Locator;\n    frameLocator(selector: string): FrameLocator;\n    first(): FrameLocator;\n    last(): FrameLocator;\n    nth(index: number): FrameLocator;\n}\nexport declare function testIdAttributeName(): string;\nexport declare function setTestIdAttribute(attributeName: string): void;\n//# sourceMappingURL=locator.d.ts.map",
      "client/network.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ChannelOwner } from './channelOwner';\nimport { APIResponse } from './fetch';\nimport { Frame } from './frame';\nimport { Worker } from './worker';\nimport { LongStandingScope, ManualPromise } from '../utils/isomorphic/manualPromise';\nimport type { BrowserContext } from './browserContext';\nimport type { Page } from './page';\nimport type { Headers, RemoteAddr, SecurityDetails, WaitForEventOptions } from './types';\nimport type { Serializable } from '../../types/structs';\nimport type * as api from '../../types/types';\nimport type { HeadersArray } from '../utils/isomorphic/types';\nimport type { URLMatch } from '../utils/isomorphic/urlMatch';\nimport type * as channels from '@protocol/channels';\nimport type { Platform } from './platform';\nexport type NetworkCookie = {\n    name: string;\n    value: string;\n    domain: string;\n    path: string;\n    expires: number;\n    httpOnly: boolean;\n    secure: boolean;\n    sameSite: 'Strict' | 'Lax' | 'None';\n};\nexport type SetNetworkCookieParam = {\n    name: string;\n    value: string;\n    url?: string;\n    domain?: string;\n    path?: string;\n    expires?: number;\n    httpOnly?: boolean;\n    secure?: boolean;\n    sameSite?: 'Strict' | 'Lax' | 'None';\n};\nexport type ClearNetworkCookieOptions = {\n    name?: string | RegExp;\n    domain?: string | RegExp;\n    path?: string | RegExp;\n};\ntype SerializedFallbackOverrides = {\n    url?: string;\n    method?: string;\n    headers?: Headers;\n    postDataBuffer?: Buffer;\n};\ntype FallbackOverrides = {\n    url?: string;\n    method?: string;\n    headers?: Headers;\n    postData?: string | Buffer | Serializable;\n};\nexport declare class Request extends ChannelOwner<channels.RequestChannel> implements api.Request {\n    private _redirectedFrom;\n    private _redirectedTo;\n    _failureText: string | null;\n    private _provisionalHeaders;\n    private _actualHeadersPromise;\n    _timing: ResourceTiming;\n    private _fallbackOverrides;\n    _hasResponse: boolean;\n    static from(request: channels.RequestChannel): Request;\n    static fromNullable(request: channels.RequestChannel | undefined): Request | null;\n    constructor(parent: ChannelOwner, type: string, guid: string, initializer: channels.RequestInitializer);\n    url(): string;\n    resourceType(): string;\n    method(): string;\n    postData(): string | null;\n    postDataBuffer(): Buffer | null;\n    postDataJSON(): Object | null;\n    /**\n     * @deprecated\n     */\n    headers(): Headers;\n    _actualHeaders(): Promise<RawHeaders>;\n    allHeaders(): Promise<Headers>;\n    headersArray(): Promise<HeadersArray>;\n    headerValue(name: string): Promise<string | null>;\n    response(): Promise<Response | null>;\n    _internalResponse(): Promise<Response | null>;\n    frame(): Frame;\n    _safePage(): Page | null;\n    serviceWorker(): Worker | null;\n    isNavigationRequest(): boolean;\n    redirectedFrom(): Request | null;\n    redirectedTo(): Request | null;\n    failure(): {\n        errorText: string;\n    } | null;\n    timing(): ResourceTiming;\n    sizes(): Promise<RequestSizes>;\n    _setResponseEndTiming(responseEndTiming: number): void;\n    _finalRequest(): Request;\n    _applyFallbackOverrides(overrides: FallbackOverrides): void;\n    _fallbackOverridesForContinue(): SerializedFallbackOverrides;\n    _targetClosedScope(): LongStandingScope;\n}\nexport declare class Route extends ChannelOwner<channels.RouteChannel> implements api.Route {\n    private _handlingPromise;\n    _context: BrowserContext;\n    _didThrow: boolean;\n    static from(route: channels.RouteChannel): Route;\n    constructor(parent: ChannelOwner, type: string, guid: string, initializer: channels.RouteInitializer);\n    request(): Request;\n    private _raceWithTargetClose;\n    _startHandling(): Promise<boolean>;\n    fallback(options?: FallbackOverrides): Promise<void>;\n    abort(errorCode?: string): Promise<void>;\n    _redirectNavigationRequest(url: string): Promise<void>;\n    fetch(options?: FallbackOverrides & {\n        maxRedirects?: number;\n        maxRetries?: number;\n        timeout?: number;\n    }): Promise<APIResponse>;\n    fulfill(options?: {\n        response?: api.APIResponse;\n        status?: number;\n        headers?: Headers;\n        contentType?: string;\n        body?: string | Buffer;\n        json?: any;\n        path?: string;\n    }): Promise<void>;\n    private _handleRoute;\n    private _innerFulfill;\n    continue(options?: FallbackOverrides): Promise<void>;\n    _checkNotHandled(): void;\n    _reportHandled(done: boolean): void;\n    _innerContinue(isFallback: boolean): Promise<void>;\n}\nexport declare class WebSocketRoute extends ChannelOwner<channels.WebSocketRouteChannel> implements api.WebSocketRoute {\n    static from(route: channels.WebSocketRouteChannel): WebSocketRoute;\n    private _onPageMessage?;\n    private _onPageClose?;\n    private _onServerMessage?;\n    private _onServerClose?;\n    private _server;\n    private _connected;\n    constructor(parent: ChannelOwner, type: string, guid: string, initializer: channels.WebSocketRouteInitializer);\n    url(): any;\n    close(options?: {\n        code?: number;\n        reason?: string;\n    }): Promise<void>;\n    connectToServer(): api.WebSocketRoute;\n    send(message: string | Buffer): void;\n    onMessage(handler: (message: string | Buffer) => any): void;\n    onClose(handler: (code: number | undefined, reason: string | undefined) => any): void;\n    [Symbol.asyncDispose](): Promise<void>;\n    _afterHandle(): Promise<void>;\n}\nexport declare class WebSocketRouteHandler {\n    private readonly _baseURL;\n    readonly url: URLMatch;\n    readonly handler: WebSocketRouteHandlerCallback;\n    constructor(baseURL: string | undefined, url: URLMatch, handler: WebSocketRouteHandlerCallback);\n    static prepareInterceptionPatterns(handlers: WebSocketRouteHandler[]): any;\n    matches(wsURL: string): boolean;\n    handle(webSocketRoute: WebSocketRoute): Promise<void>;\n}\nexport type RouteHandlerCallback = (route: Route, request: Request) => Promise<any> | void;\nexport type WebSocketRouteHandlerCallback = (ws: WebSocketRoute) => Promise<any> | void;\nexport type ResourceTiming = {\n    startTime: number;\n    domainLookupStart: number;\n    domainLookupEnd: number;\n    connectStart: number;\n    secureConnectionStart: number;\n    connectEnd: number;\n    requestStart: number;\n    responseStart: number;\n    responseEnd: number;\n};\nexport type RequestSizes = {\n    requestBodySize: number;\n    requestHeadersSize: number;\n    responseBodySize: number;\n    responseHeadersSize: number;\n};\nexport declare class Response extends ChannelOwner<channels.ResponseChannel> implements api.Response {\n    private _provisionalHeaders;\n    private _actualHeadersPromise;\n    private _request;\n    readonly _finishedPromise: ManualPromise<null>;\n    static from(response: channels.ResponseChannel): Response;\n    static fromNullable(response: channels.ResponseChannel | undefined): Response | null;\n    constructor(parent: ChannelOwner, type: string, guid: string, initializer: channels.ResponseInitializer);\n    url(): string;\n    ok(): boolean;\n    status(): number;\n    statusText(): string;\n    fromServiceWorker(): boolean;\n    /**\n     * @deprecated\n     */\n    headers(): Headers;\n    _actualHeaders(): Promise<RawHeaders>;\n    allHeaders(): Promise<Headers>;\n    headersArray(): Promise<HeadersArray>;\n    headerValue(name: string): Promise<string | null>;\n    headerValues(name: string): Promise<string[]>;\n    finished(): Promise<null>;\n    body(): Promise<Buffer>;\n    text(): Promise<string>;\n    json(): Promise<object>;\n    request(): Request;\n    frame(): Frame;\n    serverAddr(): Promise<RemoteAddr | null>;\n    securityDetails(): Promise<SecurityDetails | null>;\n}\nexport declare class WebSocket extends ChannelOwner<channels.WebSocketChannel> implements api.WebSocket {\n    private _page;\n    private _isClosed;\n    static from(webSocket: channels.WebSocketChannel): WebSocket;\n    constructor(parent: ChannelOwner, type: string, guid: string, initializer: channels.WebSocketInitializer);\n    url(): string;\n    isClosed(): boolean;\n    waitForEvent(event: string, optionsOrPredicate?: WaitForEventOptions): Promise<any>;\n}\nexport declare function validateHeaders(headers: Headers): void;\nexport declare class RouteHandler {\n    private handledCount;\n    private readonly _baseURL;\n    private readonly _times;\n    readonly url: URLMatch;\n    readonly handler: RouteHandlerCallback;\n    private _ignoreException;\n    private _activeInvocations;\n    private _savedZone;\n    constructor(platform: Platform, baseURL: string | undefined, url: URLMatch, handler: RouteHandlerCallback, times?: number);\n    static prepareInterceptionPatterns(handlers: RouteHandler[]): any;\n    matches(requestURL: string): boolean;\n    handle(route: Route): Promise<boolean>;\n    private _handleImpl;\n    stop(behavior: 'wait' | 'ignoreErrors'): Promise<void>;\n    private _handleInternal;\n    willExpire(): boolean;\n}\nexport declare class RawHeaders {\n    private _headersArray;\n    private _headersMap;\n    static _fromHeadersObjectLossy(headers: Headers): RawHeaders;\n    constructor(headers: HeadersArray);\n    get(name: string): string | null;\n    getAll(name: string): string[];\n    headers(): Headers;\n    headersArray(): HeadersArray;\n}\nexport {};\n//# sourceMappingURL=network.d.ts.map",
      "client/page.d.ts": "/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ChannelOwner } from './channelOwner';\nimport { Coverage } from './coverage';\nimport { ElementHandle } from './elementHandle';\nimport { TargetClosedError } from './errors';\nimport { Frame } from './frame';\nimport { Keyboard, Mouse, Touchscreen } from './input';\nimport { Request, Response, RouteHandler, WebSocketRouteHandler } from './network';\nimport { Video } from './video';\nimport { Worker } from './worker';\nimport { TimeoutSettings } from './timeoutSettings';\nimport { LongStandingScope } from '../utils/isomorphic/manualPromise';\nimport { ConsoleMessage } from './consoleMessage';\nimport type { BrowserContext } from './browserContext';\nimport type { Clock } from './clock';\nimport type { APIRequestContext } from './fetch';\nimport type { WaitForNavigationOptions } from './frame';\nimport type { FrameLocator, Locator, LocatorOptions } from './locator';\nimport type { RouteHandlerCallback, WebSocketRouteHandlerCallback } from './network';\nimport type { FilePayload, Headers, LifecycleEvent, SelectOption, SelectOptionOptions, Size, TimeoutOptions, WaitForEventOptions, WaitForFunctionOptions } from './types';\nimport type * as structs from '../../types/structs';\nimport type * as api from '../../types/types';\nimport type { ByRoleOptions } from '../utils/isomorphic/locatorUtils';\nimport type { URLMatch } from '../utils/isomorphic/urlMatch';\nimport type * as channels from '@protocol/channels';\ntype PDFOptions = Omit<channels.PagePdfParams, 'width' | 'height' | 'margin'> & {\n    width?: string | number;\n    height?: string | number;\n    margin?: {\n        top?: string | number;\n        bottom?: string | number;\n        left?: string | number;\n        right?: string | number;\n    };\n    path?: string;\n};\nexport type ExpectScreenshotOptions = Omit<channels.PageExpectScreenshotOptions, 'locator' | 'expected' | 'mask'> & {\n    expected?: Buffer;\n    locator?: api.Locator;\n    timeout: number;\n    isNot: boolean;\n    mask?: api.Locator[];\n};\nexport declare class Page extends ChannelOwner<channels.PageChannel> implements api.Page {\n    private _browserContext;\n    _ownedContext: BrowserContext | undefined;\n    private _mainFrame;\n    private _frames;\n    _workers: Set<Worker>;\n    private _closed;\n    readonly _closedOrCrashedScope: LongStandingScope;\n    private _viewportSize;\n    _routes: RouteHandler[];\n    _webSocketRoutes: WebSocketRouteHandler[];\n    readonly coverage: Coverage;\n    readonly keyboard: Keyboard;\n    readonly mouse: Mouse;\n    readonly request: APIRequestContext;\n    readonly touchscreen: Touchscreen;\n    readonly clock: Clock;\n    readonly _bindings: Map<string, (source: structs.BindingSource, ...args: any[]) => any>;\n    readonly _timeoutSettings: TimeoutSettings;\n    private _video;\n    readonly _opener: Page | null;\n    private _closeReason;\n    _closeWasCalled: boolean;\n    private _harRouters;\n    private _locatorHandlers;\n    static from(page: channels.PageChannel): Page;\n    static fromNullable(page: channels.PageChannel | undefined): Page | null;\n    constructor(parent: ChannelOwner, type: string, guid: string, initializer: channels.PageInitializer);\n    private _onFrameAttached;\n    private _onFrameDetached;\n    private _onRoute;\n    private _onWebSocketRoute;\n    _onBinding(bindingCall: BindingCall): Promise<void>;\n    _onWorker(worker: Worker): void;\n    _onClose(): void;\n    private _onCrash;\n    context(): BrowserContext;\n    opener(): Promise<Page | null>;\n    mainFrame(): Frame;\n    frame(frameSelector: string | {\n        name?: string;\n        url?: URLMatch;\n    }): Frame | null;\n    frames(): Frame[];\n    setDefaultNavigationTimeout(timeout: number): void;\n    setDefaultTimeout(timeout: number): void;\n    private _forceVideo;\n    video(): Video | null;\n    $(selector: string, options?: {\n        strict?: boolean;\n    }): Promise<ElementHandle<SVGElement | HTMLElement> | null>;\n    waitForSelector(selector: string, options: channels.FrameWaitForSelectorOptions & TimeoutOptions & {\n        state: 'attached' | 'visible';\n    }): Promise<ElementHandle<SVGElement | HTMLElement>>;\n    waitForSelector(selector: string, options?: channels.FrameWaitForSelectorOptions & TimeoutOptions): Promise<ElementHandle<SVGElement | HTMLElement> | null>;\n    dispatchEvent(selector: string, type: string, eventInit?: any, options?: channels.FrameDispatchEventOptions): Promise<void>;\n    evaluateHandle<R, Arg>(pageFunction: structs.PageFunction<Arg, R>, arg?: Arg): Promise<structs.SmartHandle<R>>;\n    $eval<R, Arg>(selector: string, pageFunction: structs.PageFunctionOn<Element, Arg, R>, arg?: Arg): Promise<R>;\n    $$eval<R, Arg>(selector: string, pageFunction: structs.PageFunctionOn<Element[], Arg, R>, arg?: Arg): Promise<R>;\n    $$(selector: string): Promise<ElementHandle<SVGElement | HTMLElement>[]>;\n    addScriptTag(options?: {\n        url?: string;\n        path?: string;\n        content?: string;\n        type?: string;\n    }): Promise<ElementHandle>;\n    addStyleTag(options?: {\n        url?: string;\n        path?: string;\n        content?: string;\n    }): Promise<ElementHandle>;\n    exposeFunction(name: string, callback: Function): Promise<void>;\n    exposeBinding(name: string, callback: (source: structs.BindingSource, ...args: any[]) => any, options?: {\n        handle?: boolean;\n    }): Promise<void>;\n    setExtraHTTPHeaders(headers: Headers): Promise<void>;\n    url(): string;\n    content(): Promise<string>;\n    setContent(html: string, options?: channels.FrameSetContentOptions & TimeoutOptions): Promise<void>;\n    goto(url: string, options?: channels.FrameGotoOptions & TimeoutOptions): Promise<Response | null>;\n    reload(options?: channels.PageReloadOptions & TimeoutOptions): Promise<Response | null>;\n    addLocatorHandler(locator: Locator, handler: (locator: Locator) => any, options?: {\n        times?: number;\n        noWaitAfter?: boolean;\n    }): Promise<void>;\n    private _onLocatorHandlerTriggered;\n    removeLocatorHandler(locator: Locator): Promise<void>;\n    waitForLoadState(state?: LifecycleEvent, options?: TimeoutOptions): Promise<void>;\n    waitForNavigation(options?: WaitForNavigationOptions): Promise<Response | null>;\n    waitForURL(url: URLMatch, options?: TimeoutOptions & {\n        waitUntil?: LifecycleEvent;\n    }): Promise<void>;\n    waitForRequest(urlOrPredicate: string | RegExp | ((r: Request) => boolean | Promise<boolean>), options?: TimeoutOptions): Promise<Request>;\n    waitForResponse(urlOrPredicate: string | RegExp | ((r: Response) => boolean | Promise<boolean>), options?: TimeoutOptions): Promise<Response>;\n    waitForEvent(event: string, optionsOrPredicate?: WaitForEventOptions): Promise<any>;\n    _closeErrorWithReason(): TargetClosedError;\n    private _waitForEvent;\n    goBack(options?: channels.PageGoBackOptions & TimeoutOptions): Promise<Response | null>;\n    goForward(options?: channels.PageGoForwardOptions & TimeoutOptions): Promise<Response | null>;\n    requestGC(): Promise<void>;\n    emulateMedia(options?: {\n        media?: 'screen' | 'print' | null;\n        colorScheme?: 'dark' | 'light' | 'no-preference' | null;\n        reducedMotion?: 'reduce' | 'no-preference' | null;\n        forcedColors?: 'active' | 'none' | null;\n        contrast?: 'no-preference' | 'more' | null;\n    }): Promise<void>;\n    setViewportSize(viewportSize: Size): Promise<void>;\n    viewportSize(): Size | null;\n    evaluate<R, Arg>(pageFunction: structs.PageFunction<Arg, R>, arg?: Arg): Promise<R>;\n    _evaluateFunction(functionDeclaration: string): Promise<any>;\n    addInitScript(script: Function | string | {\n        path?: string;\n        content?: string;\n    }, arg?: any): Promise<void>;\n    route(url: URLMatch, handler: RouteHandlerCallback, options?: {\n        times?: number;\n    }): Promise<void>;\n    routeFromHAR(har: string, options?: {\n        url?: string | RegExp;\n        notFound?: 'abort' | 'fallback';\n        update?: boolean;\n        updateContent?: 'attach' | 'embed';\n        updateMode?: 'minimal' | 'full';\n    }): Promise<void>;\n    routeWebSocket(url: URLMatch, handler: WebSocketRouteHandlerCallback): Promise<void>;\n    private _disposeHarRouters;\n    unrouteAll(options?: {\n        behavior?: 'wait' | 'ignoreErrors' | 'default';\n    }): Promise<void>;\n    unroute(url: URLMatch, handler?: RouteHandlerCallback): Promise<void>;\n    private _unrouteInternal;\n    private _updateInterceptionPatterns;\n    private _updateWebSocketInterceptionPatterns;\n    screenshot(options?: Omit<channels.PageScreenshotOptions, 'mask'> & TimeoutOptions & {\n        path?: string;\n        mask?: api.Locator[];\n    }): Promise<Buffer>;\n    _expectScreenshot(options: ExpectScreenshotOptions): Promise<{\n        actual?: Buffer;\n        previous?: Buffer;\n        diff?: Buffer;\n        errorMessage?: string;\n        log?: string[];\n        timedOut?: boolean;\n    }>;\n    title(): Promise<string>;\n    bringToFront(): Promise<void>;\n    [Symbol.asyncDispose](): Promise<void>;\n    close(options?: {\n        runBeforeUnload?: boolean;\n        reason?: string;\n    }): Promise<void>;\n    isClosed(): boolean;\n    click(selector: string, options?: channels.FrameClickOptions & TimeoutOptions): Promise<any>;\n    dragAndDrop(source: string, target: string, options?: channels.FrameDragAndDropOptions & TimeoutOptions): Promise<any>;\n    dblclick(selector: string, options?: channels.FrameDblclickOptions & TimeoutOptions): Promise<void>;\n    tap(selector: string, options?: channels.FrameTapOptions & TimeoutOptions): Promise<any>;\n    fill(selector: string, value: string, options?: channels.FrameFillOptions & TimeoutOptions): Promise<any>;\n    consoleMessages(): Promise<ConsoleMessage[]>;\n    pageErrors(): Promise<Error[]>;\n    locator(selector: string, options?: LocatorOptions): Locator;\n    getByTestId(testId: string | RegExp): Locator;\n    getByAltText(text: string | RegExp, options?: {\n        exact?: boolean;\n    }): Locator;\n    getByLabel(text: string | RegExp, options?: {\n        exact?: boolean;\n    }): Locator;\n    getByPlaceholder(text: string | RegExp, options?: {\n        exact?: boolean;\n    }): Locator;\n    getByText(text: string | RegExp, options?: {\n        exact?: boolean;\n    }): Locator;\n    getByTitle(text: string | RegExp, options?: {\n        exact?: boolean;\n    }): Locator;\n    getByRole(role: string, options?: ByRoleOptions): Locator;\n    frameLocator(selector: string): FrameLocator;\n    focus(selector: string, options?: channels.FrameFocusOptions & TimeoutOptions): Promise<void>;\n    textContent(selector: string, options?: channels.FrameTextContentOptions & TimeoutOptions): Promise<null | string>;\n    innerText(selector: string, options?: channels.FrameInnerTextOptions & TimeoutOptions): Promise<string>;\n    innerHTML(selector: string, options?: channels.FrameInnerHTMLOptions & TimeoutOptions): Promise<string>;\n    getAttribute(selector: string, name: string, options?: channels.FrameGetAttributeOptions & TimeoutOptions): Promise<string | null>;\n    inputValue(selector: string, options?: channels.FrameInputValueOptions & TimeoutOptions): Promise<string>;\n    isChecked(selector: string, options?: channels.FrameIsCheckedOptions & TimeoutOptions): Promise<boolean>;\n    isDisabled(selector: string, options?: channels.FrameIsDisabledOptions & TimeoutOptions): Promise<boolean>;\n    isEditable(selector: string, options?: channels.FrameIsEditableOptions & TimeoutOptions): Promise<boolean>;\n    isEnabled(selector: string, options?: channels.FrameIsEnabledOptions & TimeoutOptions): Promise<boolean>;\n    isHidden(selector: string, options?: channels.FrameIsHiddenOptions & TimeoutOptions): Promise<boolean>;\n    isVisible(selector: string, options?: channels.FrameIsVisibleOptions & TimeoutOptions): Promise<boolean>;\n    hover(selector: string, options?: channels.FrameHoverOptions & TimeoutOptions): Promise<void>;\n    selectOption(selector: string, values: string | api.ElementHandle | SelectOption | string[] | api.ElementHandle[] | SelectOption[] | null, options?: SelectOptionOptions): Promise<string[]>;\n    setInputFiles(selector: string, files: string | FilePayload | string[] | FilePayload[], options?: channels.FrameSetInputFilesOptions & TimeoutOptions): Promise<void>;\n    type(selector: string, text: string, options?: channels.FrameTypeOptions & TimeoutOptions): Promise<void>;\n    press(selector: string, key: string, options?: channels.FramePressOptions & TimeoutOptions): Promise<void>;\n    check(selector: string, options?: channels.FrameCheckOptions & TimeoutOptions): Promise<void>;\n    uncheck(selector: string, options?: channels.FrameUncheckOptions & TimeoutOptions): Promise<void>;\n    setChecked(selector: string, checked: boolean, options?: channels.FrameCheckOptions & TimeoutOptions): Promise<void>;\n    waitForTimeout(timeout: number): Promise<void>;\n    waitForFunction<R, Arg>(pageFunction: structs.PageFunction<Arg, R>, arg?: Arg, options?: WaitForFunctionOptions): Promise<structs.SmartHandle<R>>;\n    requests(): Promise<any>;\n    workers(): Worker[];\n    pause(_options?: {\n        __testHookKeepTestTimeout: boolean;\n    }): Promise<void>;\n    pdf(options?: PDFOptions): Promise<Buffer>;\n    _snapshotForAI(options?: TimeoutOptions & {\n        track?: string;\n    }): Promise<{\n        full: string;\n        incremental?: string;\n    }>;\n}\nexport declare class BindingCall extends ChannelOwner<channels.BindingCallChannel> {\n    static from(channel: channels.BindingCallChannel): BindingCall;\n    constructor(parent: ChannelOwner, type: string, guid: string, initializer: channels.BindingCallInitializer);\n    call(func: (source: structs.BindingSource, ...args: any[]) => any): Promise<void>;\n}\nexport {};\n//# sourceMappingURL=page.d.ts.map",
      "client/pageImpl.d.ts": "/**\n * PageImpl - CDP-direct Page implementation\n * Provides Playwright Page API using direct CDP calls\n */\nimport { CDPAdapter } from './cdpAdapter';\nimport { FrameImpl } from './frameImpl';\nimport type { BrowserImpl } from './browserImpl';\nimport type { CRSession } from '../server/chromium/crConnection';\nexport interface GotoOptions {\n    timeout?: number;\n    waitUntil?: 'load' | 'domcontentloaded' | 'networkidle';\n}\nexport interface ScreenshotOptions {\n    format?: 'png' | 'jpeg';\n    quality?: number;\n    fullPage?: boolean;\n    timeout?: number;\n}\n/**\n * CDP-direct Page implementation\n */\nexport declare class PageImpl {\n    private _browser;\n    private _adapter;\n    private _session;\n    private _targetId;\n    private _url;\n    private _mainFrame;\n    private _eventEmitter;\n    private _defaultTimeout;\n    constructor(browser: BrowserImpl, adapter: CDPAdapter, targetId: string, session: CRSession);\n    /**\n     * Get the current page URL\n     */\n    url(): string;\n    /**\n     * Get the main frame\n     */\n    mainFrame(): FrameImpl;\n    /**\n     * Navigate to a URL\n     */\n    goto(url: string, options?: GotoOptions): Promise<void>;\n    /**\n     * Wait for navigation to complete\n     */\n    private _waitForNavigation;\n    /**\n     * Evaluate JavaScript in the page context\n     */\n    evaluate<T>(pageFunction: string | ((...args: any[]) => T), ...args: any[]): Promise<T>;\n    /**\n     * Take a screenshot of the page\n     */\n    screenshot(options?: ScreenshotOptions): Promise<Uint8Array>;\n    /**\n     * Get the page title\n     */\n    title(): Promise<string>;\n    /**\n     * Get the page content (HTML)\n     */\n    content(): Promise<string>;\n    /**\n     * Close the page\n     */\n    close(): Promise<void>;\n    /**\n     * Get the CDP session\n     */\n    _getSession(): CRSession;\n    /**\n     * Get the CDP adapter\n     */\n    _getAdapter(): CDPAdapter;\n    /**\n     * Get the target ID\n     */\n    _getTargetId(): string;\n    /**\n     * Set default timeout for operations\n     */\n    setDefaultTimeout(timeout: number): void;\n    /**\n     * Set default navigation timeout\n     */\n    setDefaultNavigationTimeout(timeout: number): void;\n    waitForSelector(selector: string, options?: any): Promise<any>;\n    querySelector(selector: string): Promise<any>;\n    click(selector: string, options?: any): Promise<void>;\n    fill(selector: string, value: string, options?: any): Promise<void>;\n    type(selector: string, text: string, options?: any): Promise<void>;\n}\n//# sourceMappingURL=pageImpl.d.ts.map",
      "client/platform.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type * as fs from 'fs';\nimport type * as path from 'path';\nimport type { Readable, Writable } from 'stream';\nimport type { Colors } from '@isomorphic/colors';\nimport type * as channels from '@protocol/channels';\nexport type Zone = {\n    push(data: unknown): Zone;\n    pop(): Zone;\n    run<R>(func: () => R): R;\n    data<T>(): T | undefined;\n};\nexport type Platform = {\n    name: 'node' | 'web' | 'empty';\n    boxedStackPrefixes: () => string[];\n    calculateSha1: (text: string) => Promise<string>;\n    colors: Colors;\n    coreDir?: string;\n    createGuid: () => string;\n    defaultMaxListeners: () => number;\n    env: Record<string, string | undefined>;\n    fs: () => typeof fs;\n    inspectCustom: symbol | undefined;\n    isDebugMode: () => boolean;\n    isJSDebuggerAttached: () => boolean;\n    isLogEnabled: (name: 'api' | 'channel') => boolean;\n    isUnderTest: () => boolean;\n    log: (name: 'api' | 'channel', message: string | Error | object) => void;\n    path: () => typeof path;\n    pathSeparator: string;\n    showInternalStackFrames: () => boolean;\n    streamFile: (path: string, writable: Writable) => Promise<void>;\n    streamReadable: (channel: channels.StreamChannel) => Readable;\n    streamWritable: (channel: channels.WritableStreamChannel) => Writable;\n    zones: {\n        empty: Zone;\n        current: () => Zone;\n    };\n};\nexport declare const emptyPlatform: Platform;\nexport declare const webPlatform: Platform;\n//# sourceMappingURL=platform.d.ts.map",
      "client/playwright.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Android } from './android';\nimport { Browser } from './browser';\nimport { BrowserType } from './browserType';\nimport { ChannelOwner } from './channelOwner';\nimport { Electron } from './electron';\nimport { TimeoutError } from './errors';\nimport { APIRequest } from './fetch';\nimport { Selectors } from './selectors';\nimport type * as channels from '@protocol/channels';\nimport type { BrowserContextOptions, LaunchOptions } from 'playwright-core';\nexport declare class Playwright extends ChannelOwner<channels.PlaywrightChannel> {\n    readonly _android: Android;\n    readonly _electron: Electron;\n    readonly chromium: BrowserType;\n    readonly firefox: BrowserType;\n    readonly webkit: BrowserType;\n    readonly devices: any;\n    selectors: Selectors;\n    readonly request: APIRequest;\n    readonly errors: {\n        TimeoutError: typeof TimeoutError;\n    };\n    _defaultLaunchOptions?: LaunchOptions;\n    _defaultContextOptions?: BrowserContextOptions;\n    _defaultContextTimeout?: number;\n    _defaultContextNavigationTimeout?: number;\n    constructor(parent: ChannelOwner, type: string, guid: string, initializer: channels.PlaywrightInitializer);\n    static from(channel: channels.PlaywrightChannel): Playwright;\n    private _browserTypes;\n    _preLaunchedBrowser(): Browser;\n    _allContexts(): import(\"./browserContext\").BrowserContext[];\n    _allPages(): import(\"./page\").Page[];\n}\n//# sourceMappingURL=playwright.d.ts.map",
      "client/selectors.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { SelectorEngine } from './types';\nimport type * as api from '../../types/types';\nimport type { BrowserContext } from './browserContext';\nimport type { Platform } from './platform';\nexport declare class Selectors implements api.Selectors {\n    private _platform;\n    private _selectorEngines;\n    private _testIdAttributeName;\n    readonly _contextsForSelectors: Set<BrowserContext>;\n    constructor(platform: Platform);\n    register(name: string, script: string | (() => SelectorEngine) | {\n        path?: string;\n        content?: string;\n    }, options?: {\n        contentScript?: boolean;\n    }): Promise<void>;\n    setTestIdAttribute(attributeName: string): void;\n    _withSelectorOptions<T>(options: T): T & {\n        selectorEngines: channels.SelectorEngine[];\n        testIdAttributeName: string;\n    };\n}\n//# sourceMappingURL=selectors.d.ts.map",
      "client/stream.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Readable } from 'stream';\nimport { ChannelOwner } from './channelOwner';\nimport type * as channels from '@protocol/channels';\nexport declare class Stream extends ChannelOwner<channels.StreamChannel> {\n    static from(Stream: channels.StreamChannel): Stream;\n    constructor(parent: ChannelOwner, type: string, guid: string, initializer: channels.StreamInitializer);\n    stream(): Readable;\n}\n//# sourceMappingURL=stream.d.ts.map",
      "client/timeoutSettings.d.ts": "/**\n * Copyright 2019 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { Platform } from './platform';\nexport declare class TimeoutSettings {\n    private _parent;\n    private _defaultTimeout;\n    private _defaultNavigationTimeout;\n    private _platform;\n    constructor(platform: Platform, parent?: TimeoutSettings);\n    setDefaultTimeout(timeout: number | undefined): void;\n    setDefaultNavigationTimeout(timeout: number | undefined): void;\n    defaultNavigationTimeout(): number;\n    defaultTimeout(): number;\n    navigationTimeout(options: {\n        timeout?: number;\n    }): number;\n    timeout(options: {\n        timeout?: number;\n    }): number;\n    launchTimeout(options: {\n        timeout?: number;\n    }): number;\n}\n//# sourceMappingURL=timeoutSettings.d.ts.map",
      "client/tracing.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ChannelOwner } from './channelOwner';\nimport type * as api from '../../types/types';\nimport type * as channels from '@protocol/channels';\nexport declare class Tracing extends ChannelOwner<channels.TracingChannel> implements api.Tracing {\n    private _includeSources;\n    private _isLive;\n    _tracesDir: string | undefined;\n    private _stacksId;\n    private _isTracing;\n    static from(channel: channels.TracingChannel): Tracing;\n    constructor(parent: ChannelOwner, type: string, guid: string, initializer: channels.TracingInitializer);\n    start(options?: {\n        name?: string;\n        title?: string;\n        snapshots?: boolean;\n        screenshots?: boolean;\n        sources?: boolean;\n        _live?: boolean;\n    }): Promise<void>;\n    startChunk(options?: {\n        name?: string;\n        title?: string;\n    }): Promise<void>;\n    group(name: string, options?: {\n        location?: {\n            file: string;\n            line?: number;\n            column?: number;\n        };\n    }): Promise<void>;\n    groupEnd(): Promise<void>;\n    private _startCollectingStacks;\n    stopChunk(options?: {\n        path?: string;\n    }): Promise<void>;\n    stop(options?: {\n        path?: string;\n    }): Promise<void>;\n    private _doStopChunk;\n    _resetStackCounter(): void;\n}\n//# sourceMappingURL=tracing.d.ts.map",
      "client/types.d.ts": "/**\n * Copyright 2018 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { Size } from '../utils/isomorphic/types';\nimport type * as channels from '@protocol/channels';\nexport type { HeadersArray, Point, Quad, Rect, Size } from '../utils/isomorphic/types';\ntype LoggerSeverity = 'verbose' | 'info' | 'warning' | 'error';\nexport interface Logger {\n    isEnabled(name: string, severity: LoggerSeverity): boolean;\n    log(name: string, severity: LoggerSeverity, message: string | Error, args: any[], hints: {\n        color?: string;\n    }): void;\n}\nexport type TimeoutOptions = {\n    timeout?: number;\n};\nexport type StrictOptions = {\n    strict?: boolean;\n};\nexport type Headers = {\n    [key: string]: string;\n};\nexport type WaitForEventOptions = Function | TimeoutOptions & {\n    predicate?: Function;\n};\nexport type WaitForFunctionOptions = TimeoutOptions & {\n    polling?: 'raf' | number;\n};\nexport type SelectOption = {\n    value?: string;\n    label?: string;\n    index?: number;\n    valueOrLabel?: string;\n};\nexport type SelectOptionOptions = TimeoutOptions & {\n    force?: boolean;\n};\nexport type FilePayload = {\n    name: string;\n    mimeType: string;\n    buffer: Buffer;\n};\nexport type StorageState = {\n    cookies: channels.NetworkCookie[];\n    origins: (Omit<channels.OriginStorage, 'indexedDB'>)[];\n};\nexport type SetStorageState = {\n    cookies?: channels.SetNetworkCookie[];\n    origins?: (Omit<channels.SetOriginStorage, 'indexedDB'> & {\n        indexedDB?: unknown[];\n    })[];\n};\nexport type LifecycleEvent = channels.LifecycleEvent;\nexport declare const kLifecycleEvents: Set<LifecycleEvent>;\nexport type ClientCertificate = {\n    origin: string;\n    cert?: Buffer;\n    certPath?: string;\n    key?: Buffer;\n    keyPath?: string;\n    pfx?: Buffer;\n    pfxPath?: string;\n    passphrase?: string;\n};\nexport type BrowserContextOptions = Omit<channels.BrowserNewContextOptions, 'viewport' | 'noDefaultViewport' | 'extraHTTPHeaders' | 'clientCertificates' | 'storageState' | 'recordHar' | 'colorScheme' | 'reducedMotion' | 'forcedColors' | 'acceptDownloads' | 'contrast'> & {\n    viewport?: Size | null;\n    extraHTTPHeaders?: Headers;\n    logger?: Logger;\n    videosPath?: string;\n    videoSize?: Size;\n    storageState?: string | SetStorageState;\n    har?: {\n        path: string;\n        fallback?: 'abort' | 'continue';\n        urlFilter?: string | RegExp;\n    };\n    recordHar?: {\n        path: string;\n        omitContent?: boolean;\n        content?: 'omit' | 'embed' | 'attach';\n        mode?: 'full' | 'minimal';\n        urlFilter?: string | RegExp;\n    };\n    colorScheme?: 'dark' | 'light' | 'no-preference' | null;\n    reducedMotion?: 'reduce' | 'no-preference' | null;\n    forcedColors?: 'active' | 'none' | null;\n    contrast?: 'more' | 'no-preference' | null;\n    acceptDownloads?: boolean;\n    clientCertificates?: ClientCertificate[];\n};\ntype LaunchOverrides = {\n    ignoreDefaultArgs?: boolean | string[];\n    env?: NodeJS.ProcessEnv;\n    logger?: Logger;\n    firefoxUserPrefs?: {\n        [key: string]: string | number | boolean;\n    };\n} & TimeoutOptions;\nexport type LaunchOptions = Omit<channels.BrowserTypeLaunchOptions, 'ignoreAllDefaultArgs' | 'ignoreDefaultArgs' | 'env' | 'firefoxUserPrefs'> & LaunchOverrides;\nexport type LaunchPersistentContextOptions = Omit<LaunchOptions & BrowserContextOptions, 'storageState'>;\nexport type ConnectOptions = {\n    wsEndpoint: string;\n    headers?: {\n        [key: string]: string;\n    };\n    exposeNetwork?: string;\n    _exposeNetwork?: string;\n    slowMo?: number;\n    timeout?: number;\n    logger?: Logger;\n};\nexport type LaunchServerOptions = LaunchOptions & {\n    host?: string;\n    port?: number;\n    wsPath?: string;\n};\nexport type LaunchAndroidServerOptions = {\n    deviceSerialNumber?: string;\n    adbHost?: string;\n    adbPort?: number;\n    omitDriverInstall?: boolean;\n    host?: string;\n    port?: number;\n    wsPath?: string;\n};\nexport type SelectorEngine = {\n    /**\n     * Returns the first element matching given selector in the root's subtree.\n     */\n    query(root: HTMLElement, selector: string): HTMLElement | null;\n    /**\n     * Returns all elements matching given selector in the root's subtree.\n     */\n    queryAll(root: HTMLElement, selector: string): HTMLElement[];\n};\nexport type RemoteAddr = channels.RemoteAddr;\nexport type SecurityDetails = channels.SecurityDetails;\nexport type FrameExpectParams = Omit<channels.FrameExpectParams, 'selector' | 'expression' | 'expectedValue'> & {\n    expectedValue?: any;\n};\n//# sourceMappingURL=types.d.ts.map",
      "client/validateBrowserEnvironment.d.ts": "/**\n * Validates that required browser APIs are available.\n * Call this at library initialization to fail fast with clear errors.\n */\nexport declare function validateBrowserEnvironment(): void;\n//# sourceMappingURL=validateBrowserEnvironment.d.ts.map",
      "client/video.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { Artifact } from './artifact';\nimport type { Connection } from './connection';\nimport type { Page } from './page';\nimport type * as api from '../../types/types';\nexport declare class Video implements api.Video {\n    private _artifact;\n    private _artifactReadyPromise;\n    private _isRemote;\n    constructor(page: Page, connection: Connection);\n    _artifactReady(artifact: Artifact): void;\n    path(): Promise<string>;\n    saveAs(path: string): Promise<void>;\n    delete(): Promise<void>;\n}\n//# sourceMappingURL=video.d.ts.map",
      "client/waiter.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { ChannelOwner } from './channelOwner';\nimport type * as channels from '@protocol/channels';\nimport type { EventEmitter } from 'events';\nexport declare class Waiter {\n    private _dispose;\n    private _failures;\n    private _immediateError?;\n    private _logs;\n    private _channelOwner;\n    private _waitId;\n    private _error;\n    private _savedZone;\n    constructor(channelOwner: ChannelOwner<channels.EventTargetChannel>, event: string);\n    static createForEvent(channelOwner: ChannelOwner<channels.EventTargetChannel>, event: string): Waiter;\n    waitForEvent<T = void>(emitter: EventEmitter, event: string, predicate?: (arg: T) => boolean | Promise<boolean>): Promise<T>;\n    rejectOnEvent<T = void>(emitter: EventEmitter, event: string, error: Error | (() => Error), predicate?: (arg: T) => boolean | Promise<boolean>): void;\n    rejectOnTimeout(timeout: number, message: string): void;\n    rejectImmediately(error: Error): void;\n    dispose(): void;\n    waitForPromise<T>(promise: Promise<T>, dispose?: () => void): Promise<T>;\n    log(s: string): void;\n    private _rejectOn;\n}\n//# sourceMappingURL=waiter.d.ts.map",
      "client/webError.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { Page } from './page';\nimport type * as api from '../../types/types';\nexport declare class WebError implements api.WebError {\n    private _page;\n    private _error;\n    constructor(page: Page | null, error: Error);\n    page(): Page;\n    error(): Error;\n}\n//# sourceMappingURL=webError.d.ts.map",
      "client/webSocket.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Connection } from './connection';\nimport type * as channels from '@protocol/channels';\nexport declare function connectOverWebSocket(parentConnection: Connection, params: channels.LocalUtilsConnectParams): Promise<Connection>;\n//# sourceMappingURL=webSocket.d.ts.map",
      "client/worker.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ChannelOwner } from './channelOwner';\nimport { LongStandingScope } from '../utils/isomorphic/manualPromise';\nimport type { BrowserContext } from './browserContext';\nimport type { Page } from './page';\nimport type * as structs from '../../types/structs';\nimport type * as api from '../../types/types';\nimport type * as channels from '@protocol/channels';\nimport type { WaitForEventOptions } from './types';\nexport declare class Worker extends ChannelOwner<channels.WorkerChannel> implements api.Worker {\n    _page: Page | undefined;\n    _context: BrowserContext | undefined;\n    readonly _closedScope: LongStandingScope;\n    static fromNullable(worker: channels.WorkerChannel | undefined): Worker | null;\n    static from(worker: channels.WorkerChannel): Worker;\n    constructor(parent: ChannelOwner, type: string, guid: string, initializer: channels.WorkerInitializer);\n    url(): string;\n    evaluate<R, Arg>(pageFunction: structs.PageFunction<Arg, R>, arg?: Arg): Promise<R>;\n    evaluateHandle<R, Arg>(pageFunction: structs.PageFunction<Arg, R>, arg?: Arg): Promise<structs.SmartHandle<R>>;\n    waitForEvent(event: string, optionsOrPredicate?: WaitForEventOptions): Promise<any>;\n}\n//# sourceMappingURL=worker.d.ts.map",
      "client/writableStream.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ChannelOwner } from './channelOwner';\nimport type * as channels from '@protocol/channels';\nimport type { Writable } from 'stream';\nexport declare class WritableStream extends ChannelOwner<channels.WritableStreamChannel> {\n    static from(Stream: channels.WritableStreamChannel): WritableStream;\n    constructor(parent: ChannelOwner, type: string, guid: string, initializer: channels.WritableStreamInitializer);\n    stream(): Writable;\n}\n//# sourceMappingURL=writableStream.d.ts.map",
      "generated/bindingsControllerSource.d.ts": "export declare const source = \"\\nvar __commonJS = obj => {\\n  let required = false;\\n  let result;\\n  return function __require() {\\n    if (!required) {\\n      required = true;\\n      let fn;\\n      for (const name in obj) { fn = obj[name]; break; }\\n      const module = { exports: {} };\\n      fn(module.exports, module);\\n      result = module.exports;\\n    }\\n    return result;\\n  }\\n};\\nvar __export = (target, all) => {for (var name in all) target[name] = all[name];};\\nvar __toESM = mod => ({ ...mod, 'default': mod });\\nvar __toCommonJS = mod => ({ ...mod, __esModule: true });\\n\\n\\n// packages/playwright-injected/src/bindingsController.ts\\nvar bindingsController_exports = {};\\n__export(bindingsController_exports, {\\n  BindingsController: () => BindingsController\\n});\\nmodule.exports = __toCommonJS(bindingsController_exports);\\n\\n// packages/playwright-core/src/utils/isomorphic/utilityScriptSerializers.ts\\nfunction isRegExp(obj) {\\n  try {\\n    return obj instanceof RegExp || Object.prototype.toString.call(obj) === \\\"[object RegExp]\\\";\\n  } catch (error) {\\n    return false;\\n  }\\n}\\nfunction isDate(obj) {\\n  try {\\n    return obj instanceof Date || Object.prototype.toString.call(obj) === \\\"[object Date]\\\";\\n  } catch (error) {\\n    return false;\\n  }\\n}\\nfunction isURL(obj) {\\n  try {\\n    return obj instanceof URL || Object.prototype.toString.call(obj) === \\\"[object URL]\\\";\\n  } catch (error) {\\n    return false;\\n  }\\n}\\nfunction isError(obj) {\\n  var _a;\\n  try {\\n    return obj instanceof Error || obj && ((_a = Object.getPrototypeOf(obj)) == null ? void 0 : _a.name) === \\\"Error\\\";\\n  } catch (error) {\\n    return false;\\n  }\\n}\\nfunction isTypedArray(obj, constructor) {\\n  try {\\n    return obj instanceof constructor || Object.prototype.toString.call(obj) === `[object ${constructor.name}]`;\\n  } catch (error) {\\n    return false;\\n  }\\n}\\nvar typedArrayConstructors = {\\n  i8: Int8Array,\\n  ui8: Uint8Array,\\n  ui8c: Uint8ClampedArray,\\n  i16: Int16Array,\\n  ui16: Uint16Array,\\n  i32: Int32Array,\\n  ui32: Uint32Array,\\n  // TODO: add Float16Array once it's in baseline\\n  f32: Float32Array,\\n  f64: Float64Array,\\n  bi64: BigInt64Array,\\n  bui64: BigUint64Array\\n};\\nfunction typedArrayToBase64(array) {\\n  if (\\\"toBase64\\\" in array)\\n    return array.toBase64();\\n  const binary = Array.from(new Uint8Array(array.buffer, array.byteOffset, array.byteLength)).map((b) => String.fromCharCode(b)).join(\\\"\\\");\\n  return btoa(binary);\\n}\\nfunction serializeAsCallArgument(value, handleSerializer) {\\n  return serialize(value, handleSerializer, { visited: /* @__PURE__ */ new Map(), lastId: 0 });\\n}\\nfunction serialize(value, handleSerializer, visitorInfo) {\\n  if (value && typeof value === \\\"object\\\") {\\n    if (typeof globalThis.Window === \\\"function\\\" && value instanceof globalThis.Window)\\n      return \\\"ref: <Window>\\\";\\n    if (typeof globalThis.Document === \\\"function\\\" && value instanceof globalThis.Document)\\n      return \\\"ref: <Document>\\\";\\n    if (typeof globalThis.Node === \\\"function\\\" && value instanceof globalThis.Node)\\n      return \\\"ref: <Node>\\\";\\n  }\\n  return innerSerialize(value, handleSerializer, visitorInfo);\\n}\\nfunction innerSerialize(value, handleSerializer, visitorInfo) {\\n  var _a;\\n  const result = handleSerializer(value);\\n  if (\\\"fallThrough\\\" in result)\\n    value = result.fallThrough;\\n  else\\n    return result;\\n  if (typeof value === \\\"symbol\\\")\\n    return { v: \\\"undefined\\\" };\\n  if (Object.is(value, void 0))\\n    return { v: \\\"undefined\\\" };\\n  if (Object.is(value, null))\\n    return { v: \\\"null\\\" };\\n  if (Object.is(value, NaN))\\n    return { v: \\\"NaN\\\" };\\n  if (Object.is(value, Infinity))\\n    return { v: \\\"Infinity\\\" };\\n  if (Object.is(value, -Infinity))\\n    return { v: \\\"-Infinity\\\" };\\n  if (Object.is(value, -0))\\n    return { v: \\\"-0\\\" };\\n  if (typeof value === \\\"boolean\\\")\\n    return value;\\n  if (typeof value === \\\"number\\\")\\n    return value;\\n  if (typeof value === \\\"string\\\")\\n    return value;\\n  if (typeof value === \\\"bigint\\\")\\n    return { bi: value.toString() };\\n  if (isError(value)) {\\n    let stack;\\n    if ((_a = value.stack) == null ? void 0 : _a.startsWith(value.name + \\\": \\\" + value.message)) {\\n      stack = value.stack;\\n    } else {\\n      stack = `${value.name}: ${value.message}\\n${value.stack}`;\\n    }\\n    return { e: { n: value.name, m: value.message, s: stack } };\\n  }\\n  if (isDate(value))\\n    return { d: value.toJSON() };\\n  if (isURL(value))\\n    return { u: value.toJSON() };\\n  if (isRegExp(value))\\n    return { r: { p: value.source, f: value.flags } };\\n  for (const [k, ctor] of Object.entries(typedArrayConstructors)) {\\n    if (isTypedArray(value, ctor))\\n      return { ta: { b: typedArrayToBase64(value), k } };\\n  }\\n  const id = visitorInfo.visited.get(value);\\n  if (id)\\n    return { ref: id };\\n  if (Array.isArray(value)) {\\n    const a = [];\\n    const id2 = ++visitorInfo.lastId;\\n    visitorInfo.visited.set(value, id2);\\n    for (let i = 0; i < value.length; ++i)\\n      a.push(serialize(value[i], handleSerializer, visitorInfo));\\n    return { a, id: id2 };\\n  }\\n  if (typeof value === \\\"object\\\") {\\n    const o = [];\\n    const id2 = ++visitorInfo.lastId;\\n    visitorInfo.visited.set(value, id2);\\n    for (const name of Object.keys(value)) {\\n      let item;\\n      try {\\n        item = value[name];\\n      } catch (e) {\\n        continue;\\n      }\\n      if (name === \\\"toJSON\\\" && typeof item === \\\"function\\\")\\n        o.push({ k: name, v: { o: [], id: 0 } });\\n      else\\n        o.push({ k: name, v: serialize(item, handleSerializer, visitorInfo) });\\n    }\\n    let jsonWrapper;\\n    try {\\n      if (o.length === 0 && value.toJSON && typeof value.toJSON === \\\"function\\\")\\n        jsonWrapper = { value: value.toJSON() };\\n    } catch (e) {\\n    }\\n    if (jsonWrapper)\\n      return innerSerialize(jsonWrapper.value, handleSerializer, visitorInfo);\\n    return { o, id: id2 };\\n  }\\n}\\n\\n// packages/playwright-injected/src/bindingsController.ts\\nvar BindingsController = class {\\n  constructor(global, globalBindingName) {\\n    this._bindings = /* @__PURE__ */ new Map();\\n    this._global = global;\\n    this._globalBindingName = globalBindingName;\\n  }\\n  addBinding(bindingName, needsHandle) {\\n    const data = {\\n      callbacks: /* @__PURE__ */ new Map(),\\n      lastSeq: 0,\\n      handles: /* @__PURE__ */ new Map(),\\n      removed: false\\n    };\\n    this._bindings.set(bindingName, data);\\n    this._global[bindingName] = (...args) => {\\n      if (data.removed)\\n        throw new Error(`binding \\\"${bindingName}\\\" has been removed`);\\n      if (needsHandle && args.slice(1).some((arg) => arg !== void 0))\\n        throw new Error(`exposeBindingHandle supports a single argument, ${args.length} received`);\\n      const seq = ++data.lastSeq;\\n      const promise = new Promise((resolve, reject) => data.callbacks.set(seq, { resolve, reject }));\\n      let payload;\\n      if (needsHandle) {\\n        data.handles.set(seq, args[0]);\\n        payload = { name: bindingName, seq };\\n      } else {\\n        const serializedArgs = [];\\n        for (let i = 0; i < args.length; i++) {\\n          serializedArgs[i] = serializeAsCallArgument(args[i], (v) => {\\n            return { fallThrough: v };\\n          });\\n        }\\n        payload = { name: bindingName, seq, serializedArgs };\\n      }\\n      this._global[this._globalBindingName](JSON.stringify(payload));\\n      return promise;\\n    };\\n  }\\n  removeBinding(bindingName) {\\n    const data = this._bindings.get(bindingName);\\n    if (data)\\n      data.removed = true;\\n    this._bindings.delete(bindingName);\\n    delete this._global[bindingName];\\n  }\\n  takeBindingHandle(arg) {\\n    const handles = this._bindings.get(arg.name).handles;\\n    const handle = handles.get(arg.seq);\\n    handles.delete(arg.seq);\\n    return handle;\\n  }\\n  deliverBindingResult(arg) {\\n    const callbacks = this._bindings.get(arg.name).callbacks;\\n    if (\\\"error\\\" in arg)\\n      callbacks.get(arg.seq).reject(arg.error);\\n    else\\n      callbacks.get(arg.seq).resolve(arg.result);\\n    callbacks.delete(arg.seq);\\n  }\\n};\\n\";\n//# sourceMappingURL=bindingsControllerSource.d.ts.map",
      "generated/clockSource.d.ts": "export declare const source = \"\\nvar __commonJS = obj => {\\n  let required = false;\\n  let result;\\n  return function __require() {\\n    if (!required) {\\n      required = true;\\n      let fn;\\n      for (const name in obj) { fn = obj[name]; break; }\\n      const module = { exports: {} };\\n      fn(module.exports, module);\\n      result = module.exports;\\n    }\\n    return result;\\n  }\\n};\\nvar __export = (target, all) => {for (var name in all) target[name] = all[name];};\\nvar __toESM = mod => ({ ...mod, 'default': mod });\\nvar __toCommonJS = mod => ({ ...mod, __esModule: true });\\n\\n\\n// packages/playwright-injected/src/clock.ts\\nvar clock_exports = {};\\n__export(clock_exports, {\\n  ClockController: () => ClockController,\\n  createClock: () => createClock,\\n  inject: () => inject,\\n  install: () => install\\n});\\nmodule.exports = __toCommonJS(clock_exports);\\nvar ClockController = class {\\n  constructor(embedder) {\\n    this._duringTick = false;\\n    this._uniqueTimerId = idCounterStart;\\n    this.disposables = [];\\n    this._log = [];\\n    this._timers = /* @__PURE__ */ new Map();\\n    this._now = { time: asWallTime(0), isFixedTime: false, ticks: 0, origin: asWallTime(-1) };\\n    this._embedder = embedder;\\n  }\\n  uninstall() {\\n    this.disposables.forEach((dispose) => dispose());\\n    this.disposables.length = 0;\\n  }\\n  now() {\\n    this._replayLogOnce();\\n    this._syncRealTime();\\n    return this._now.time;\\n  }\\n  install(time) {\\n    this._replayLogOnce();\\n    this._innerSetTime(asWallTime(time));\\n  }\\n  setSystemTime(time) {\\n    this._replayLogOnce();\\n    this._innerSetTime(asWallTime(time));\\n  }\\n  setFixedTime(time) {\\n    this._replayLogOnce();\\n    this._innerSetFixedTime(asWallTime(time));\\n  }\\n  performanceNow() {\\n    this._replayLogOnce();\\n    this._syncRealTime();\\n    return this._now.ticks;\\n  }\\n  _syncRealTime() {\\n    if (!this._realTime)\\n      return;\\n    const now = this._embedder.performanceNow();\\n    const sinceLastSync = now - this._realTime.lastSyncTicks;\\n    if (sinceLastSync > 0) {\\n      this._advanceNow(shiftTicks(this._now.ticks, sinceLastSync));\\n      this._realTime.lastSyncTicks = now;\\n    }\\n  }\\n  _innerSetTime(time) {\\n    this._now.time = time;\\n    this._now.isFixedTime = false;\\n    if (this._now.origin < 0)\\n      this._now.origin = this._now.time;\\n  }\\n  _innerSetFixedTime(time) {\\n    this._innerSetTime(time);\\n    this._now.isFixedTime = true;\\n  }\\n  _advanceNow(to) {\\n    if (this._now.ticks > to) {\\n      return;\\n    }\\n    if (!this._now.isFixedTime)\\n      this._now.time = asWallTime(this._now.time + to - this._now.ticks);\\n    this._now.ticks = to;\\n  }\\n  async log(type, time, param) {\\n    this._log.push({ type, time, param });\\n  }\\n  async runFor(ticks) {\\n    this._replayLogOnce();\\n    if (ticks < 0)\\n      throw new TypeError(\\\"Negative ticks are not supported\\\");\\n    await this._runWithDisabledRealTimeSync(async () => {\\n      await this._runTo(shiftTicks(this._now.ticks, ticks));\\n    });\\n  }\\n  async _runTo(to) {\\n    to = Math.ceil(to);\\n    if (this._now.ticks > to)\\n      return;\\n    let firstException;\\n    while (true) {\\n      const result = await this._callFirstTimer(to);\\n      if (!result.timerFound)\\n        break;\\n      firstException = firstException || result.error;\\n    }\\n    this._advanceNow(to);\\n    if (firstException)\\n      throw firstException;\\n  }\\n  async pauseAt(time) {\\n    this._replayLogOnce();\\n    await this._innerPause();\\n    const toConsume = time - this._now.time;\\n    await this._innerFastForwardTo(shiftTicks(this._now.ticks, toConsume));\\n    return toConsume;\\n  }\\n  async _innerPause() {\\n    var _a;\\n    this._realTime = void 0;\\n    await ((_a = this._currentRealTimeTimer) == null ? void 0 : _a.dispose());\\n    this._currentRealTimeTimer = void 0;\\n  }\\n  resume() {\\n    this._replayLogOnce();\\n    this._innerResume();\\n  }\\n  _innerResume() {\\n    const now = this._embedder.performanceNow();\\n    this._realTime = { startTicks: now, lastSyncTicks: now };\\n    this._updateRealTimeTimer();\\n  }\\n  _updateRealTimeTimer() {\\n    var _a;\\n    if ((_a = this._currentRealTimeTimer) == null ? void 0 : _a.promise) {\\n      return;\\n    }\\n    const firstTimer = this._firstTimer();\\n    const nextTick = Math.min(firstTimer ? firstTimer.callAt : this._now.ticks + maxTimeout, this._now.ticks + 100);\\n    const callAt = this._currentRealTimeTimer ? Math.min(this._currentRealTimeTimer.callAt, nextTick) : nextTick;\\n    if (this._currentRealTimeTimer) {\\n      this._currentRealTimeTimer.cancel();\\n      this._currentRealTimeTimer = void 0;\\n    }\\n    const realTimeTimer = {\\n      callAt,\\n      promise: void 0,\\n      cancel: this._embedder.setTimeout(() => {\\n        this._syncRealTime();\\n        realTimeTimer.promise = this._runTo(this._now.ticks).catch((e) => console.error(e));\\n        void realTimeTimer.promise.then(() => {\\n          this._currentRealTimeTimer = void 0;\\n          if (this._realTime)\\n            this._updateRealTimeTimer();\\n        });\\n      }, callAt - this._now.ticks),\\n      dispose: async () => {\\n        realTimeTimer.cancel();\\n        await realTimeTimer.promise;\\n      }\\n    };\\n    this._currentRealTimeTimer = realTimeTimer;\\n  }\\n  async _runWithDisabledRealTimeSync(fn) {\\n    if (!this._realTime) {\\n      await fn();\\n      return;\\n    }\\n    await this._innerPause();\\n    try {\\n      await fn();\\n    } finally {\\n      this._innerResume();\\n    }\\n  }\\n  async fastForward(ticks) {\\n    this._replayLogOnce();\\n    await this._runWithDisabledRealTimeSync(async () => {\\n      await this._innerFastForwardTo(shiftTicks(this._now.ticks, ticks | 0));\\n    });\\n  }\\n  async _innerFastForwardTo(to) {\\n    if (to < this._now.ticks)\\n      throw new Error(\\\"Cannot fast-forward to the past\\\");\\n    for (const timer of this._timers.values()) {\\n      if (to > timer.callAt)\\n        timer.callAt = to;\\n    }\\n    await this._runTo(to);\\n  }\\n  addTimer(options) {\\n    this._replayLogOnce();\\n    if (options.type === \\\"AnimationFrame\\\" /* AnimationFrame */ && !options.func)\\n      throw new Error(\\\"Callback must be provided to requestAnimationFrame calls\\\");\\n    if (options.type === \\\"IdleCallback\\\" /* IdleCallback */ && !options.func)\\n      throw new Error(\\\"Callback must be provided to requestIdleCallback calls\\\");\\n    if ([\\\"Timeout\\\" /* Timeout */, \\\"Interval\\\" /* Interval */].includes(options.type) && !options.func && options.delay === void 0)\\n      throw new Error(\\\"Callback must be provided to timer calls\\\");\\n    let delay = options.delay ? +options.delay : 0;\\n    if (!Number.isFinite(delay))\\n      delay = 0;\\n    delay = delay > maxTimeout ? 1 : delay;\\n    delay = Math.max(0, delay);\\n    const timer = {\\n      type: options.type,\\n      func: options.func,\\n      args: options.args || [],\\n      delay,\\n      callAt: shiftTicks(this._now.ticks, delay || (this._duringTick ? 1 : 0)),\\n      createdAt: this._now.ticks,\\n      id: this._uniqueTimerId++,\\n      error: new Error()\\n    };\\n    this._timers.set(timer.id, timer);\\n    if (this._realTime)\\n      this._updateRealTimeTimer();\\n    return timer.id;\\n  }\\n  countTimers() {\\n    return this._timers.size;\\n  }\\n  _firstTimer(beforeTick) {\\n    let firstTimer = null;\\n    for (const timer of this._timers.values()) {\\n      const isInRange = beforeTick === void 0 || timer.callAt <= beforeTick;\\n      if (isInRange && (!firstTimer || compareTimers(firstTimer, timer) === 1))\\n        firstTimer = timer;\\n    }\\n    return firstTimer;\\n  }\\n  _takeFirstTimer(beforeTick) {\\n    const timer = this._firstTimer(beforeTick);\\n    if (!timer)\\n      return null;\\n    this._advanceNow(timer.callAt);\\n    if (timer.type === \\\"Interval\\\" /* Interval */)\\n      timer.callAt = shiftTicks(timer.callAt, timer.delay);\\n    else\\n      this._timers.delete(timer.id);\\n    return timer;\\n  }\\n  async _callFirstTimer(beforeTick) {\\n    const timer = this._takeFirstTimer(beforeTick);\\n    if (!timer)\\n      return { timerFound: false };\\n    this._duringTick = true;\\n    try {\\n      if (typeof timer.func !== \\\"function\\\") {\\n        let error2;\\n        try {\\n          (() => {\\n            globalThis.eval(timer.func);\\n          })();\\n        } catch (e) {\\n          error2 = e;\\n        }\\n        await new Promise((f) => this._embedder.setTimeout(f));\\n        return { timerFound: true, error: error2 };\\n      }\\n      let args = timer.args;\\n      if (timer.type === \\\"AnimationFrame\\\" /* AnimationFrame */)\\n        args = [this._now.ticks];\\n      else if (timer.type === \\\"IdleCallback\\\" /* IdleCallback */)\\n        args = [{ didTimeout: false, timeRemaining: () => 0 }];\\n      let error;\\n      try {\\n        timer.func.apply(null, args);\\n      } catch (e) {\\n        error = e;\\n      }\\n      await new Promise((f) => this._embedder.setTimeout(f));\\n      return { timerFound: true, error };\\n    } finally {\\n      this._duringTick = false;\\n    }\\n  }\\n  getTimeToNextFrame() {\\n    this._replayLogOnce();\\n    return 16 - this._now.ticks % 16;\\n  }\\n  clearTimer(timerId, type) {\\n    this._replayLogOnce();\\n    if (!timerId) {\\n      return;\\n    }\\n    const id = Number(timerId);\\n    if (Number.isNaN(id) || id < idCounterStart) {\\n      const handlerName = getClearHandler(type);\\n      new Error(`Clock: ${handlerName} was invoked to clear a native timer instead of one created by the clock library.`);\\n    }\\n    const timer = this._timers.get(id);\\n    if (timer) {\\n      if (timer.type === type || timer.type === \\\"Timeout\\\" && type === \\\"Interval\\\" || timer.type === \\\"Interval\\\" && type === \\\"Timeout\\\") {\\n        this._timers.delete(id);\\n      } else {\\n        const clear = getClearHandler(type);\\n        const schedule = getScheduleHandler(timer.type);\\n        throw new Error(\\n          `Cannot clear timer: timer created with ${schedule}() but cleared with ${clear}()`\\n        );\\n      }\\n    }\\n  }\\n  _replayLogOnce() {\\n    if (!this._log.length)\\n      return;\\n    let lastLogTime = -1;\\n    let isPaused = false;\\n    for (const { type, time, param } of this._log) {\\n      if (!isPaused && lastLogTime !== -1)\\n        this._advanceNow(shiftTicks(this._now.ticks, time - lastLogTime));\\n      lastLogTime = time;\\n      if (type === \\\"install\\\") {\\n        this._innerSetTime(asWallTime(param));\\n      } else if (type === \\\"fastForward\\\" || type === \\\"runFor\\\") {\\n        this._advanceNow(shiftTicks(this._now.ticks, param));\\n      } else if (type === \\\"pauseAt\\\") {\\n        isPaused = true;\\n        this._innerSetTime(asWallTime(param));\\n      } else if (type === \\\"resume\\\") {\\n        isPaused = false;\\n      } else if (type === \\\"setFixedTime\\\") {\\n        this._innerSetFixedTime(asWallTime(param));\\n      } else if (type === \\\"setSystemTime\\\") {\\n        this._innerSetTime(asWallTime(param));\\n      }\\n    }\\n    if (!isPaused) {\\n      if (lastLogTime > 0)\\n        this._advanceNow(shiftTicks(this._now.ticks, this._embedder.dateNow() - lastLogTime));\\n      this._innerResume();\\n    } else {\\n      this._realTime = void 0;\\n    }\\n    this._log.length = 0;\\n  }\\n};\\nfunction mirrorDateProperties(target, source) {\\n  for (const prop in source) {\\n    if (source.hasOwnProperty(prop))\\n      target[prop] = source[prop];\\n  }\\n  target.toString = () => source.toString();\\n  target.prototype = source.prototype;\\n  target.parse = source.parse;\\n  target.UTC = source.UTC;\\n  target.prototype.toUTCString = source.prototype.toUTCString;\\n  target.isFake = true;\\n  return target;\\n}\\nfunction createDate(clock, NativeDate) {\\n  function ClockDate(year, month, date, hour, minute, second, ms) {\\n    if (!(this instanceof ClockDate))\\n      return new NativeDate(clock.now()).toString();\\n    switch (arguments.length) {\\n      case 0:\\n        return new NativeDate(clock.now());\\n      case 1:\\n        return new NativeDate(year);\\n      case 2:\\n        return new NativeDate(year, month);\\n      case 3:\\n        return new NativeDate(year, month, date);\\n      case 4:\\n        return new NativeDate(year, month, date, hour);\\n      case 5:\\n        return new NativeDate(year, month, date, hour, minute);\\n      case 6:\\n        return new NativeDate(\\n          year,\\n          month,\\n          date,\\n          hour,\\n          minute,\\n          second\\n        );\\n      default:\\n        return new NativeDate(\\n          year,\\n          month,\\n          date,\\n          hour,\\n          minute,\\n          second,\\n          ms\\n        );\\n    }\\n  }\\n  ClockDate.now = () => clock.now();\\n  return mirrorDateProperties(ClockDate, NativeDate);\\n}\\nfunction createIntl(clock, NativeIntl) {\\n  const ClockIntl = {};\\n  for (const key of Object.getOwnPropertyNames(NativeIntl))\\n    ClockIntl[key] = NativeIntl[key];\\n  ClockIntl.DateTimeFormat = function(...args) {\\n    const realFormatter = new NativeIntl.DateTimeFormat(...args);\\n    const formatter = {\\n      formatRange: realFormatter.formatRange.bind(realFormatter),\\n      formatRangeToParts: realFormatter.formatRangeToParts.bind(realFormatter),\\n      resolvedOptions: realFormatter.resolvedOptions.bind(realFormatter),\\n      format: (date) => realFormatter.format(date || clock.now()),\\n      formatToParts: (date) => realFormatter.formatToParts(date || clock.now())\\n    };\\n    return formatter;\\n  };\\n  ClockIntl.DateTimeFormat.prototype = Object.create(\\n    NativeIntl.DateTimeFormat.prototype\\n  );\\n  ClockIntl.DateTimeFormat.supportedLocalesOf = NativeIntl.DateTimeFormat.supportedLocalesOf;\\n  return ClockIntl;\\n}\\nfunction compareTimers(a, b) {\\n  if (a.callAt < b.callAt)\\n    return -1;\\n  if (a.callAt > b.callAt)\\n    return 1;\\n  if (a.type === \\\"Immediate\\\" /* Immediate */ && b.type !== \\\"Immediate\\\" /* Immediate */)\\n    return -1;\\n  if (a.type !== \\\"Immediate\\\" /* Immediate */ && b.type === \\\"Immediate\\\" /* Immediate */)\\n    return 1;\\n  if (a.createdAt < b.createdAt)\\n    return -1;\\n  if (a.createdAt > b.createdAt)\\n    return 1;\\n  if (a.id < b.id)\\n    return -1;\\n  if (a.id > b.id)\\n    return 1;\\n}\\nvar maxTimeout = Math.pow(2, 31) - 1;\\nvar idCounterStart = 1e12;\\nfunction platformOriginals(globalObject) {\\n  const raw = {\\n    setTimeout: globalObject.setTimeout,\\n    clearTimeout: globalObject.clearTimeout,\\n    setInterval: globalObject.setInterval,\\n    clearInterval: globalObject.clearInterval,\\n    requestAnimationFrame: globalObject.requestAnimationFrame ? globalObject.requestAnimationFrame : void 0,\\n    cancelAnimationFrame: globalObject.cancelAnimationFrame ? globalObject.cancelAnimationFrame : void 0,\\n    requestIdleCallback: globalObject.requestIdleCallback ? globalObject.requestIdleCallback : void 0,\\n    cancelIdleCallback: globalObject.cancelIdleCallback ? globalObject.cancelIdleCallback : void 0,\\n    Date: globalObject.Date,\\n    performance: globalObject.performance,\\n    Intl: globalObject.Intl\\n  };\\n  const bound = { ...raw };\\n  for (const key of Object.keys(bound)) {\\n    if (key !== \\\"Date\\\" && typeof bound[key] === \\\"function\\\")\\n      bound[key] = bound[key].bind(globalObject);\\n  }\\n  return { raw, bound };\\n}\\nfunction getScheduleHandler(type) {\\n  if (type === \\\"IdleCallback\\\" || type === \\\"AnimationFrame\\\")\\n    return `request${type}`;\\n  return `set${type}`;\\n}\\nfunction createApi(clock, originals) {\\n  return {\\n    setTimeout: (func, timeout, ...args) => {\\n      const delay = timeout ? +timeout : timeout;\\n      return clock.addTimer({\\n        type: \\\"Timeout\\\" /* Timeout */,\\n        func,\\n        args,\\n        delay\\n      });\\n    },\\n    clearTimeout: (timerId) => {\\n      if (timerId)\\n        clock.clearTimer(timerId, \\\"Timeout\\\" /* Timeout */);\\n    },\\n    setInterval: (func, timeout, ...args) => {\\n      const delay = timeout ? +timeout : timeout;\\n      return clock.addTimer({\\n        type: \\\"Interval\\\" /* Interval */,\\n        func,\\n        args,\\n        delay\\n      });\\n    },\\n    clearInterval: (timerId) => {\\n      if (timerId)\\n        return clock.clearTimer(timerId, \\\"Interval\\\" /* Interval */);\\n    },\\n    requestAnimationFrame: (callback) => {\\n      return clock.addTimer({\\n        type: \\\"AnimationFrame\\\" /* AnimationFrame */,\\n        func: callback,\\n        delay: clock.getTimeToNextFrame()\\n      });\\n    },\\n    cancelAnimationFrame: (timerId) => {\\n      if (timerId)\\n        return clock.clearTimer(timerId, \\\"AnimationFrame\\\" /* AnimationFrame */);\\n    },\\n    requestIdleCallback: (callback, options) => {\\n      let timeToNextIdlePeriod = 0;\\n      if (clock.countTimers() > 0)\\n        timeToNextIdlePeriod = 50;\\n      return clock.addTimer({\\n        type: \\\"IdleCallback\\\" /* IdleCallback */,\\n        func: callback,\\n        delay: (options == null ? void 0 : options.timeout) ? Math.min(options == null ? void 0 : options.timeout, timeToNextIdlePeriod) : timeToNextIdlePeriod\\n      });\\n    },\\n    cancelIdleCallback: (timerId) => {\\n      if (timerId)\\n        return clock.clearTimer(timerId, \\\"IdleCallback\\\" /* IdleCallback */);\\n    },\\n    Intl: originals.Intl ? createIntl(clock, originals.Intl) : void 0,\\n    Date: createDate(clock, originals.Date),\\n    performance: originals.performance ? fakePerformance(clock, originals.performance) : void 0\\n  };\\n}\\nfunction getClearHandler(type) {\\n  if (type === \\\"IdleCallback\\\" || type === \\\"AnimationFrame\\\")\\n    return `cancel${type}`;\\n  return `clear${type}`;\\n}\\nfunction fakePerformance(clock, performance) {\\n  const result = {\\n    now: () => clock.performanceNow()\\n  };\\n  result.__defineGetter__(\\\"timeOrigin\\\", () => clock._now.origin || 0);\\n  for (const key of Object.keys(performance.__proto__)) {\\n    if (key === \\\"now\\\" || key === \\\"timeOrigin\\\")\\n      continue;\\n    if (key === \\\"getEntries\\\" || key === \\\"getEntriesByName\\\" || key === \\\"getEntriesByType\\\")\\n      result[key] = () => [];\\n    else\\n      result[key] = () => {\\n      };\\n  }\\n  return result;\\n}\\nfunction createClock(globalObject) {\\n  const originals = platformOriginals(globalObject);\\n  const embedder = {\\n    dateNow: () => originals.raw.Date.now(),\\n    performanceNow: () => Math.ceil(originals.raw.performance.now()),\\n    setTimeout: (task, timeout) => {\\n      const timerId = originals.bound.setTimeout(task, timeout);\\n      return () => originals.bound.clearTimeout(timerId);\\n    },\\n    setInterval: (task, delay) => {\\n      const intervalId = originals.bound.setInterval(task, delay);\\n      return () => originals.bound.clearInterval(intervalId);\\n    }\\n  };\\n  const clock = new ClockController(embedder);\\n  const api = createApi(clock, originals.bound);\\n  return { clock, api, originals: originals.raw };\\n}\\nfunction install(globalObject, config = {}) {\\n  var _a, _b;\\n  if ((_a = globalObject.Date) == null ? void 0 : _a.isFake) {\\n    throw new TypeError(`Can't install fake timers twice on the same global object.`);\\n  }\\n  const { clock, api, originals } = createClock(globalObject);\\n  const toFake = ((_b = config.toFake) == null ? void 0 : _b.length) ? config.toFake : Object.keys(originals);\\n  for (const method of toFake) {\\n    if (method === \\\"Date\\\") {\\n      globalObject.Date = mirrorDateProperties(api.Date, globalObject.Date);\\n    } else if (method === \\\"Intl\\\") {\\n      globalObject.Intl = api[method];\\n    } else if (method === \\\"performance\\\") {\\n      globalObject.performance = api[method];\\n      const kEventTimeStamp = /* @__PURE__ */ Symbol(\\\"playwrightEventTimeStamp\\\");\\n      Object.defineProperty(Event.prototype, \\\"timeStamp\\\", {\\n        get() {\\n          var _a2;\\n          if (!this[kEventTimeStamp])\\n            this[kEventTimeStamp] = (_a2 = api.performance) == null ? void 0 : _a2.now();\\n          return this[kEventTimeStamp];\\n        }\\n      });\\n    } else {\\n      globalObject[method] = (...args) => {\\n        return api[method].apply(api, args);\\n      };\\n    }\\n    clock.disposables.push(() => {\\n      globalObject[method] = originals[method];\\n    });\\n  }\\n  return { clock, api, originals };\\n}\\nfunction inject(globalObject) {\\n  const builtins = platformOriginals(globalObject).bound;\\n  const { clock: controller } = install(globalObject);\\n  controller.resume();\\n  return {\\n    controller,\\n    builtins\\n  };\\n}\\nfunction asWallTime(n) {\\n  return n;\\n}\\nfunction shiftTicks(ticks, ms) {\\n  return ticks + ms;\\n}\\n\";\n//# sourceMappingURL=clockSource.d.ts.map",
      "generated/injectedScriptSource.d.ts": "export declare const source = \"\\nvar __commonJS = obj => {\\n  let required = false;\\n  let result;\\n  return function __require() {\\n    if (!required) {\\n      required = true;\\n      let fn;\\n      for (const name in obj) { fn = obj[name]; break; }\\n      const module = { exports: {} };\\n      fn(module.exports, module);\\n      result = module.exports;\\n    }\\n    return result;\\n  }\\n};\\nvar __export = (target, all) => {for (var name in all) target[name] = all[name];};\\nvar __toESM = mod => ({ ...mod, 'default': mod });\\nvar __toCommonJS = mod => ({ ...mod, __esModule: true });\\n\\n\\n// packages/playwright-injected/src/injectedScript.ts\\nvar injectedScript_exports = {};\\n__export(injectedScript_exports, {\\n  InjectedScript: () => InjectedScript\\n});\\nmodule.exports = __toCommonJS(injectedScript_exports);\\n\\n// packages/playwright-core/src/utils/isomorphic/ariaSnapshot.ts\\nfunction ariaPropsEqual(a, b) {\\n  return a.active === b.active && a.checked === b.checked && a.disabled === b.disabled && a.expanded === b.expanded && a.selected === b.selected && a.level === b.level && a.pressed === b.pressed;\\n}\\nfunction parseAriaSnapshot(yaml, text, options = {}) {\\n  var _a;\\n  const lineCounter = new yaml.LineCounter();\\n  const parseOptions = {\\n    keepSourceTokens: true,\\n    lineCounter,\\n    ...options\\n  };\\n  const yamlDoc = yaml.parseDocument(text, parseOptions);\\n  const errors = [];\\n  const convertRange = (range) => {\\n    return [lineCounter.linePos(range[0]), lineCounter.linePos(range[1])];\\n  };\\n  const addError = (error) => {\\n    errors.push({\\n      message: error.message,\\n      range: [lineCounter.linePos(error.pos[0]), lineCounter.linePos(error.pos[1])]\\n    });\\n  };\\n  const convertSeq = (container, seq) => {\\n    for (const item of seq.items) {\\n      const itemIsString = item instanceof yaml.Scalar && typeof item.value === \\\"string\\\";\\n      if (itemIsString) {\\n        const childNode = KeyParser.parse(item, parseOptions, errors);\\n        if (childNode) {\\n          container.children = container.children || [];\\n          container.children.push(childNode);\\n        }\\n        continue;\\n      }\\n      const itemIsMap = item instanceof yaml.YAMLMap;\\n      if (itemIsMap) {\\n        convertMap(container, item);\\n        continue;\\n      }\\n      errors.push({\\n        message: \\\"Sequence items should be strings or maps\\\",\\n        range: convertRange(item.range || seq.range)\\n      });\\n    }\\n  };\\n  const convertMap = (container, map) => {\\n    var _a2;\\n    for (const entry of map.items) {\\n      container.children = container.children || [];\\n      const keyIsString = entry.key instanceof yaml.Scalar && typeof entry.key.value === \\\"string\\\";\\n      if (!keyIsString) {\\n        errors.push({\\n          message: \\\"Only string keys are supported\\\",\\n          range: convertRange(entry.key.range || map.range)\\n        });\\n        continue;\\n      }\\n      const key = entry.key;\\n      const value = entry.value;\\n      if (key.value === \\\"text\\\") {\\n        const valueIsString = value instanceof yaml.Scalar && typeof value.value === \\\"string\\\";\\n        if (!valueIsString) {\\n          errors.push({\\n            message: \\\"Text value should be a string\\\",\\n            range: convertRange(entry.value.range || map.range)\\n          });\\n          continue;\\n        }\\n        container.children.push({\\n          kind: \\\"text\\\",\\n          text: textValue(value.value)\\n        });\\n        continue;\\n      }\\n      if (key.value === \\\"/children\\\") {\\n        const valueIsString = value instanceof yaml.Scalar && typeof value.value === \\\"string\\\";\\n        if (!valueIsString || value.value !== \\\"contain\\\" && value.value !== \\\"equal\\\" && value.value !== \\\"deep-equal\\\") {\\n          errors.push({\\n            message: 'Strict value should be \\\"contain\\\", \\\"equal\\\" or \\\"deep-equal\\\"',\\n            range: convertRange(entry.value.range || map.range)\\n          });\\n          continue;\\n        }\\n        container.containerMode = value.value;\\n        continue;\\n      }\\n      if (key.value.startsWith(\\\"/\\\")) {\\n        const valueIsString = value instanceof yaml.Scalar && typeof value.value === \\\"string\\\";\\n        if (!valueIsString) {\\n          errors.push({\\n            message: \\\"Property value should be a string\\\",\\n            range: convertRange(entry.value.range || map.range)\\n          });\\n          continue;\\n        }\\n        container.props = (_a2 = container.props) != null ? _a2 : {};\\n        container.props[key.value.slice(1)] = textValue(value.value);\\n        continue;\\n      }\\n      const childNode = KeyParser.parse(key, parseOptions, errors);\\n      if (!childNode)\\n        continue;\\n      const valueIsScalar = value instanceof yaml.Scalar;\\n      if (valueIsScalar) {\\n        const type = typeof value.value;\\n        if (type !== \\\"string\\\" && type !== \\\"number\\\" && type !== \\\"boolean\\\") {\\n          errors.push({\\n            message: \\\"Node value should be a string or a sequence\\\",\\n            range: convertRange(entry.value.range || map.range)\\n          });\\n          continue;\\n        }\\n        container.children.push({\\n          ...childNode,\\n          children: [{\\n            kind: \\\"text\\\",\\n            text: textValue(String(value.value))\\n          }]\\n        });\\n        continue;\\n      }\\n      const valueIsSequence = value instanceof yaml.YAMLSeq;\\n      if (valueIsSequence) {\\n        container.children.push(childNode);\\n        convertSeq(childNode, value);\\n        continue;\\n      }\\n      errors.push({\\n        message: \\\"Map values should be strings or sequences\\\",\\n        range: convertRange(entry.value.range || map.range)\\n      });\\n    }\\n  };\\n  const fragment = { kind: \\\"role\\\", role: \\\"fragment\\\" };\\n  yamlDoc.errors.forEach(addError);\\n  if (errors.length)\\n    return { errors, fragment };\\n  if (!(yamlDoc.contents instanceof yaml.YAMLSeq)) {\\n    errors.push({\\n      message: 'Aria snapshot must be a YAML sequence, elements starting with \\\" -\\\"',\\n      range: yamlDoc.contents ? convertRange(yamlDoc.contents.range) : [{ line: 0, col: 0 }, { line: 0, col: 0 }]\\n    });\\n  }\\n  if (errors.length)\\n    return { errors, fragment };\\n  convertSeq(fragment, yamlDoc.contents);\\n  if (errors.length)\\n    return { errors, fragment: emptyFragment };\\n  if (((_a = fragment.children) == null ? void 0 : _a.length) === 1 && (!fragment.containerMode || fragment.containerMode === \\\"contain\\\"))\\n    return { fragment: fragment.children[0], errors: [] };\\n  return { fragment, errors: [] };\\n}\\nvar emptyFragment = { kind: \\\"role\\\", role: \\\"fragment\\\" };\\nfunction normalizeWhitespace(text) {\\n  return text.replace(/[\\\\u200b\\\\u00ad]/g, \\\"\\\").replace(/[\\\\r\\\\n\\\\s\\\\t]+/g, \\\" \\\").trim();\\n}\\nfunction textValue(value) {\\n  return {\\n    raw: value,\\n    normalized: normalizeWhitespace(value)\\n  };\\n}\\nvar KeyParser = class _KeyParser {\\n  static parse(text, options, errors) {\\n    try {\\n      return new _KeyParser(text.value)._parse();\\n    } catch (e) {\\n      if (e instanceof ParserError) {\\n        const message = options.prettyErrors === false ? e.message : e.message + \\\":\\\\n\\\\n\\\" + text.value + \\\"\\\\n\\\" + \\\" \\\".repeat(e.pos) + \\\"^\\\\n\\\";\\n        errors.push({\\n          message,\\n          range: [options.lineCounter.linePos(text.range[0]), options.lineCounter.linePos(text.range[0] + e.pos)]\\n        });\\n        return null;\\n      }\\n      throw e;\\n    }\\n  }\\n  constructor(input) {\\n    this._input = input;\\n    this._pos = 0;\\n    this._length = input.length;\\n  }\\n  _peek() {\\n    return this._input[this._pos] || \\\"\\\";\\n  }\\n  _next() {\\n    if (this._pos < this._length)\\n      return this._input[this._pos++];\\n    return null;\\n  }\\n  _eof() {\\n    return this._pos >= this._length;\\n  }\\n  _isWhitespace() {\\n    return !this._eof() && /\\\\s/.test(this._peek());\\n  }\\n  _skipWhitespace() {\\n    while (this._isWhitespace())\\n      this._pos++;\\n  }\\n  _readIdentifier(type) {\\n    if (this._eof())\\n      this._throwError(`Unexpected end of input when expecting ${type}`);\\n    const start = this._pos;\\n    while (!this._eof() && /[a-zA-Z]/.test(this._peek()))\\n      this._pos++;\\n    return this._input.slice(start, this._pos);\\n  }\\n  _readString() {\\n    let result = \\\"\\\";\\n    let escaped = false;\\n    while (!this._eof()) {\\n      const ch = this._next();\\n      if (escaped) {\\n        result += ch;\\n        escaped = false;\\n      } else if (ch === \\\"\\\\\\\\\\\") {\\n        escaped = true;\\n      } else if (ch === '\\\"') {\\n        return result;\\n      } else {\\n        result += ch;\\n      }\\n    }\\n    this._throwError(\\\"Unterminated string\\\");\\n  }\\n  _throwError(message, offset = 0) {\\n    throw new ParserError(message, offset || this._pos);\\n  }\\n  _readRegex() {\\n    let result = \\\"\\\";\\n    let escaped = false;\\n    let insideClass = false;\\n    while (!this._eof()) {\\n      const ch = this._next();\\n      if (escaped) {\\n        result += ch;\\n        escaped = false;\\n      } else if (ch === \\\"\\\\\\\\\\\") {\\n        escaped = true;\\n        result += ch;\\n      } else if (ch === \\\"/\\\" && !insideClass) {\\n        return { pattern: result };\\n      } else if (ch === \\\"[\\\") {\\n        insideClass = true;\\n        result += ch;\\n      } else if (ch === \\\"]\\\" && insideClass) {\\n        result += ch;\\n        insideClass = false;\\n      } else {\\n        result += ch;\\n      }\\n    }\\n    this._throwError(\\\"Unterminated regex\\\");\\n  }\\n  _readStringOrRegex() {\\n    const ch = this._peek();\\n    if (ch === '\\\"') {\\n      this._next();\\n      return normalizeWhitespace(this._readString());\\n    }\\n    if (ch === \\\"/\\\") {\\n      this._next();\\n      return this._readRegex();\\n    }\\n    return null;\\n  }\\n  _readAttributes(result) {\\n    let errorPos = this._pos;\\n    while (true) {\\n      this._skipWhitespace();\\n      if (this._peek() === \\\"[\\\") {\\n        this._next();\\n        this._skipWhitespace();\\n        errorPos = this._pos;\\n        const flagName = this._readIdentifier(\\\"attribute\\\");\\n        this._skipWhitespace();\\n        let flagValue = \\\"\\\";\\n        if (this._peek() === \\\"=\\\") {\\n          this._next();\\n          this._skipWhitespace();\\n          errorPos = this._pos;\\n          while (this._peek() !== \\\"]\\\" && !this._isWhitespace() && !this._eof())\\n            flagValue += this._next();\\n        }\\n        this._skipWhitespace();\\n        if (this._peek() !== \\\"]\\\")\\n          this._throwError(\\\"Expected ]\\\");\\n        this._next();\\n        this._applyAttribute(result, flagName, flagValue || \\\"true\\\", errorPos);\\n      } else {\\n        break;\\n      }\\n    }\\n  }\\n  _parse() {\\n    this._skipWhitespace();\\n    const role = this._readIdentifier(\\\"role\\\");\\n    this._skipWhitespace();\\n    const name = this._readStringOrRegex() || \\\"\\\";\\n    const result = { kind: \\\"role\\\", role, name };\\n    this._readAttributes(result);\\n    this._skipWhitespace();\\n    if (!this._eof())\\n      this._throwError(\\\"Unexpected input\\\");\\n    return result;\\n  }\\n  _applyAttribute(node, key, value, errorPos) {\\n    if (key === \\\"checked\\\") {\\n      this._assert(value === \\\"true\\\" || value === \\\"false\\\" || value === \\\"mixed\\\", 'Value of \\\"checked\\\" attribute must be a boolean or \\\"mixed\\\"', errorPos);\\n      node.checked = value === \\\"true\\\" ? true : value === \\\"false\\\" ? false : \\\"mixed\\\";\\n      return;\\n    }\\n    if (key === \\\"disabled\\\") {\\n      this._assert(value === \\\"true\\\" || value === \\\"false\\\", 'Value of \\\"disabled\\\" attribute must be a boolean', errorPos);\\n      node.disabled = value === \\\"true\\\";\\n      return;\\n    }\\n    if (key === \\\"expanded\\\") {\\n      this._assert(value === \\\"true\\\" || value === \\\"false\\\", 'Value of \\\"expanded\\\" attribute must be a boolean', errorPos);\\n      node.expanded = value === \\\"true\\\";\\n      return;\\n    }\\n    if (key === \\\"active\\\") {\\n      this._assert(value === \\\"true\\\" || value === \\\"false\\\", 'Value of \\\"active\\\" attribute must be a boolean', errorPos);\\n      node.active = value === \\\"true\\\";\\n      return;\\n    }\\n    if (key === \\\"level\\\") {\\n      this._assert(!isNaN(Number(value)), 'Value of \\\"level\\\" attribute must be a number', errorPos);\\n      node.level = Number(value);\\n      return;\\n    }\\n    if (key === \\\"pressed\\\") {\\n      this._assert(value === \\\"true\\\" || value === \\\"false\\\" || value === \\\"mixed\\\", 'Value of \\\"pressed\\\" attribute must be a boolean or \\\"mixed\\\"', errorPos);\\n      node.pressed = value === \\\"true\\\" ? true : value === \\\"false\\\" ? false : \\\"mixed\\\";\\n      return;\\n    }\\n    if (key === \\\"selected\\\") {\\n      this._assert(value === \\\"true\\\" || value === \\\"false\\\", 'Value of \\\"selected\\\" attribute must be a boolean', errorPos);\\n      node.selected = value === \\\"true\\\";\\n      return;\\n    }\\n    this._assert(false, `Unsupported attribute [${key}]`, errorPos);\\n  }\\n  _assert(value, message, valuePos) {\\n    if (!value)\\n      this._throwError(message || \\\"Assertion error\\\", valuePos);\\n  }\\n};\\nvar ParserError = class extends Error {\\n  constructor(message, pos) {\\n    super(message);\\n    this.pos = pos;\\n  }\\n};\\n\\n// packages/playwright-core/src/utils/isomorphic/cssTokenizer.ts\\nvar between = function(num, first, last) {\\n  return num >= first && num <= last;\\n};\\nfunction digit(code) {\\n  return between(code, 48, 57);\\n}\\nfunction hexdigit(code) {\\n  return digit(code) || between(code, 65, 70) || between(code, 97, 102);\\n}\\nfunction uppercaseletter(code) {\\n  return between(code, 65, 90);\\n}\\nfunction lowercaseletter(code) {\\n  return between(code, 97, 122);\\n}\\nfunction letter(code) {\\n  return uppercaseletter(code) || lowercaseletter(code);\\n}\\nfunction nonascii(code) {\\n  return code >= 128;\\n}\\nfunction namestartchar(code) {\\n  return letter(code) || nonascii(code) || code === 95;\\n}\\nfunction namechar(code) {\\n  return namestartchar(code) || digit(code) || code === 45;\\n}\\nfunction nonprintable(code) {\\n  return between(code, 0, 8) || code === 11 || between(code, 14, 31) || code === 127;\\n}\\nfunction newline(code) {\\n  return code === 10;\\n}\\nfunction whitespace(code) {\\n  return newline(code) || code === 9 || code === 32;\\n}\\nvar maximumallowedcodepoint = 1114111;\\nvar InvalidCharacterError = class extends Error {\\n  constructor(message) {\\n    super(message);\\n    this.name = \\\"InvalidCharacterError\\\";\\n  }\\n};\\nfunction preprocess(str) {\\n  const codepoints = [];\\n  for (let i = 0; i < str.length; i++) {\\n    let code = str.charCodeAt(i);\\n    if (code === 13 && str.charCodeAt(i + 1) === 10) {\\n      code = 10;\\n      i++;\\n    }\\n    if (code === 13 || code === 12)\\n      code = 10;\\n    if (code === 0)\\n      code = 65533;\\n    if (between(code, 55296, 56319) && between(str.charCodeAt(i + 1), 56320, 57343)) {\\n      const lead = code - 55296;\\n      const trail = str.charCodeAt(i + 1) - 56320;\\n      code = Math.pow(2, 16) + lead * Math.pow(2, 10) + trail;\\n      i++;\\n    }\\n    codepoints.push(code);\\n  }\\n  return codepoints;\\n}\\nfunction stringFromCode(code) {\\n  if (code <= 65535)\\n    return String.fromCharCode(code);\\n  code -= Math.pow(2, 16);\\n  const lead = Math.floor(code / Math.pow(2, 10)) + 55296;\\n  const trail = code % Math.pow(2, 10) + 56320;\\n  return String.fromCharCode(lead) + String.fromCharCode(trail);\\n}\\nfunction tokenize(str1) {\\n  const str = preprocess(str1);\\n  let i = -1;\\n  const tokens = [];\\n  let code;\\n  let line = 0;\\n  let column = 0;\\n  let lastLineLength = 0;\\n  const incrLineno = function() {\\n    line += 1;\\n    lastLineLength = column;\\n    column = 0;\\n  };\\n  const locStart = { line, column };\\n  const codepoint = function(i2) {\\n    if (i2 >= str.length)\\n      return -1;\\n    return str[i2];\\n  };\\n  const next = function(num) {\\n    if (num === void 0)\\n      num = 1;\\n    if (num > 3)\\n      throw \\\"Spec Error: no more than three codepoints of lookahead.\\\";\\n    return codepoint(i + num);\\n  };\\n  const consume = function(num) {\\n    if (num === void 0)\\n      num = 1;\\n    i += num;\\n    code = codepoint(i);\\n    if (newline(code))\\n      incrLineno();\\n    else\\n      column += num;\\n    return true;\\n  };\\n  const reconsume = function() {\\n    i -= 1;\\n    if (newline(code)) {\\n      line -= 1;\\n      column = lastLineLength;\\n    } else {\\n      column -= 1;\\n    }\\n    locStart.line = line;\\n    locStart.column = column;\\n    return true;\\n  };\\n  const eof = function(codepoint2) {\\n    if (codepoint2 === void 0)\\n      codepoint2 = code;\\n    return codepoint2 === -1;\\n  };\\n  const donothing = function() {\\n  };\\n  const parseerror = function() {\\n  };\\n  const consumeAToken = function() {\\n    consumeComments();\\n    consume();\\n    if (whitespace(code)) {\\n      while (whitespace(next()))\\n        consume();\\n      return new WhitespaceToken();\\n    } else if (code === 34) {\\n      return consumeAStringToken();\\n    } else if (code === 35) {\\n      if (namechar(next()) || areAValidEscape(next(1), next(2))) {\\n        const token = new HashToken(\\\"\\\");\\n        if (wouldStartAnIdentifier(next(1), next(2), next(3)))\\n          token.type = \\\"id\\\";\\n        token.value = consumeAName();\\n        return token;\\n      } else {\\n        return new DelimToken(code);\\n      }\\n    } else if (code === 36) {\\n      if (next() === 61) {\\n        consume();\\n        return new SuffixMatchToken();\\n      } else {\\n        return new DelimToken(code);\\n      }\\n    } else if (code === 39) {\\n      return consumeAStringToken();\\n    } else if (code === 40) {\\n      return new OpenParenToken();\\n    } else if (code === 41) {\\n      return new CloseParenToken();\\n    } else if (code === 42) {\\n      if (next() === 61) {\\n        consume();\\n        return new SubstringMatchToken();\\n      } else {\\n        return new DelimToken(code);\\n      }\\n    } else if (code === 43) {\\n      if (startsWithANumber()) {\\n        reconsume();\\n        return consumeANumericToken();\\n      } else {\\n        return new DelimToken(code);\\n      }\\n    } else if (code === 44) {\\n      return new CommaToken();\\n    } else if (code === 45) {\\n      if (startsWithANumber()) {\\n        reconsume();\\n        return consumeANumericToken();\\n      } else if (next(1) === 45 && next(2) === 62) {\\n        consume(2);\\n        return new CDCToken();\\n      } else if (startsWithAnIdentifier()) {\\n        reconsume();\\n        return consumeAnIdentlikeToken();\\n      } else {\\n        return new DelimToken(code);\\n      }\\n    } else if (code === 46) {\\n      if (startsWithANumber()) {\\n        reconsume();\\n        return consumeANumericToken();\\n      } else {\\n        return new DelimToken(code);\\n      }\\n    } else if (code === 58) {\\n      return new ColonToken();\\n    } else if (code === 59) {\\n      return new SemicolonToken();\\n    } else if (code === 60) {\\n      if (next(1) === 33 && next(2) === 45 && next(3) === 45) {\\n        consume(3);\\n        return new CDOToken();\\n      } else {\\n        return new DelimToken(code);\\n      }\\n    } else if (code === 64) {\\n      if (wouldStartAnIdentifier(next(1), next(2), next(3)))\\n        return new AtKeywordToken(consumeAName());\\n      else\\n        return new DelimToken(code);\\n    } else if (code === 91) {\\n      return new OpenSquareToken();\\n    } else if (code === 92) {\\n      if (startsWithAValidEscape()) {\\n        reconsume();\\n        return consumeAnIdentlikeToken();\\n      } else {\\n        parseerror();\\n        return new DelimToken(code);\\n      }\\n    } else if (code === 93) {\\n      return new CloseSquareToken();\\n    } else if (code === 94) {\\n      if (next() === 61) {\\n        consume();\\n        return new PrefixMatchToken();\\n      } else {\\n        return new DelimToken(code);\\n      }\\n    } else if (code === 123) {\\n      return new OpenCurlyToken();\\n    } else if (code === 124) {\\n      if (next() === 61) {\\n        consume();\\n        return new DashMatchToken();\\n      } else if (next() === 124) {\\n        consume();\\n        return new ColumnToken();\\n      } else {\\n        return new DelimToken(code);\\n      }\\n    } else if (code === 125) {\\n      return new CloseCurlyToken();\\n    } else if (code === 126) {\\n      if (next() === 61) {\\n        consume();\\n        return new IncludeMatchToken();\\n      } else {\\n        return new DelimToken(code);\\n      }\\n    } else if (digit(code)) {\\n      reconsume();\\n      return consumeANumericToken();\\n    } else if (namestartchar(code)) {\\n      reconsume();\\n      return consumeAnIdentlikeToken();\\n    } else if (eof()) {\\n      return new EOFToken();\\n    } else {\\n      return new DelimToken(code);\\n    }\\n  };\\n  const consumeComments = function() {\\n    while (next(1) === 47 && next(2) === 42) {\\n      consume(2);\\n      while (true) {\\n        consume();\\n        if (code === 42 && next() === 47) {\\n          consume();\\n          break;\\n        } else if (eof()) {\\n          parseerror();\\n          return;\\n        }\\n      }\\n    }\\n  };\\n  const consumeANumericToken = function() {\\n    const num = consumeANumber();\\n    if (wouldStartAnIdentifier(next(1), next(2), next(3))) {\\n      const token = new DimensionToken();\\n      token.value = num.value;\\n      token.repr = num.repr;\\n      token.type = num.type;\\n      token.unit = consumeAName();\\n      return token;\\n    } else if (next() === 37) {\\n      consume();\\n      const token = new PercentageToken();\\n      token.value = num.value;\\n      token.repr = num.repr;\\n      return token;\\n    } else {\\n      const token = new NumberToken();\\n      token.value = num.value;\\n      token.repr = num.repr;\\n      token.type = num.type;\\n      return token;\\n    }\\n  };\\n  const consumeAnIdentlikeToken = function() {\\n    const str2 = consumeAName();\\n    if (str2.toLowerCase() === \\\"url\\\" && next() === 40) {\\n      consume();\\n      while (whitespace(next(1)) && whitespace(next(2)))\\n        consume();\\n      if (next() === 34 || next() === 39)\\n        return new FunctionToken(str2);\\n      else if (whitespace(next()) && (next(2) === 34 || next(2) === 39))\\n        return new FunctionToken(str2);\\n      else\\n        return consumeAURLToken();\\n    } else if (next() === 40) {\\n      consume();\\n      return new FunctionToken(str2);\\n    } else {\\n      return new IdentToken(str2);\\n    }\\n  };\\n  const consumeAStringToken = function(endingCodePoint) {\\n    if (endingCodePoint === void 0)\\n      endingCodePoint = code;\\n    let string = \\\"\\\";\\n    while (consume()) {\\n      if (code === endingCodePoint || eof()) {\\n        return new StringToken(string);\\n      } else if (newline(code)) {\\n        parseerror();\\n        reconsume();\\n        return new BadStringToken();\\n      } else if (code === 92) {\\n        if (eof(next()))\\n          donothing();\\n        else if (newline(next()))\\n          consume();\\n        else\\n          string += stringFromCode(consumeEscape());\\n      } else {\\n        string += stringFromCode(code);\\n      }\\n    }\\n    throw new Error(\\\"Internal error\\\");\\n  };\\n  const consumeAURLToken = function() {\\n    const token = new URLToken(\\\"\\\");\\n    while (whitespace(next()))\\n      consume();\\n    if (eof(next()))\\n      return token;\\n    while (consume()) {\\n      if (code === 41 || eof()) {\\n        return token;\\n      } else if (whitespace(code)) {\\n        while (whitespace(next()))\\n          consume();\\n        if (next() === 41 || eof(next())) {\\n          consume();\\n          return token;\\n        } else {\\n          consumeTheRemnantsOfABadURL();\\n          return new BadURLToken();\\n        }\\n      } else if (code === 34 || code === 39 || code === 40 || nonprintable(code)) {\\n        parseerror();\\n        consumeTheRemnantsOfABadURL();\\n        return new BadURLToken();\\n      } else if (code === 92) {\\n        if (startsWithAValidEscape()) {\\n          token.value += stringFromCode(consumeEscape());\\n        } else {\\n          parseerror();\\n          consumeTheRemnantsOfABadURL();\\n          return new BadURLToken();\\n        }\\n      } else {\\n        token.value += stringFromCode(code);\\n      }\\n    }\\n    throw new Error(\\\"Internal error\\\");\\n  };\\n  const consumeEscape = function() {\\n    consume();\\n    if (hexdigit(code)) {\\n      const digits = [code];\\n      for (let total = 0; total < 5; total++) {\\n        if (hexdigit(next())) {\\n          consume();\\n          digits.push(code);\\n        } else {\\n          break;\\n        }\\n      }\\n      if (whitespace(next()))\\n        consume();\\n      let value = parseInt(digits.map(function(x) {\\n        return String.fromCharCode(x);\\n      }).join(\\\"\\\"), 16);\\n      if (value > maximumallowedcodepoint)\\n        value = 65533;\\n      return value;\\n    } else if (eof()) {\\n      return 65533;\\n    } else {\\n      return code;\\n    }\\n  };\\n  const areAValidEscape = function(c1, c2) {\\n    if (c1 !== 92)\\n      return false;\\n    if (newline(c2))\\n      return false;\\n    return true;\\n  };\\n  const startsWithAValidEscape = function() {\\n    return areAValidEscape(code, next());\\n  };\\n  const wouldStartAnIdentifier = function(c1, c2, c3) {\\n    if (c1 === 45)\\n      return namestartchar(c2) || c2 === 45 || areAValidEscape(c2, c3);\\n    else if (namestartchar(c1))\\n      return true;\\n    else if (c1 === 92)\\n      return areAValidEscape(c1, c2);\\n    else\\n      return false;\\n  };\\n  const startsWithAnIdentifier = function() {\\n    return wouldStartAnIdentifier(code, next(1), next(2));\\n  };\\n  const wouldStartANumber = function(c1, c2, c3) {\\n    if (c1 === 43 || c1 === 45) {\\n      if (digit(c2))\\n        return true;\\n      if (c2 === 46 && digit(c3))\\n        return true;\\n      return false;\\n    } else if (c1 === 46) {\\n      if (digit(c2))\\n        return true;\\n      return false;\\n    } else if (digit(c1)) {\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  };\\n  const startsWithANumber = function() {\\n    return wouldStartANumber(code, next(1), next(2));\\n  };\\n  const consumeAName = function() {\\n    let result = \\\"\\\";\\n    while (consume()) {\\n      if (namechar(code)) {\\n        result += stringFromCode(code);\\n      } else if (startsWithAValidEscape()) {\\n        result += stringFromCode(consumeEscape());\\n      } else {\\n        reconsume();\\n        return result;\\n      }\\n    }\\n    throw new Error(\\\"Internal parse error\\\");\\n  };\\n  const consumeANumber = function() {\\n    let repr = \\\"\\\";\\n    let type = \\\"integer\\\";\\n    if (next() === 43 || next() === 45) {\\n      consume();\\n      repr += stringFromCode(code);\\n    }\\n    while (digit(next())) {\\n      consume();\\n      repr += stringFromCode(code);\\n    }\\n    if (next(1) === 46 && digit(next(2))) {\\n      consume();\\n      repr += stringFromCode(code);\\n      consume();\\n      repr += stringFromCode(code);\\n      type = \\\"number\\\";\\n      while (digit(next())) {\\n        consume();\\n        repr += stringFromCode(code);\\n      }\\n    }\\n    const c1 = next(1), c2 = next(2), c3 = next(3);\\n    if ((c1 === 69 || c1 === 101) && digit(c2)) {\\n      consume();\\n      repr += stringFromCode(code);\\n      consume();\\n      repr += stringFromCode(code);\\n      type = \\\"number\\\";\\n      while (digit(next())) {\\n        consume();\\n        repr += stringFromCode(code);\\n      }\\n    } else if ((c1 === 69 || c1 === 101) && (c2 === 43 || c2 === 45) && digit(c3)) {\\n      consume();\\n      repr += stringFromCode(code);\\n      consume();\\n      repr += stringFromCode(code);\\n      consume();\\n      repr += stringFromCode(code);\\n      type = \\\"number\\\";\\n      while (digit(next())) {\\n        consume();\\n        repr += stringFromCode(code);\\n      }\\n    }\\n    const value = convertAStringToANumber(repr);\\n    return { type, value, repr };\\n  };\\n  const convertAStringToANumber = function(string) {\\n    return +string;\\n  };\\n  const consumeTheRemnantsOfABadURL = function() {\\n    while (consume()) {\\n      if (code === 41 || eof()) {\\n        return;\\n      } else if (startsWithAValidEscape()) {\\n        consumeEscape();\\n        donothing();\\n      } else {\\n        donothing();\\n      }\\n    }\\n  };\\n  let iterationCount = 0;\\n  while (!eof(next())) {\\n    tokens.push(consumeAToken());\\n    iterationCount++;\\n    if (iterationCount > str.length * 2)\\n      throw new Error(\\\"I'm infinite-looping!\\\");\\n  }\\n  return tokens;\\n}\\nvar CSSParserToken = class {\\n  constructor() {\\n    this.tokenType = \\\"\\\";\\n  }\\n  toJSON() {\\n    return { token: this.tokenType };\\n  }\\n  toString() {\\n    return this.tokenType;\\n  }\\n  toSource() {\\n    return \\\"\\\" + this;\\n  }\\n};\\nvar BadStringToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\"BADSTRING\\\";\\n  }\\n};\\nvar BadURLToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\"BADURL\\\";\\n  }\\n};\\nvar WhitespaceToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\"WHITESPACE\\\";\\n  }\\n  toString() {\\n    return \\\"WS\\\";\\n  }\\n  toSource() {\\n    return \\\" \\\";\\n  }\\n};\\nvar CDOToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\"CDO\\\";\\n  }\\n  toSource() {\\n    return \\\"<!--\\\";\\n  }\\n};\\nvar CDCToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\"CDC\\\";\\n  }\\n  toSource() {\\n    return \\\"-->\\\";\\n  }\\n};\\nvar ColonToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\":\\\";\\n  }\\n};\\nvar SemicolonToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\";\\\";\\n  }\\n};\\nvar CommaToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\",\\\";\\n  }\\n};\\nvar GroupingToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.value = \\\"\\\";\\n    this.mirror = \\\"\\\";\\n  }\\n};\\nvar OpenCurlyToken = class extends GroupingToken {\\n  constructor() {\\n    super();\\n    this.tokenType = \\\"{\\\";\\n    this.value = \\\"{\\\";\\n    this.mirror = \\\"}\\\";\\n  }\\n};\\nvar CloseCurlyToken = class extends GroupingToken {\\n  constructor() {\\n    super();\\n    this.tokenType = \\\"}\\\";\\n    this.value = \\\"}\\\";\\n    this.mirror = \\\"{\\\";\\n  }\\n};\\nvar OpenSquareToken = class extends GroupingToken {\\n  constructor() {\\n    super();\\n    this.tokenType = \\\"[\\\";\\n    this.value = \\\"[\\\";\\n    this.mirror = \\\"]\\\";\\n  }\\n};\\nvar CloseSquareToken = class extends GroupingToken {\\n  constructor() {\\n    super();\\n    this.tokenType = \\\"]\\\";\\n    this.value = \\\"]\\\";\\n    this.mirror = \\\"[\\\";\\n  }\\n};\\nvar OpenParenToken = class extends GroupingToken {\\n  constructor() {\\n    super();\\n    this.tokenType = \\\"(\\\";\\n    this.value = \\\"(\\\";\\n    this.mirror = \\\")\\\";\\n  }\\n};\\nvar CloseParenToken = class extends GroupingToken {\\n  constructor() {\\n    super();\\n    this.tokenType = \\\")\\\";\\n    this.value = \\\")\\\";\\n    this.mirror = \\\"(\\\";\\n  }\\n};\\nvar IncludeMatchToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\"~=\\\";\\n  }\\n};\\nvar DashMatchToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\"|=\\\";\\n  }\\n};\\nvar PrefixMatchToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\"^=\\\";\\n  }\\n};\\nvar SuffixMatchToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\"$=\\\";\\n  }\\n};\\nvar SubstringMatchToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\"*=\\\";\\n  }\\n};\\nvar ColumnToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\"||\\\";\\n  }\\n};\\nvar EOFToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.tokenType = \\\"EOF\\\";\\n  }\\n  toSource() {\\n    return \\\"\\\";\\n  }\\n};\\nvar DelimToken = class extends CSSParserToken {\\n  constructor(code) {\\n    super();\\n    this.tokenType = \\\"DELIM\\\";\\n    this.value = \\\"\\\";\\n    this.value = stringFromCode(code);\\n  }\\n  toString() {\\n    return \\\"DELIM(\\\" + this.value + \\\")\\\";\\n  }\\n  toJSON() {\\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\\n    json.value = this.value;\\n    return json;\\n  }\\n  toSource() {\\n    if (this.value === \\\"\\\\\\\\\\\")\\n      return \\\"\\\\\\\\\\\\n\\\";\\n    else\\n      return this.value;\\n  }\\n};\\nvar StringValuedToken = class extends CSSParserToken {\\n  constructor() {\\n    super(...arguments);\\n    this.value = \\\"\\\";\\n  }\\n  ASCIIMatch(str) {\\n    return this.value.toLowerCase() === str.toLowerCase();\\n  }\\n  toJSON() {\\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\\n    json.value = this.value;\\n    return json;\\n  }\\n};\\nvar IdentToken = class extends StringValuedToken {\\n  constructor(val) {\\n    super();\\n    this.tokenType = \\\"IDENT\\\";\\n    this.value = val;\\n  }\\n  toString() {\\n    return \\\"IDENT(\\\" + this.value + \\\")\\\";\\n  }\\n  toSource() {\\n    return escapeIdent(this.value);\\n  }\\n};\\nvar FunctionToken = class extends StringValuedToken {\\n  constructor(val) {\\n    super();\\n    this.tokenType = \\\"FUNCTION\\\";\\n    this.value = val;\\n    this.mirror = \\\")\\\";\\n  }\\n  toString() {\\n    return \\\"FUNCTION(\\\" + this.value + \\\")\\\";\\n  }\\n  toSource() {\\n    return escapeIdent(this.value) + \\\"(\\\";\\n  }\\n};\\nvar AtKeywordToken = class extends StringValuedToken {\\n  constructor(val) {\\n    super();\\n    this.tokenType = \\\"AT-KEYWORD\\\";\\n    this.value = val;\\n  }\\n  toString() {\\n    return \\\"AT(\\\" + this.value + \\\")\\\";\\n  }\\n  toSource() {\\n    return \\\"@\\\" + escapeIdent(this.value);\\n  }\\n};\\nvar HashToken = class extends StringValuedToken {\\n  constructor(val) {\\n    super();\\n    this.tokenType = \\\"HASH\\\";\\n    this.value = val;\\n    this.type = \\\"unrestricted\\\";\\n  }\\n  toString() {\\n    return \\\"HASH(\\\" + this.value + \\\")\\\";\\n  }\\n  toJSON() {\\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\\n    json.value = this.value;\\n    json.type = this.type;\\n    return json;\\n  }\\n  toSource() {\\n    if (this.type === \\\"id\\\")\\n      return \\\"#\\\" + escapeIdent(this.value);\\n    else\\n      return \\\"#\\\" + escapeHash(this.value);\\n  }\\n};\\nvar StringToken = class extends StringValuedToken {\\n  constructor(val) {\\n    super();\\n    this.tokenType = \\\"STRING\\\";\\n    this.value = val;\\n  }\\n  toString() {\\n    return '\\\"' + escapeString(this.value) + '\\\"';\\n  }\\n};\\nvar URLToken = class extends StringValuedToken {\\n  constructor(val) {\\n    super();\\n    this.tokenType = \\\"URL\\\";\\n    this.value = val;\\n  }\\n  toString() {\\n    return \\\"URL(\\\" + this.value + \\\")\\\";\\n  }\\n  toSource() {\\n    return 'url(\\\"' + escapeString(this.value) + '\\\")';\\n  }\\n};\\nvar NumberToken = class extends CSSParserToken {\\n  constructor() {\\n    super();\\n    this.tokenType = \\\"NUMBER\\\";\\n    this.type = \\\"integer\\\";\\n    this.repr = \\\"\\\";\\n  }\\n  toString() {\\n    if (this.type === \\\"integer\\\")\\n      return \\\"INT(\\\" + this.value + \\\")\\\";\\n    return \\\"NUMBER(\\\" + this.value + \\\")\\\";\\n  }\\n  toJSON() {\\n    const json = super.toJSON();\\n    json.value = this.value;\\n    json.type = this.type;\\n    json.repr = this.repr;\\n    return json;\\n  }\\n  toSource() {\\n    return this.repr;\\n  }\\n};\\nvar PercentageToken = class extends CSSParserToken {\\n  constructor() {\\n    super();\\n    this.tokenType = \\\"PERCENTAGE\\\";\\n    this.repr = \\\"\\\";\\n  }\\n  toString() {\\n    return \\\"PERCENTAGE(\\\" + this.value + \\\")\\\";\\n  }\\n  toJSON() {\\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\\n    json.value = this.value;\\n    json.repr = this.repr;\\n    return json;\\n  }\\n  toSource() {\\n    return this.repr + \\\"%\\\";\\n  }\\n};\\nvar DimensionToken = class extends CSSParserToken {\\n  constructor() {\\n    super();\\n    this.tokenType = \\\"DIMENSION\\\";\\n    this.type = \\\"integer\\\";\\n    this.repr = \\\"\\\";\\n    this.unit = \\\"\\\";\\n  }\\n  toString() {\\n    return \\\"DIM(\\\" + this.value + \\\",\\\" + this.unit + \\\")\\\";\\n  }\\n  toJSON() {\\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\\n    json.value = this.value;\\n    json.type = this.type;\\n    json.repr = this.repr;\\n    json.unit = this.unit;\\n    return json;\\n  }\\n  toSource() {\\n    const source = this.repr;\\n    let unit = escapeIdent(this.unit);\\n    if (unit[0].toLowerCase() === \\\"e\\\" && (unit[1] === \\\"-\\\" || between(unit.charCodeAt(1), 48, 57))) {\\n      unit = \\\"\\\\\\\\65 \\\" + unit.slice(1, unit.length);\\n    }\\n    return source + unit;\\n  }\\n};\\nfunction escapeIdent(string) {\\n  string = \\\"\\\" + string;\\n  let result = \\\"\\\";\\n  const firstcode = string.charCodeAt(0);\\n  for (let i = 0; i < string.length; i++) {\\n    const code = string.charCodeAt(i);\\n    if (code === 0)\\n      throw new InvalidCharacterError(\\\"Invalid character: the input contains U+0000.\\\");\\n    if (between(code, 1, 31) || code === 127 || i === 0 && between(code, 48, 57) || i === 1 && between(code, 48, 57) && firstcode === 45)\\n      result += \\\"\\\\\\\\\\\" + code.toString(16) + \\\" \\\";\\n    else if (code >= 128 || code === 45 || code === 95 || between(code, 48, 57) || between(code, 65, 90) || between(code, 97, 122))\\n      result += string[i];\\n    else\\n      result += \\\"\\\\\\\\\\\" + string[i];\\n  }\\n  return result;\\n}\\nfunction escapeHash(string) {\\n  string = \\\"\\\" + string;\\n  let result = \\\"\\\";\\n  for (let i = 0; i < string.length; i++) {\\n    const code = string.charCodeAt(i);\\n    if (code === 0)\\n      throw new InvalidCharacterError(\\\"Invalid character: the input contains U+0000.\\\");\\n    if (code >= 128 || code === 45 || code === 95 || between(code, 48, 57) || between(code, 65, 90) || between(code, 97, 122))\\n      result += string[i];\\n    else\\n      result += \\\"\\\\\\\\\\\" + code.toString(16) + \\\" \\\";\\n  }\\n  return result;\\n}\\nfunction escapeString(string) {\\n  string = \\\"\\\" + string;\\n  let result = \\\"\\\";\\n  for (let i = 0; i < string.length; i++) {\\n    const code = string.charCodeAt(i);\\n    if (code === 0)\\n      throw new InvalidCharacterError(\\\"Invalid character: the input contains U+0000.\\\");\\n    if (between(code, 1, 31) || code === 127)\\n      result += \\\"\\\\\\\\\\\" + code.toString(16) + \\\" \\\";\\n    else if (code === 34 || code === 92)\\n      result += \\\"\\\\\\\\\\\" + string[i];\\n    else\\n      result += string[i];\\n  }\\n  return result;\\n}\\n\\n// packages/playwright-core/src/utils/isomorphic/cssParser.ts\\nvar InvalidSelectorError = class extends Error {\\n};\\nfunction parseCSS(selector, customNames) {\\n  let tokens;\\n  try {\\n    tokens = tokenize(selector);\\n    if (!(tokens[tokens.length - 1] instanceof EOFToken))\\n      tokens.push(new EOFToken());\\n  } catch (e) {\\n    const newMessage = e.message + ` while parsing css selector \\\"${selector}\\\". Did you mean to CSS.escape it?`;\\n    const index = (e.stack || \\\"\\\").indexOf(e.message);\\n    if (index !== -1)\\n      e.stack = e.stack.substring(0, index) + newMessage + e.stack.substring(index + e.message.length);\\n    e.message = newMessage;\\n    throw e;\\n  }\\n  const unsupportedToken = tokens.find((token) => {\\n    return token instanceof AtKeywordToken || token instanceof BadStringToken || token instanceof BadURLToken || token instanceof ColumnToken || token instanceof CDOToken || token instanceof CDCToken || token instanceof SemicolonToken || // TODO: Consider using these for something, e.g. to escape complex strings.\\n    // For example :xpath{ (//div/bar[@attr=\\\"foo\\\"])[2]/baz }\\n    // Or this way :xpath( {complex-xpath-goes-here(\\\"hello\\\")} )\\n    token instanceof OpenCurlyToken || token instanceof CloseCurlyToken || // TODO: Consider treating these as strings?\\n    token instanceof URLToken || token instanceof PercentageToken;\\n  });\\n  if (unsupportedToken)\\n    throw new InvalidSelectorError(`Unsupported token \\\"${unsupportedToken.toSource()}\\\" while parsing css selector \\\"${selector}\\\". Did you mean to CSS.escape it?`);\\n  let pos = 0;\\n  const names = /* @__PURE__ */ new Set();\\n  function unexpected() {\\n    return new InvalidSelectorError(`Unexpected token \\\"${tokens[pos].toSource()}\\\" while parsing css selector \\\"${selector}\\\". Did you mean to CSS.escape it?`);\\n  }\\n  function skipWhitespace() {\\n    while (tokens[pos] instanceof WhitespaceToken)\\n      pos++;\\n  }\\n  function isIdent(p = pos) {\\n    return tokens[p] instanceof IdentToken;\\n  }\\n  function isString(p = pos) {\\n    return tokens[p] instanceof StringToken;\\n  }\\n  function isNumber(p = pos) {\\n    return tokens[p] instanceof NumberToken;\\n  }\\n  function isComma(p = pos) {\\n    return tokens[p] instanceof CommaToken;\\n  }\\n  function isOpenParen(p = pos) {\\n    return tokens[p] instanceof OpenParenToken;\\n  }\\n  function isCloseParen(p = pos) {\\n    return tokens[p] instanceof CloseParenToken;\\n  }\\n  function isFunction(p = pos) {\\n    return tokens[p] instanceof FunctionToken;\\n  }\\n  function isStar(p = pos) {\\n    return tokens[p] instanceof DelimToken && tokens[p].value === \\\"*\\\";\\n  }\\n  function isEOF(p = pos) {\\n    return tokens[p] instanceof EOFToken;\\n  }\\n  function isClauseCombinator(p = pos) {\\n    return tokens[p] instanceof DelimToken && [\\\">\\\", \\\"+\\\", \\\"~\\\"].includes(tokens[p].value);\\n  }\\n  function isSelectorClauseEnd(p = pos) {\\n    return isComma(p) || isCloseParen(p) || isEOF(p) || isClauseCombinator(p) || tokens[p] instanceof WhitespaceToken;\\n  }\\n  function consumeFunctionArguments() {\\n    const result2 = [consumeArgument()];\\n    while (true) {\\n      skipWhitespace();\\n      if (!isComma())\\n        break;\\n      pos++;\\n      result2.push(consumeArgument());\\n    }\\n    return result2;\\n  }\\n  function consumeArgument() {\\n    skipWhitespace();\\n    if (isNumber())\\n      return tokens[pos++].value;\\n    if (isString())\\n      return tokens[pos++].value;\\n    return consumeComplexSelector();\\n  }\\n  function consumeComplexSelector() {\\n    const result2 = { simples: [] };\\n    skipWhitespace();\\n    if (isClauseCombinator()) {\\n      result2.simples.push({ selector: { functions: [{ name: \\\"scope\\\", args: [] }] }, combinator: \\\"\\\" });\\n    } else {\\n      result2.simples.push({ selector: consumeSimpleSelector(), combinator: \\\"\\\" });\\n    }\\n    while (true) {\\n      skipWhitespace();\\n      if (isClauseCombinator()) {\\n        result2.simples[result2.simples.length - 1].combinator = tokens[pos++].value;\\n        skipWhitespace();\\n      } else if (isSelectorClauseEnd()) {\\n        break;\\n      }\\n      result2.simples.push({ combinator: \\\"\\\", selector: consumeSimpleSelector() });\\n    }\\n    return result2;\\n  }\\n  function consumeSimpleSelector() {\\n    let rawCSSString = \\\"\\\";\\n    const functions = [];\\n    while (!isSelectorClauseEnd()) {\\n      if (isIdent() || isStar()) {\\n        rawCSSString += tokens[pos++].toSource();\\n      } else if (tokens[pos] instanceof HashToken) {\\n        rawCSSString += tokens[pos++].toSource();\\n      } else if (tokens[pos] instanceof DelimToken && tokens[pos].value === \\\".\\\") {\\n        pos++;\\n        if (isIdent())\\n          rawCSSString += \\\".\\\" + tokens[pos++].toSource();\\n        else\\n          throw unexpected();\\n      } else if (tokens[pos] instanceof ColonToken) {\\n        pos++;\\n        if (isIdent()) {\\n          if (!customNames.has(tokens[pos].value.toLowerCase())) {\\n            rawCSSString += \\\":\\\" + tokens[pos++].toSource();\\n          } else {\\n            const name = tokens[pos++].value.toLowerCase();\\n            functions.push({ name, args: [] });\\n            names.add(name);\\n          }\\n        } else if (isFunction()) {\\n          const name = tokens[pos++].value.toLowerCase();\\n          if (!customNames.has(name)) {\\n            rawCSSString += `:${name}(${consumeBuiltinFunctionArguments()})`;\\n          } else {\\n            functions.push({ name, args: consumeFunctionArguments() });\\n            names.add(name);\\n          }\\n          skipWhitespace();\\n          if (!isCloseParen())\\n            throw unexpected();\\n          pos++;\\n        } else {\\n          throw unexpected();\\n        }\\n      } else if (tokens[pos] instanceof OpenSquareToken) {\\n        rawCSSString += \\\"[\\\";\\n        pos++;\\n        while (!(tokens[pos] instanceof CloseSquareToken) && !isEOF())\\n          rawCSSString += tokens[pos++].toSource();\\n        if (!(tokens[pos] instanceof CloseSquareToken))\\n          throw unexpected();\\n        rawCSSString += \\\"]\\\";\\n        pos++;\\n      } else {\\n        throw unexpected();\\n      }\\n    }\\n    if (!rawCSSString && !functions.length)\\n      throw unexpected();\\n    return { css: rawCSSString || void 0, functions };\\n  }\\n  function consumeBuiltinFunctionArguments() {\\n    let s = \\\"\\\";\\n    let balance = 1;\\n    while (!isEOF()) {\\n      if (isOpenParen() || isFunction())\\n        balance++;\\n      if (isCloseParen())\\n        balance--;\\n      if (!balance)\\n        break;\\n      s += tokens[pos++].toSource();\\n    }\\n    return s;\\n  }\\n  const result = consumeFunctionArguments();\\n  if (!isEOF())\\n    throw unexpected();\\n  if (result.some((arg) => typeof arg !== \\\"object\\\" || !(\\\"simples\\\" in arg)))\\n    throw new InvalidSelectorError(`Error while parsing css selector \\\"${selector}\\\". Did you mean to CSS.escape it?`);\\n  return { selector: result, names: Array.from(names) };\\n}\\n\\n// packages/playwright-core/src/utils/isomorphic/selectorParser.ts\\nvar kNestedSelectorNames = /* @__PURE__ */ new Set([\\\"internal:has\\\", \\\"internal:has-not\\\", \\\"internal:and\\\", \\\"internal:or\\\", \\\"internal:chain\\\", \\\"left-of\\\", \\\"right-of\\\", \\\"above\\\", \\\"below\\\", \\\"near\\\"]);\\nvar kNestedSelectorNamesWithDistance = /* @__PURE__ */ new Set([\\\"left-of\\\", \\\"right-of\\\", \\\"above\\\", \\\"below\\\", \\\"near\\\"]);\\nvar customCSSNames = /* @__PURE__ */ new Set([\\\"not\\\", \\\"is\\\", \\\"where\\\", \\\"has\\\", \\\"scope\\\", \\\"light\\\", \\\"visible\\\", \\\"text\\\", \\\"text-matches\\\", \\\"text-is\\\", \\\"has-text\\\", \\\"above\\\", \\\"below\\\", \\\"right-of\\\", \\\"left-of\\\", \\\"near\\\", \\\"nth-match\\\"]);\\nfunction parseSelector(selector) {\\n  const parsedStrings = parseSelectorString(selector);\\n  const parts = [];\\n  for (const part of parsedStrings.parts) {\\n    if (part.name === \\\"css\\\" || part.name === \\\"css:light\\\") {\\n      if (part.name === \\\"css:light\\\")\\n        part.body = \\\":light(\\\" + part.body + \\\")\\\";\\n      const parsedCSS = parseCSS(part.body, customCSSNames);\\n      parts.push({\\n        name: \\\"css\\\",\\n        body: parsedCSS.selector,\\n        source: part.body\\n      });\\n      continue;\\n    }\\n    if (kNestedSelectorNames.has(part.name)) {\\n      let innerSelector;\\n      let distance;\\n      try {\\n        const unescaped = JSON.parse(\\\"[\\\" + part.body + \\\"]\\\");\\n        if (!Array.isArray(unescaped) || unescaped.length < 1 || unescaped.length > 2 || typeof unescaped[0] !== \\\"string\\\")\\n          throw new InvalidSelectorError(`Malformed selector: ${part.name}=` + part.body);\\n        innerSelector = unescaped[0];\\n        if (unescaped.length === 2) {\\n          if (typeof unescaped[1] !== \\\"number\\\" || !kNestedSelectorNamesWithDistance.has(part.name))\\n            throw new InvalidSelectorError(`Malformed selector: ${part.name}=` + part.body);\\n          distance = unescaped[1];\\n        }\\n      } catch (e) {\\n        throw new InvalidSelectorError(`Malformed selector: ${part.name}=` + part.body);\\n      }\\n      const nested = { name: part.name, source: part.body, body: { parsed: parseSelector(innerSelector), distance } };\\n      const lastFrame = [...nested.body.parsed.parts].reverse().find((part2) => part2.name === \\\"internal:control\\\" && part2.body === \\\"enter-frame\\\");\\n      const lastFrameIndex = lastFrame ? nested.body.parsed.parts.indexOf(lastFrame) : -1;\\n      if (lastFrameIndex !== -1 && selectorPartsEqual(nested.body.parsed.parts.slice(0, lastFrameIndex + 1), parts.slice(0, lastFrameIndex + 1)))\\n        nested.body.parsed.parts.splice(0, lastFrameIndex + 1);\\n      parts.push(nested);\\n      continue;\\n    }\\n    parts.push({ ...part, source: part.body });\\n  }\\n  if (kNestedSelectorNames.has(parts[0].name))\\n    throw new InvalidSelectorError(`\\\"${parts[0].name}\\\" selector cannot be first`);\\n  return {\\n    capture: parsedStrings.capture,\\n    parts\\n  };\\n}\\nfunction selectorPartsEqual(list1, list2) {\\n  return stringifySelector({ parts: list1 }) === stringifySelector({ parts: list2 });\\n}\\nfunction stringifySelector(selector, forceEngineName) {\\n  if (typeof selector === \\\"string\\\")\\n    return selector;\\n  return selector.parts.map((p, i) => {\\n    let includeEngine = true;\\n    if (!forceEngineName && i !== selector.capture) {\\n      if (p.name === \\\"css\\\")\\n        includeEngine = false;\\n      else if (p.name === \\\"xpath\\\" && p.source.startsWith(\\\"//\\\") || p.source.startsWith(\\\"..\\\"))\\n        includeEngine = false;\\n    }\\n    const prefix = includeEngine ? p.name + \\\"=\\\" : \\\"\\\";\\n    return `${i === selector.capture ? \\\"*\\\" : \\\"\\\"}${prefix}${p.source}`;\\n  }).join(\\\" >> \\\");\\n}\\nfunction visitAllSelectorParts(selector, visitor) {\\n  const visit = (selector2, nested) => {\\n    for (const part of selector2.parts) {\\n      visitor(part, nested);\\n      if (kNestedSelectorNames.has(part.name))\\n        visit(part.body.parsed, true);\\n    }\\n  };\\n  visit(selector, false);\\n}\\nfunction parseSelectorString(selector) {\\n  let index = 0;\\n  let quote;\\n  let start = 0;\\n  const result = { parts: [] };\\n  const append = () => {\\n    const part = selector.substring(start, index).trim();\\n    const eqIndex = part.indexOf(\\\"=\\\");\\n    let name;\\n    let body;\\n    if (eqIndex !== -1 && part.substring(0, eqIndex).trim().match(/^[a-zA-Z_0-9-+:*]+$/)) {\\n      name = part.substring(0, eqIndex).trim();\\n      body = part.substring(eqIndex + 1);\\n    } else if (part.length > 1 && part[0] === '\\\"' && part[part.length - 1] === '\\\"') {\\n      name = \\\"text\\\";\\n      body = part;\\n    } else if (part.length > 1 && part[0] === \\\"'\\\" && part[part.length - 1] === \\\"'\\\") {\\n      name = \\\"text\\\";\\n      body = part;\\n    } else if (/^\\\\(*\\\\/\\\\//.test(part) || part.startsWith(\\\"..\\\")) {\\n      name = \\\"xpath\\\";\\n      body = part;\\n    } else {\\n      name = \\\"css\\\";\\n      body = part;\\n    }\\n    let capture = false;\\n    if (name[0] === \\\"*\\\") {\\n      capture = true;\\n      name = name.substring(1);\\n    }\\n    result.parts.push({ name, body });\\n    if (capture) {\\n      if (result.capture !== void 0)\\n        throw new InvalidSelectorError(`Only one of the selectors can capture using * modifier`);\\n      result.capture = result.parts.length - 1;\\n    }\\n  };\\n  if (!selector.includes(\\\">>\\\")) {\\n    index = selector.length;\\n    append();\\n    return result;\\n  }\\n  const shouldIgnoreTextSelectorQuote = () => {\\n    const prefix = selector.substring(start, index);\\n    const match = prefix.match(/^\\\\s*text\\\\s*=(.*)$/);\\n    return !!match && !!match[1];\\n  };\\n  while (index < selector.length) {\\n    const c = selector[index];\\n    if (c === \\\"\\\\\\\\\\\" && index + 1 < selector.length) {\\n      index += 2;\\n    } else if (c === quote) {\\n      quote = void 0;\\n      index++;\\n    } else if (!quote && (c === '\\\"' || c === \\\"'\\\" || c === \\\"`\\\") && !shouldIgnoreTextSelectorQuote()) {\\n      quote = c;\\n      index++;\\n    } else if (!quote && c === \\\">\\\" && selector[index + 1] === \\\">\\\") {\\n      append();\\n      index += 2;\\n      start = index;\\n    } else {\\n      index++;\\n    }\\n  }\\n  append();\\n  return result;\\n}\\nfunction parseAttributeSelector(selector, allowUnquotedStrings) {\\n  let wp = 0;\\n  let EOL = selector.length === 0;\\n  const next = () => selector[wp] || \\\"\\\";\\n  const eat1 = () => {\\n    const result2 = next();\\n    ++wp;\\n    EOL = wp >= selector.length;\\n    return result2;\\n  };\\n  const syntaxError = (stage) => {\\n    if (EOL)\\n      throw new InvalidSelectorError(`Unexpected end of selector while parsing selector \\\\`${selector}\\\\``);\\n    throw new InvalidSelectorError(`Error while parsing selector \\\\`${selector}\\\\` - unexpected symbol \\\"${next()}\\\" at position ${wp}` + (stage ? \\\" during \\\" + stage : \\\"\\\"));\\n  };\\n  function skipSpaces() {\\n    while (!EOL && /\\\\s/.test(next()))\\n      eat1();\\n  }\\n  function isCSSNameChar(char) {\\n    return char >= \\\"\\\\x80\\\" || char >= \\\"0\\\" && char <= \\\"9\\\" || char >= \\\"A\\\" && char <= \\\"Z\\\" || char >= \\\"a\\\" && char <= \\\"z\\\" || char >= \\\"0\\\" && char <= \\\"9\\\" || char === \\\"_\\\" || char === \\\"-\\\";\\n  }\\n  function readIdentifier() {\\n    let result2 = \\\"\\\";\\n    skipSpaces();\\n    while (!EOL && isCSSNameChar(next()))\\n      result2 += eat1();\\n    return result2;\\n  }\\n  function readQuotedString(quote) {\\n    let result2 = eat1();\\n    if (result2 !== quote)\\n      syntaxError(\\\"parsing quoted string\\\");\\n    while (!EOL && next() !== quote) {\\n      if (next() === \\\"\\\\\\\\\\\")\\n        eat1();\\n      result2 += eat1();\\n    }\\n    if (next() !== quote)\\n      syntaxError(\\\"parsing quoted string\\\");\\n    result2 += eat1();\\n    return result2;\\n  }\\n  function readRegularExpression() {\\n    if (eat1() !== \\\"/\\\")\\n      syntaxError(\\\"parsing regular expression\\\");\\n    let source = \\\"\\\";\\n    let inClass = false;\\n    while (!EOL) {\\n      if (next() === \\\"\\\\\\\\\\\") {\\n        source += eat1();\\n        if (EOL)\\n          syntaxError(\\\"parsing regular expression\\\");\\n      } else if (inClass && next() === \\\"]\\\") {\\n        inClass = false;\\n      } else if (!inClass && next() === \\\"[\\\") {\\n        inClass = true;\\n      } else if (!inClass && next() === \\\"/\\\") {\\n        break;\\n      }\\n      source += eat1();\\n    }\\n    if (eat1() !== \\\"/\\\")\\n      syntaxError(\\\"parsing regular expression\\\");\\n    let flags = \\\"\\\";\\n    while (!EOL && next().match(/[dgimsuy]/))\\n      flags += eat1();\\n    try {\\n      return new RegExp(source, flags);\\n    } catch (e) {\\n      throw new InvalidSelectorError(`Error while parsing selector \\\\`${selector}\\\\`: ${e.message}`);\\n    }\\n  }\\n  function readAttributeToken() {\\n    let token = \\\"\\\";\\n    skipSpaces();\\n    if (next() === `'` || next() === `\\\"`)\\n      token = readQuotedString(next()).slice(1, -1);\\n    else\\n      token = readIdentifier();\\n    if (!token)\\n      syntaxError(\\\"parsing property path\\\");\\n    return token;\\n  }\\n  function readOperator() {\\n    skipSpaces();\\n    let op = \\\"\\\";\\n    if (!EOL)\\n      op += eat1();\\n    if (!EOL && op !== \\\"=\\\")\\n      op += eat1();\\n    if (![\\\"=\\\", \\\"*=\\\", \\\"^=\\\", \\\"$=\\\", \\\"|=\\\", \\\"~=\\\"].includes(op))\\n      syntaxError(\\\"parsing operator\\\");\\n    return op;\\n  }\\n  function readAttribute() {\\n    eat1();\\n    const jsonPath = [];\\n    jsonPath.push(readAttributeToken());\\n    skipSpaces();\\n    while (next() === \\\".\\\") {\\n      eat1();\\n      jsonPath.push(readAttributeToken());\\n      skipSpaces();\\n    }\\n    if (next() === \\\"]\\\") {\\n      eat1();\\n      return { name: jsonPath.join(\\\".\\\"), jsonPath, op: \\\"<truthy>\\\", value: null, caseSensitive: false };\\n    }\\n    const operator = readOperator();\\n    let value = void 0;\\n    let caseSensitive = true;\\n    skipSpaces();\\n    if (next() === \\\"/\\\") {\\n      if (operator !== \\\"=\\\")\\n        throw new InvalidSelectorError(`Error while parsing selector \\\\`${selector}\\\\` - cannot use ${operator} in attribute with regular expression`);\\n      value = readRegularExpression();\\n    } else if (next() === `'` || next() === `\\\"`) {\\n      value = readQuotedString(next()).slice(1, -1);\\n      skipSpaces();\\n      if (next() === \\\"i\\\" || next() === \\\"I\\\") {\\n        caseSensitive = false;\\n        eat1();\\n      } else if (next() === \\\"s\\\" || next() === \\\"S\\\") {\\n        caseSensitive = true;\\n        eat1();\\n      }\\n    } else {\\n      value = \\\"\\\";\\n      while (!EOL && (isCSSNameChar(next()) || next() === \\\"+\\\" || next() === \\\".\\\"))\\n        value += eat1();\\n      if (value === \\\"true\\\") {\\n        value = true;\\n      } else if (value === \\\"false\\\") {\\n        value = false;\\n      } else {\\n        if (!allowUnquotedStrings) {\\n          value = +value;\\n          if (Number.isNaN(value))\\n            syntaxError(\\\"parsing attribute value\\\");\\n        }\\n      }\\n    }\\n    skipSpaces();\\n    if (next() !== \\\"]\\\")\\n      syntaxError(\\\"parsing attribute value\\\");\\n    eat1();\\n    if (operator !== \\\"=\\\" && typeof value !== \\\"string\\\")\\n      throw new InvalidSelectorError(`Error while parsing selector \\\\`${selector}\\\\` - cannot use ${operator} in attribute with non-string matching value - ${value}`);\\n    return { name: jsonPath.join(\\\".\\\"), jsonPath, op: operator, value, caseSensitive };\\n  }\\n  const result = {\\n    name: \\\"\\\",\\n    attributes: []\\n  };\\n  result.name = readIdentifier();\\n  skipSpaces();\\n  while (next() === \\\"[\\\") {\\n    result.attributes.push(readAttribute());\\n    skipSpaces();\\n  }\\n  if (!EOL)\\n    syntaxError(void 0);\\n  if (!result.name && !result.attributes.length)\\n    throw new InvalidSelectorError(`Error while parsing selector \\\\`${selector}\\\\` - selector cannot be empty`);\\n  return result;\\n}\\n\\n// packages/playwright-core/src/utils/isomorphic/stringUtils.ts\\nfunction escapeWithQuotes(text, char = \\\"'\\\") {\\n  const stringified = JSON.stringify(text);\\n  const escapedText = stringified.substring(1, stringified.length - 1).replace(/\\\\\\\\\\\"/g, '\\\"');\\n  if (char === \\\"'\\\")\\n    return char + escapedText.replace(/[']/g, \\\"\\\\\\\\'\\\") + char;\\n  if (char === '\\\"')\\n    return char + escapedText.replace(/[\\\"]/g, '\\\\\\\\\\\"') + char;\\n  if (char === \\\"`\\\")\\n    return char + escapedText.replace(/[`]/g, \\\"\\\\\\\\`\\\") + char;\\n  throw new Error(\\\"Invalid escape char\\\");\\n}\\nfunction toTitleCase(name) {\\n  return name.charAt(0).toUpperCase() + name.substring(1);\\n}\\nfunction toSnakeCase(name) {\\n  return name.replace(/([a-z0-9])([A-Z])/g, \\\"$1_$2\\\").replace(/([A-Z])([A-Z][a-z])/g, \\\"$1_$2\\\").toLowerCase();\\n}\\nfunction quoteCSSAttributeValue(text) {\\n  return `\\\"${text.replace(/[\\\"\\\\\\\\]/g, (char) => \\\"\\\\\\\\\\\" + char)}\\\"`;\\n}\\nvar normalizedWhitespaceCache;\\nfunction cacheNormalizedWhitespaces() {\\n  normalizedWhitespaceCache = /* @__PURE__ */ new Map();\\n}\\nfunction normalizeWhiteSpace(text) {\\n  let result = normalizedWhitespaceCache == null ? void 0 : normalizedWhitespaceCache.get(text);\\n  if (result === void 0) {\\n    result = text.replace(/[\\\\u200b\\\\u00ad]/g, \\\"\\\").trim().replace(/\\\\s+/g, \\\" \\\");\\n    normalizedWhitespaceCache == null ? void 0 : normalizedWhitespaceCache.set(text, result);\\n  }\\n  return result;\\n}\\nfunction normalizeEscapedRegexQuotes(source) {\\n  return source.replace(/(^|[^\\\\\\\\])(\\\\\\\\\\\\\\\\)*\\\\\\\\(['\\\"`])/g, \\\"$1$2$3\\\");\\n}\\nfunction escapeRegexForSelector(re) {\\n  if (re.unicode || re.unicodeSets)\\n    return String(re);\\n  return String(re).replace(/(^|[^\\\\\\\\])(\\\\\\\\\\\\\\\\)*([\\\"'`])/g, \\\"$1$2\\\\\\\\$3\\\").replace(/>>/g, \\\"\\\\\\\\>\\\\\\\\>\\\");\\n}\\nfunction escapeForTextSelector(text, exact) {\\n  if (typeof text !== \\\"string\\\")\\n    return escapeRegexForSelector(text);\\n  return `${JSON.stringify(text)}${exact ? \\\"s\\\" : \\\"i\\\"}`;\\n}\\nfunction escapeForAttributeSelector(value, exact) {\\n  if (typeof value !== \\\"string\\\")\\n    return escapeRegexForSelector(value);\\n  return `\\\"${value.replace(/\\\\\\\\/g, \\\"\\\\\\\\\\\\\\\\\\\").replace(/[\\\"]/g, '\\\\\\\\\\\"')}\\\"${exact ? \\\"s\\\" : \\\"i\\\"}`;\\n}\\nfunction trimString(input, cap, suffix = \\\"\\\") {\\n  if (input.length <= cap)\\n    return input;\\n  const chars = [...input];\\n  if (chars.length > cap)\\n    return chars.slice(0, cap - suffix.length).join(\\\"\\\") + suffix;\\n  return chars.join(\\\"\\\");\\n}\\nfunction trimStringWithEllipsis(input, cap) {\\n  return trimString(input, cap, \\\"\\\\u2026\\\");\\n}\\nfunction escapeRegExp(s) {\\n  return s.replace(/[.*+?^${}()|[\\\\]\\\\\\\\]/g, \\\"\\\\\\\\$&\\\");\\n}\\nfunction longestCommonSubstring(s1, s2) {\\n  const n = s1.length;\\n  const m = s2.length;\\n  let maxLen = 0;\\n  let endingIndex = 0;\\n  const dp = Array(n + 1).fill(null).map(() => Array(m + 1).fill(0));\\n  for (let i = 1; i <= n; i++) {\\n    for (let j = 1; j <= m; j++) {\\n      if (s1[i - 1] === s2[j - 1]) {\\n        dp[i][j] = dp[i - 1][j - 1] + 1;\\n        if (dp[i][j] > maxLen) {\\n          maxLen = dp[i][j];\\n          endingIndex = i;\\n        }\\n      }\\n    }\\n  }\\n  return s1.slice(endingIndex - maxLen, endingIndex);\\n}\\n\\n// packages/playwright-core/src/utils/isomorphic/locatorGenerators.ts\\nfunction asLocator(lang, selector, isFrameLocator = false) {\\n  return asLocators(lang, selector, isFrameLocator, 1)[0];\\n}\\nfunction asLocators(lang, selector, isFrameLocator = false, maxOutputSize = 20, preferredQuote) {\\n  try {\\n    return innerAsLocators(new generators[lang](preferredQuote), parseSelector(selector), isFrameLocator, maxOutputSize);\\n  } catch (e) {\\n    return [selector];\\n  }\\n}\\nfunction innerAsLocators(factory, parsed, isFrameLocator = false, maxOutputSize = 20) {\\n  const parts = [...parsed.parts];\\n  const tokens = [];\\n  let nextBase = isFrameLocator ? \\\"frame-locator\\\" : \\\"page\\\";\\n  for (let index = 0; index < parts.length; index++) {\\n    const part = parts[index];\\n    const base = nextBase;\\n    nextBase = \\\"locator\\\";\\n    if (part.name === \\\"internal:describe\\\")\\n      continue;\\n    if (part.name === \\\"nth\\\") {\\n      if (part.body === \\\"0\\\")\\n        tokens.push([factory.generateLocator(base, \\\"first\\\", \\\"\\\"), factory.generateLocator(base, \\\"nth\\\", \\\"0\\\")]);\\n      else if (part.body === \\\"-1\\\")\\n        tokens.push([factory.generateLocator(base, \\\"last\\\", \\\"\\\"), factory.generateLocator(base, \\\"nth\\\", \\\"-1\\\")]);\\n      else\\n        tokens.push([factory.generateLocator(base, \\\"nth\\\", part.body)]);\\n      continue;\\n    }\\n    if (part.name === \\\"visible\\\") {\\n      tokens.push([factory.generateLocator(base, \\\"visible\\\", part.body), factory.generateLocator(base, \\\"default\\\", `visible=${part.body}`)]);\\n      continue;\\n    }\\n    if (part.name === \\\"internal:text\\\") {\\n      const { exact, text } = detectExact(part.body);\\n      tokens.push([factory.generateLocator(base, \\\"text\\\", text, { exact })]);\\n      continue;\\n    }\\n    if (part.name === \\\"internal:has-text\\\") {\\n      const { exact, text } = detectExact(part.body);\\n      if (!exact) {\\n        tokens.push([factory.generateLocator(base, \\\"has-text\\\", text, { exact })]);\\n        continue;\\n      }\\n    }\\n    if (part.name === \\\"internal:has-not-text\\\") {\\n      const { exact, text } = detectExact(part.body);\\n      if (!exact) {\\n        tokens.push([factory.generateLocator(base, \\\"has-not-text\\\", text, { exact })]);\\n        continue;\\n      }\\n    }\\n    if (part.name === \\\"internal:has\\\") {\\n      const inners = innerAsLocators(factory, part.body.parsed, false, maxOutputSize);\\n      tokens.push(inners.map((inner) => factory.generateLocator(base, \\\"has\\\", inner)));\\n      continue;\\n    }\\n    if (part.name === \\\"internal:has-not\\\") {\\n      const inners = innerAsLocators(factory, part.body.parsed, false, maxOutputSize);\\n      tokens.push(inners.map((inner) => factory.generateLocator(base, \\\"hasNot\\\", inner)));\\n      continue;\\n    }\\n    if (part.name === \\\"internal:and\\\") {\\n      const inners = innerAsLocators(factory, part.body.parsed, false, maxOutputSize);\\n      tokens.push(inners.map((inner) => factory.generateLocator(base, \\\"and\\\", inner)));\\n      continue;\\n    }\\n    if (part.name === \\\"internal:or\\\") {\\n      const inners = innerAsLocators(factory, part.body.parsed, false, maxOutputSize);\\n      tokens.push(inners.map((inner) => factory.generateLocator(base, \\\"or\\\", inner)));\\n      continue;\\n    }\\n    if (part.name === \\\"internal:chain\\\") {\\n      const inners = innerAsLocators(factory, part.body.parsed, false, maxOutputSize);\\n      tokens.push(inners.map((inner) => factory.generateLocator(base, \\\"chain\\\", inner)));\\n      continue;\\n    }\\n    if (part.name === \\\"internal:label\\\") {\\n      const { exact, text } = detectExact(part.body);\\n      tokens.push([factory.generateLocator(base, \\\"label\\\", text, { exact })]);\\n      continue;\\n    }\\n    if (part.name === \\\"internal:role\\\") {\\n      const attrSelector = parseAttributeSelector(part.body, true);\\n      const options = { attrs: [] };\\n      for (const attr of attrSelector.attributes) {\\n        if (attr.name === \\\"name\\\") {\\n          options.exact = attr.caseSensitive;\\n          options.name = attr.value;\\n        } else {\\n          if (attr.name === \\\"level\\\" && typeof attr.value === \\\"string\\\")\\n            attr.value = +attr.value;\\n          options.attrs.push({ name: attr.name === \\\"include-hidden\\\" ? \\\"includeHidden\\\" : attr.name, value: attr.value });\\n        }\\n      }\\n      tokens.push([factory.generateLocator(base, \\\"role\\\", attrSelector.name, options)]);\\n      continue;\\n    }\\n    if (part.name === \\\"internal:testid\\\") {\\n      const attrSelector = parseAttributeSelector(part.body, true);\\n      const { value } = attrSelector.attributes[0];\\n      tokens.push([factory.generateLocator(base, \\\"test-id\\\", value)]);\\n      continue;\\n    }\\n    if (part.name === \\\"internal:attr\\\") {\\n      const attrSelector = parseAttributeSelector(part.body, true);\\n      const { name, value, caseSensitive } = attrSelector.attributes[0];\\n      const text = value;\\n      const exact = !!caseSensitive;\\n      if (name === \\\"placeholder\\\") {\\n        tokens.push([factory.generateLocator(base, \\\"placeholder\\\", text, { exact })]);\\n        continue;\\n      }\\n      if (name === \\\"alt\\\") {\\n        tokens.push([factory.generateLocator(base, \\\"alt\\\", text, { exact })]);\\n        continue;\\n      }\\n      if (name === \\\"title\\\") {\\n        tokens.push([factory.generateLocator(base, \\\"title\\\", text, { exact })]);\\n        continue;\\n      }\\n    }\\n    if (part.name === \\\"internal:control\\\" && part.body === \\\"enter-frame\\\") {\\n      const lastTokens = tokens[tokens.length - 1];\\n      const lastPart = parts[index - 1];\\n      const transformed = lastTokens.map((token) => factory.chainLocators([token, factory.generateLocator(base, \\\"frame\\\", \\\"\\\")]));\\n      if ([\\\"xpath\\\", \\\"css\\\"].includes(lastPart.name)) {\\n        transformed.push(\\n          factory.generateLocator(base, \\\"frame-locator\\\", stringifySelector({ parts: [lastPart] })),\\n          factory.generateLocator(base, \\\"frame-locator\\\", stringifySelector({ parts: [lastPart] }, true))\\n        );\\n      }\\n      lastTokens.splice(0, lastTokens.length, ...transformed);\\n      nextBase = \\\"frame-locator\\\";\\n      continue;\\n    }\\n    const nextPart = parts[index + 1];\\n    const selectorPart = stringifySelector({ parts: [part] });\\n    const locatorPart = factory.generateLocator(base, \\\"default\\\", selectorPart);\\n    if (nextPart && [\\\"internal:has-text\\\", \\\"internal:has-not-text\\\"].includes(nextPart.name)) {\\n      const { exact, text } = detectExact(nextPart.body);\\n      if (!exact) {\\n        const nextLocatorPart = factory.generateLocator(\\\"locator\\\", nextPart.name === \\\"internal:has-text\\\" ? \\\"has-text\\\" : \\\"has-not-text\\\", text, { exact });\\n        const options = {};\\n        if (nextPart.name === \\\"internal:has-text\\\")\\n          options.hasText = text;\\n        else\\n          options.hasNotText = text;\\n        const combinedPart = factory.generateLocator(base, \\\"default\\\", selectorPart, options);\\n        tokens.push([factory.chainLocators([locatorPart, nextLocatorPart]), combinedPart]);\\n        index++;\\n        continue;\\n      }\\n    }\\n    let locatorPartWithEngine;\\n    if ([\\\"xpath\\\", \\\"css\\\"].includes(part.name)) {\\n      const selectorPart2 = stringifySelector(\\n        { parts: [part] },\\n        /* forceEngineName */\\n        true\\n      );\\n      locatorPartWithEngine = factory.generateLocator(base, \\\"default\\\", selectorPart2);\\n    }\\n    tokens.push([locatorPart, locatorPartWithEngine].filter(Boolean));\\n  }\\n  return combineTokens(factory, tokens, maxOutputSize);\\n}\\nfunction combineTokens(factory, tokens, maxOutputSize) {\\n  const currentTokens = tokens.map(() => \\\"\\\");\\n  const result = [];\\n  const visit = (index) => {\\n    if (index === tokens.length) {\\n      result.push(factory.chainLocators(currentTokens));\\n      return result.length < maxOutputSize;\\n    }\\n    for (const taken of tokens[index]) {\\n      currentTokens[index] = taken;\\n      if (!visit(index + 1))\\n        return false;\\n    }\\n    return true;\\n  };\\n  visit(0);\\n  return result;\\n}\\nfunction detectExact(text) {\\n  let exact = false;\\n  const match = text.match(/^\\\\/(.*)\\\\/([igm]*)$/);\\n  if (match)\\n    return { text: new RegExp(match[1], match[2]) };\\n  if (text.endsWith('\\\"')) {\\n    text = JSON.parse(text);\\n    exact = true;\\n  } else if (text.endsWith('\\\"s')) {\\n    text = JSON.parse(text.substring(0, text.length - 1));\\n    exact = true;\\n  } else if (text.endsWith('\\\"i')) {\\n    text = JSON.parse(text.substring(0, text.length - 1));\\n    exact = false;\\n  }\\n  return { exact, text };\\n}\\nvar JavaScriptLocatorFactory = class {\\n  constructor(preferredQuote) {\\n    this.preferredQuote = preferredQuote;\\n  }\\n  generateLocator(base, kind, body, options = {}) {\\n    switch (kind) {\\n      case \\\"default\\\":\\n        if (options.hasText !== void 0)\\n          return `locator(${this.quote(body)}, { hasText: ${this.toHasText(options.hasText)} })`;\\n        if (options.hasNotText !== void 0)\\n          return `locator(${this.quote(body)}, { hasNotText: ${this.toHasText(options.hasNotText)} })`;\\n        return `locator(${this.quote(body)})`;\\n      case \\\"frame-locator\\\":\\n        return `frameLocator(${this.quote(body)})`;\\n      case \\\"frame\\\":\\n        return `contentFrame()`;\\n      case \\\"nth\\\":\\n        return `nth(${body})`;\\n      case \\\"first\\\":\\n        return `first()`;\\n      case \\\"last\\\":\\n        return `last()`;\\n      case \\\"visible\\\":\\n        return `filter({ visible: ${body === \\\"true\\\" ? \\\"true\\\" : \\\"false\\\"} })`;\\n      case \\\"role\\\":\\n        const attrs = [];\\n        if (isRegExp(options.name)) {\\n          attrs.push(`name: ${this.regexToSourceString(options.name)}`);\\n        } else if (typeof options.name === \\\"string\\\") {\\n          attrs.push(`name: ${this.quote(options.name)}`);\\n          if (options.exact)\\n            attrs.push(`exact: true`);\\n        }\\n        for (const { name, value } of options.attrs)\\n          attrs.push(`${name}: ${typeof value === \\\"string\\\" ? this.quote(value) : value}`);\\n        const attrString = attrs.length ? `, { ${attrs.join(\\\", \\\")} }` : \\\"\\\";\\n        return `getByRole(${this.quote(body)}${attrString})`;\\n      case \\\"has-text\\\":\\n        return `filter({ hasText: ${this.toHasText(body)} })`;\\n      case \\\"has-not-text\\\":\\n        return `filter({ hasNotText: ${this.toHasText(body)} })`;\\n      case \\\"has\\\":\\n        return `filter({ has: ${body} })`;\\n      case \\\"hasNot\\\":\\n        return `filter({ hasNot: ${body} })`;\\n      case \\\"and\\\":\\n        return `and(${body})`;\\n      case \\\"or\\\":\\n        return `or(${body})`;\\n      case \\\"chain\\\":\\n        return `locator(${body})`;\\n      case \\\"test-id\\\":\\n        return `getByTestId(${this.toTestIdValue(body)})`;\\n      case \\\"text\\\":\\n        return this.toCallWithExact(\\\"getByText\\\", body, !!options.exact);\\n      case \\\"alt\\\":\\n        return this.toCallWithExact(\\\"getByAltText\\\", body, !!options.exact);\\n      case \\\"placeholder\\\":\\n        return this.toCallWithExact(\\\"getByPlaceholder\\\", body, !!options.exact);\\n      case \\\"label\\\":\\n        return this.toCallWithExact(\\\"getByLabel\\\", body, !!options.exact);\\n      case \\\"title\\\":\\n        return this.toCallWithExact(\\\"getByTitle\\\", body, !!options.exact);\\n      default:\\n        throw new Error(\\\"Unknown selector kind \\\" + kind);\\n    }\\n  }\\n  chainLocators(locators) {\\n    return locators.join(\\\".\\\");\\n  }\\n  regexToSourceString(re) {\\n    return normalizeEscapedRegexQuotes(String(re));\\n  }\\n  toCallWithExact(method, body, exact) {\\n    if (isRegExp(body))\\n      return `${method}(${this.regexToSourceString(body)})`;\\n    return exact ? `${method}(${this.quote(body)}, { exact: true })` : `${method}(${this.quote(body)})`;\\n  }\\n  toHasText(body) {\\n    if (isRegExp(body))\\n      return this.regexToSourceString(body);\\n    return this.quote(body);\\n  }\\n  toTestIdValue(value) {\\n    if (isRegExp(value))\\n      return this.regexToSourceString(value);\\n    return this.quote(value);\\n  }\\n  quote(text) {\\n    var _a;\\n    return escapeWithQuotes(text, (_a = this.preferredQuote) != null ? _a : \\\"'\\\");\\n  }\\n};\\nvar PythonLocatorFactory = class {\\n  generateLocator(base, kind, body, options = {}) {\\n    switch (kind) {\\n      case \\\"default\\\":\\n        if (options.hasText !== void 0)\\n          return `locator(${this.quote(body)}, has_text=${this.toHasText(options.hasText)})`;\\n        if (options.hasNotText !== void 0)\\n          return `locator(${this.quote(body)}, has_not_text=${this.toHasText(options.hasNotText)})`;\\n        return `locator(${this.quote(body)})`;\\n      case \\\"frame-locator\\\":\\n        return `frame_locator(${this.quote(body)})`;\\n      case \\\"frame\\\":\\n        return `content_frame`;\\n      case \\\"nth\\\":\\n        return `nth(${body})`;\\n      case \\\"first\\\":\\n        return `first`;\\n      case \\\"last\\\":\\n        return `last`;\\n      case \\\"visible\\\":\\n        return `filter(visible=${body === \\\"true\\\" ? \\\"True\\\" : \\\"False\\\"})`;\\n      case \\\"role\\\":\\n        const attrs = [];\\n        if (isRegExp(options.name)) {\\n          attrs.push(`name=${this.regexToString(options.name)}`);\\n        } else if (typeof options.name === \\\"string\\\") {\\n          attrs.push(`name=${this.quote(options.name)}`);\\n          if (options.exact)\\n            attrs.push(`exact=True`);\\n        }\\n        for (const { name, value } of options.attrs) {\\n          let valueString = typeof value === \\\"string\\\" ? this.quote(value) : value;\\n          if (typeof value === \\\"boolean\\\")\\n            valueString = value ? \\\"True\\\" : \\\"False\\\";\\n          attrs.push(`${toSnakeCase(name)}=${valueString}`);\\n        }\\n        const attrString = attrs.length ? `, ${attrs.join(\\\", \\\")}` : \\\"\\\";\\n        return `get_by_role(${this.quote(body)}${attrString})`;\\n      case \\\"has-text\\\":\\n        return `filter(has_text=${this.toHasText(body)})`;\\n      case \\\"has-not-text\\\":\\n        return `filter(has_not_text=${this.toHasText(body)})`;\\n      case \\\"has\\\":\\n        return `filter(has=${body})`;\\n      case \\\"hasNot\\\":\\n        return `filter(has_not=${body})`;\\n      case \\\"and\\\":\\n        return `and_(${body})`;\\n      case \\\"or\\\":\\n        return `or_(${body})`;\\n      case \\\"chain\\\":\\n        return `locator(${body})`;\\n      case \\\"test-id\\\":\\n        return `get_by_test_id(${this.toTestIdValue(body)})`;\\n      case \\\"text\\\":\\n        return this.toCallWithExact(\\\"get_by_text\\\", body, !!options.exact);\\n      case \\\"alt\\\":\\n        return this.toCallWithExact(\\\"get_by_alt_text\\\", body, !!options.exact);\\n      case \\\"placeholder\\\":\\n        return this.toCallWithExact(\\\"get_by_placeholder\\\", body, !!options.exact);\\n      case \\\"label\\\":\\n        return this.toCallWithExact(\\\"get_by_label\\\", body, !!options.exact);\\n      case \\\"title\\\":\\n        return this.toCallWithExact(\\\"get_by_title\\\", body, !!options.exact);\\n      default:\\n        throw new Error(\\\"Unknown selector kind \\\" + kind);\\n    }\\n  }\\n  chainLocators(locators) {\\n    return locators.join(\\\".\\\");\\n  }\\n  regexToString(body) {\\n    const suffix = body.flags.includes(\\\"i\\\") ? \\\", re.IGNORECASE\\\" : \\\"\\\";\\n    return `re.compile(r\\\"${normalizeEscapedRegexQuotes(body.source).replace(/\\\\\\\\\\\\//, \\\"/\\\").replace(/\\\"/g, '\\\\\\\\\\\"')}\\\"${suffix})`;\\n  }\\n  toCallWithExact(method, body, exact) {\\n    if (isRegExp(body))\\n      return `${method}(${this.regexToString(body)})`;\\n    if (exact)\\n      return `${method}(${this.quote(body)}, exact=True)`;\\n    return `${method}(${this.quote(body)})`;\\n  }\\n  toHasText(body) {\\n    if (isRegExp(body))\\n      return this.regexToString(body);\\n    return `${this.quote(body)}`;\\n  }\\n  toTestIdValue(value) {\\n    if (isRegExp(value))\\n      return this.regexToString(value);\\n    return this.quote(value);\\n  }\\n  quote(text) {\\n    return escapeWithQuotes(text, '\\\"');\\n  }\\n};\\nvar JavaLocatorFactory = class {\\n  generateLocator(base, kind, body, options = {}) {\\n    let clazz;\\n    switch (base) {\\n      case \\\"page\\\":\\n        clazz = \\\"Page\\\";\\n        break;\\n      case \\\"frame-locator\\\":\\n        clazz = \\\"FrameLocator\\\";\\n        break;\\n      case \\\"locator\\\":\\n        clazz = \\\"Locator\\\";\\n        break;\\n    }\\n    switch (kind) {\\n      case \\\"default\\\":\\n        if (options.hasText !== void 0)\\n          return `locator(${this.quote(body)}, new ${clazz}.LocatorOptions().setHasText(${this.toHasText(options.hasText)}))`;\\n        if (options.hasNotText !== void 0)\\n          return `locator(${this.quote(body)}, new ${clazz}.LocatorOptions().setHasNotText(${this.toHasText(options.hasNotText)}))`;\\n        return `locator(${this.quote(body)})`;\\n      case \\\"frame-locator\\\":\\n        return `frameLocator(${this.quote(body)})`;\\n      case \\\"frame\\\":\\n        return `contentFrame()`;\\n      case \\\"nth\\\":\\n        return `nth(${body})`;\\n      case \\\"first\\\":\\n        return `first()`;\\n      case \\\"last\\\":\\n        return `last()`;\\n      case \\\"visible\\\":\\n        return `filter(new ${clazz}.FilterOptions().setVisible(${body === \\\"true\\\" ? \\\"true\\\" : \\\"false\\\"}))`;\\n      case \\\"role\\\":\\n        const attrs = [];\\n        if (isRegExp(options.name)) {\\n          attrs.push(`.setName(${this.regexToString(options.name)})`);\\n        } else if (typeof options.name === \\\"string\\\") {\\n          attrs.push(`.setName(${this.quote(options.name)})`);\\n          if (options.exact)\\n            attrs.push(`.setExact(true)`);\\n        }\\n        for (const { name, value } of options.attrs)\\n          attrs.push(`.set${toTitleCase(name)}(${typeof value === \\\"string\\\" ? this.quote(value) : value})`);\\n        const attrString = attrs.length ? `, new ${clazz}.GetByRoleOptions()${attrs.join(\\\"\\\")}` : \\\"\\\";\\n        return `getByRole(AriaRole.${toSnakeCase(body).toUpperCase()}${attrString})`;\\n      case \\\"has-text\\\":\\n        return `filter(new ${clazz}.FilterOptions().setHasText(${this.toHasText(body)}))`;\\n      case \\\"has-not-text\\\":\\n        return `filter(new ${clazz}.FilterOptions().setHasNotText(${this.toHasText(body)}))`;\\n      case \\\"has\\\":\\n        return `filter(new ${clazz}.FilterOptions().setHas(${body}))`;\\n      case \\\"hasNot\\\":\\n        return `filter(new ${clazz}.FilterOptions().setHasNot(${body}))`;\\n      case \\\"and\\\":\\n        return `and(${body})`;\\n      case \\\"or\\\":\\n        return `or(${body})`;\\n      case \\\"chain\\\":\\n        return `locator(${body})`;\\n      case \\\"test-id\\\":\\n        return `getByTestId(${this.toTestIdValue(body)})`;\\n      case \\\"text\\\":\\n        return this.toCallWithExact(clazz, \\\"getByText\\\", body, !!options.exact);\\n      case \\\"alt\\\":\\n        return this.toCallWithExact(clazz, \\\"getByAltText\\\", body, !!options.exact);\\n      case \\\"placeholder\\\":\\n        return this.toCallWithExact(clazz, \\\"getByPlaceholder\\\", body, !!options.exact);\\n      case \\\"label\\\":\\n        return this.toCallWithExact(clazz, \\\"getByLabel\\\", body, !!options.exact);\\n      case \\\"title\\\":\\n        return this.toCallWithExact(clazz, \\\"getByTitle\\\", body, !!options.exact);\\n      default:\\n        throw new Error(\\\"Unknown selector kind \\\" + kind);\\n    }\\n  }\\n  chainLocators(locators) {\\n    return locators.join(\\\".\\\");\\n  }\\n  regexToString(body) {\\n    const suffix = body.flags.includes(\\\"i\\\") ? \\\", Pattern.CASE_INSENSITIVE\\\" : \\\"\\\";\\n    return `Pattern.compile(${this.quote(normalizeEscapedRegexQuotes(body.source))}${suffix})`;\\n  }\\n  toCallWithExact(clazz, method, body, exact) {\\n    if (isRegExp(body))\\n      return `${method}(${this.regexToString(body)})`;\\n    if (exact)\\n      return `${method}(${this.quote(body)}, new ${clazz}.${toTitleCase(method)}Options().setExact(true))`;\\n    return `${method}(${this.quote(body)})`;\\n  }\\n  toHasText(body) {\\n    if (isRegExp(body))\\n      return this.regexToString(body);\\n    return this.quote(body);\\n  }\\n  toTestIdValue(value) {\\n    if (isRegExp(value))\\n      return this.regexToString(value);\\n    return this.quote(value);\\n  }\\n  quote(text) {\\n    return escapeWithQuotes(text, '\\\"');\\n  }\\n};\\nvar CSharpLocatorFactory = class {\\n  generateLocator(base, kind, body, options = {}) {\\n    switch (kind) {\\n      case \\\"default\\\":\\n        if (options.hasText !== void 0)\\n          return `Locator(${this.quote(body)}, new() { ${this.toHasText(options.hasText)} })`;\\n        if (options.hasNotText !== void 0)\\n          return `Locator(${this.quote(body)}, new() { ${this.toHasNotText(options.hasNotText)} })`;\\n        return `Locator(${this.quote(body)})`;\\n      case \\\"frame-locator\\\":\\n        return `FrameLocator(${this.quote(body)})`;\\n      case \\\"frame\\\":\\n        return `ContentFrame`;\\n      case \\\"nth\\\":\\n        return `Nth(${body})`;\\n      case \\\"first\\\":\\n        return `First`;\\n      case \\\"last\\\":\\n        return `Last`;\\n      case \\\"visible\\\":\\n        return `Filter(new() { Visible = ${body === \\\"true\\\" ? \\\"true\\\" : \\\"false\\\"} })`;\\n      case \\\"role\\\":\\n        const attrs = [];\\n        if (isRegExp(options.name)) {\\n          attrs.push(`NameRegex = ${this.regexToString(options.name)}`);\\n        } else if (typeof options.name === \\\"string\\\") {\\n          attrs.push(`Name = ${this.quote(options.name)}`);\\n          if (options.exact)\\n            attrs.push(`Exact = true`);\\n        }\\n        for (const { name, value } of options.attrs)\\n          attrs.push(`${toTitleCase(name)} = ${typeof value === \\\"string\\\" ? this.quote(value) : value}`);\\n        const attrString = attrs.length ? `, new() { ${attrs.join(\\\", \\\")} }` : \\\"\\\";\\n        return `GetByRole(AriaRole.${toTitleCase(body)}${attrString})`;\\n      case \\\"has-text\\\":\\n        return `Filter(new() { ${this.toHasText(body)} })`;\\n      case \\\"has-not-text\\\":\\n        return `Filter(new() { ${this.toHasNotText(body)} })`;\\n      case \\\"has\\\":\\n        return `Filter(new() { Has = ${body} })`;\\n      case \\\"hasNot\\\":\\n        return `Filter(new() { HasNot = ${body} })`;\\n      case \\\"and\\\":\\n        return `And(${body})`;\\n      case \\\"or\\\":\\n        return `Or(${body})`;\\n      case \\\"chain\\\":\\n        return `Locator(${body})`;\\n      case \\\"test-id\\\":\\n        return `GetByTestId(${this.toTestIdValue(body)})`;\\n      case \\\"text\\\":\\n        return this.toCallWithExact(\\\"GetByText\\\", body, !!options.exact);\\n      case \\\"alt\\\":\\n        return this.toCallWithExact(\\\"GetByAltText\\\", body, !!options.exact);\\n      case \\\"placeholder\\\":\\n        return this.toCallWithExact(\\\"GetByPlaceholder\\\", body, !!options.exact);\\n      case \\\"label\\\":\\n        return this.toCallWithExact(\\\"GetByLabel\\\", body, !!options.exact);\\n      case \\\"title\\\":\\n        return this.toCallWithExact(\\\"GetByTitle\\\", body, !!options.exact);\\n      default:\\n        throw new Error(\\\"Unknown selector kind \\\" + kind);\\n    }\\n  }\\n  chainLocators(locators) {\\n    return locators.join(\\\".\\\");\\n  }\\n  regexToString(body) {\\n    const suffix = body.flags.includes(\\\"i\\\") ? \\\", RegexOptions.IgnoreCase\\\" : \\\"\\\";\\n    return `new Regex(${this.quote(normalizeEscapedRegexQuotes(body.source))}${suffix})`;\\n  }\\n  toCallWithExact(method, body, exact) {\\n    if (isRegExp(body))\\n      return `${method}(${this.regexToString(body)})`;\\n    if (exact)\\n      return `${method}(${this.quote(body)}, new() { Exact = true })`;\\n    return `${method}(${this.quote(body)})`;\\n  }\\n  toHasText(body) {\\n    if (isRegExp(body))\\n      return `HasTextRegex = ${this.regexToString(body)}`;\\n    return `HasText = ${this.quote(body)}`;\\n  }\\n  toTestIdValue(value) {\\n    if (isRegExp(value))\\n      return this.regexToString(value);\\n    return this.quote(value);\\n  }\\n  toHasNotText(body) {\\n    if (isRegExp(body))\\n      return `HasNotTextRegex = ${this.regexToString(body)}`;\\n    return `HasNotText = ${this.quote(body)}`;\\n  }\\n  quote(text) {\\n    return escapeWithQuotes(text, '\\\"');\\n  }\\n};\\nvar JsonlLocatorFactory = class {\\n  generateLocator(base, kind, body, options = {}) {\\n    return JSON.stringify({\\n      kind,\\n      body,\\n      options\\n    });\\n  }\\n  chainLocators(locators) {\\n    const objects = locators.map((l) => JSON.parse(l));\\n    for (let i = 0; i < objects.length - 1; ++i)\\n      objects[i].next = objects[i + 1];\\n    return JSON.stringify(objects[0]);\\n  }\\n};\\nvar generators = {\\n  javascript: JavaScriptLocatorFactory,\\n  python: PythonLocatorFactory,\\n  java: JavaLocatorFactory,\\n  csharp: CSharpLocatorFactory,\\n  jsonl: JsonlLocatorFactory\\n};\\nfunction isRegExp(obj) {\\n  return obj instanceof RegExp;\\n}\\n\\n// packages/playwright-injected/src/domUtils.ts\\nvar globalOptions = {};\\nfunction setGlobalOptions(options) {\\n  globalOptions = options;\\n}\\nfunction isInsideScope(scope, element) {\\n  while (element) {\\n    if (scope.contains(element))\\n      return true;\\n    element = enclosingShadowHost(element);\\n  }\\n  return false;\\n}\\nfunction parentElementOrShadowHost(element) {\\n  if (element.parentElement)\\n    return element.parentElement;\\n  if (!element.parentNode)\\n    return;\\n  if (element.parentNode.nodeType === 11 && element.parentNode.host)\\n    return element.parentNode.host;\\n}\\nfunction enclosingShadowRootOrDocument(element) {\\n  let node = element;\\n  while (node.parentNode)\\n    node = node.parentNode;\\n  if (node.nodeType === 11 || node.nodeType === 9)\\n    return node;\\n}\\nfunction enclosingShadowHost(element) {\\n  while (element.parentElement)\\n    element = element.parentElement;\\n  return parentElementOrShadowHost(element);\\n}\\nfunction closestCrossShadow(element, css, scope) {\\n  while (element) {\\n    const closest = element.closest(css);\\n    if (scope && closest !== scope && (closest == null ? void 0 : closest.contains(scope)))\\n      return;\\n    if (closest)\\n      return closest;\\n    element = enclosingShadowHost(element);\\n  }\\n}\\nfunction getElementComputedStyle(element, pseudo) {\\n  const cache = pseudo === \\\"::before\\\" ? cacheStyleBefore : pseudo === \\\"::after\\\" ? cacheStyleAfter : cacheStyle;\\n  if (cache && cache.has(element))\\n    return cache.get(element);\\n  const style = element.ownerDocument && element.ownerDocument.defaultView ? element.ownerDocument.defaultView.getComputedStyle(element, pseudo) : void 0;\\n  cache == null ? void 0 : cache.set(element, style);\\n  return style;\\n}\\nfunction isElementStyleVisibilityVisible(element, style) {\\n  style = style != null ? style : getElementComputedStyle(element);\\n  if (!style)\\n    return true;\\n  if (Element.prototype.checkVisibility && globalOptions.browserNameForWorkarounds !== \\\"webkit\\\") {\\n    if (!element.checkVisibility())\\n      return false;\\n  } else {\\n    const detailsOrSummary = element.closest(\\\"details,summary\\\");\\n    if (detailsOrSummary !== element && (detailsOrSummary == null ? void 0 : detailsOrSummary.nodeName) === \\\"DETAILS\\\" && !detailsOrSummary.open)\\n      return false;\\n  }\\n  if (style.visibility !== \\\"visible\\\")\\n    return false;\\n  return true;\\n}\\nfunction computeBox(element) {\\n  const style = getElementComputedStyle(element);\\n  if (!style)\\n    return { visible: true, inline: false };\\n  const cursor = style.cursor;\\n  if (style.display === \\\"contents\\\") {\\n    for (let child = element.firstChild; child; child = child.nextSibling) {\\n      if (child.nodeType === 1 && isElementVisible(child))\\n        return { visible: true, inline: false, cursor };\\n      if (child.nodeType === 3 && isVisibleTextNode(child))\\n        return { visible: true, inline: true, cursor };\\n    }\\n    return { visible: false, inline: false, cursor };\\n  }\\n  if (!isElementStyleVisibilityVisible(element, style))\\n    return { cursor, visible: false, inline: false };\\n  const rect = element.getBoundingClientRect();\\n  return { rect, cursor, visible: rect.width > 0 && rect.height > 0, inline: style.display === \\\"inline\\\" };\\n}\\nfunction isElementVisible(element) {\\n  return computeBox(element).visible;\\n}\\nfunction isVisibleTextNode(node) {\\n  const range = node.ownerDocument.createRange();\\n  range.selectNode(node);\\n  const rect = range.getBoundingClientRect();\\n  return rect.width > 0 && rect.height > 0;\\n}\\nfunction elementSafeTagName(element) {\\n  const tagName = element.tagName;\\n  if (typeof tagName === \\\"string\\\")\\n    return tagName.toUpperCase();\\n  if (element instanceof HTMLFormElement)\\n    return \\\"FORM\\\";\\n  return element.tagName.toUpperCase();\\n}\\nvar cacheStyle;\\nvar cacheStyleBefore;\\nvar cacheStyleAfter;\\nvar cachesCounter = 0;\\nfunction beginDOMCaches() {\\n  ++cachesCounter;\\n  cacheStyle != null ? cacheStyle : cacheStyle = /* @__PURE__ */ new Map();\\n  cacheStyleBefore != null ? cacheStyleBefore : cacheStyleBefore = /* @__PURE__ */ new Map();\\n  cacheStyleAfter != null ? cacheStyleAfter : cacheStyleAfter = /* @__PURE__ */ new Map();\\n}\\nfunction endDOMCaches() {\\n  if (!--cachesCounter) {\\n    cacheStyle = void 0;\\n    cacheStyleBefore = void 0;\\n    cacheStyleAfter = void 0;\\n  }\\n}\\n\\n// packages/playwright-injected/src/roleUtils.ts\\nfunction hasExplicitAccessibleName(e) {\\n  return e.hasAttribute(\\\"aria-label\\\") || e.hasAttribute(\\\"aria-labelledby\\\");\\n}\\nvar kAncestorPreventingLandmark = \\\"article:not([role]), aside:not([role]), main:not([role]), nav:not([role]), section:not([role]), [role=article], [role=complementary], [role=main], [role=navigation], [role=region]\\\";\\nvar kGlobalAriaAttributes = [\\n  [\\\"aria-atomic\\\", void 0],\\n  [\\\"aria-busy\\\", void 0],\\n  [\\\"aria-controls\\\", void 0],\\n  [\\\"aria-current\\\", void 0],\\n  [\\\"aria-describedby\\\", void 0],\\n  [\\\"aria-details\\\", void 0],\\n  // Global use deprecated in ARIA 1.2\\n  // ['aria-disabled', undefined],\\n  [\\\"aria-dropeffect\\\", void 0],\\n  // Global use deprecated in ARIA 1.2\\n  // ['aria-errormessage', undefined],\\n  [\\\"aria-flowto\\\", void 0],\\n  [\\\"aria-grabbed\\\", void 0],\\n  // Global use deprecated in ARIA 1.2\\n  // ['aria-haspopup', undefined],\\n  [\\\"aria-hidden\\\", void 0],\\n  // Global use deprecated in ARIA 1.2\\n  // ['aria-invalid', undefined],\\n  [\\\"aria-keyshortcuts\\\", void 0],\\n  [\\\"aria-label\\\", [\\\"caption\\\", \\\"code\\\", \\\"deletion\\\", \\\"emphasis\\\", \\\"generic\\\", \\\"insertion\\\", \\\"paragraph\\\", \\\"presentation\\\", \\\"strong\\\", \\\"subscript\\\", \\\"superscript\\\"]],\\n  [\\\"aria-labelledby\\\", [\\\"caption\\\", \\\"code\\\", \\\"deletion\\\", \\\"emphasis\\\", \\\"generic\\\", \\\"insertion\\\", \\\"paragraph\\\", \\\"presentation\\\", \\\"strong\\\", \\\"subscript\\\", \\\"superscript\\\"]],\\n  [\\\"aria-live\\\", void 0],\\n  [\\\"aria-owns\\\", void 0],\\n  [\\\"aria-relevant\\\", void 0],\\n  [\\\"aria-roledescription\\\", [\\\"generic\\\"]]\\n];\\nfunction hasGlobalAriaAttribute(element, forRole) {\\n  return kGlobalAriaAttributes.some(([attr, prohibited]) => {\\n    return !(prohibited == null ? void 0 : prohibited.includes(forRole || \\\"\\\")) && element.hasAttribute(attr);\\n  });\\n}\\nfunction hasTabIndex(element) {\\n  return !Number.isNaN(Number(String(element.getAttribute(\\\"tabindex\\\"))));\\n}\\nfunction isFocusable(element) {\\n  return !isNativelyDisabled(element) && (isNativelyFocusable(element) || hasTabIndex(element));\\n}\\nfunction isNativelyFocusable(element) {\\n  const tagName = elementSafeTagName(element);\\n  if ([\\\"BUTTON\\\", \\\"DETAILS\\\", \\\"SELECT\\\", \\\"TEXTAREA\\\"].includes(tagName))\\n    return true;\\n  if (tagName === \\\"A\\\" || tagName === \\\"AREA\\\")\\n    return element.hasAttribute(\\\"href\\\");\\n  if (tagName === \\\"INPUT\\\")\\n    return !element.hidden;\\n  return false;\\n}\\nvar kImplicitRoleByTagName = {\\n  \\\"A\\\": (e) => {\\n    return e.hasAttribute(\\\"href\\\") ? \\\"link\\\" : null;\\n  },\\n  \\\"AREA\\\": (e) => {\\n    return e.hasAttribute(\\\"href\\\") ? \\\"link\\\" : null;\\n  },\\n  \\\"ARTICLE\\\": () => \\\"article\\\",\\n  \\\"ASIDE\\\": () => \\\"complementary\\\",\\n  \\\"BLOCKQUOTE\\\": () => \\\"blockquote\\\",\\n  \\\"BUTTON\\\": () => \\\"button\\\",\\n  \\\"CAPTION\\\": () => \\\"caption\\\",\\n  \\\"CODE\\\": () => \\\"code\\\",\\n  \\\"DATALIST\\\": () => \\\"listbox\\\",\\n  \\\"DD\\\": () => \\\"definition\\\",\\n  \\\"DEL\\\": () => \\\"deletion\\\",\\n  \\\"DETAILS\\\": () => \\\"group\\\",\\n  \\\"DFN\\\": () => \\\"term\\\",\\n  \\\"DIALOG\\\": () => \\\"dialog\\\",\\n  \\\"DT\\\": () => \\\"term\\\",\\n  \\\"EM\\\": () => \\\"emphasis\\\",\\n  \\\"FIELDSET\\\": () => \\\"group\\\",\\n  \\\"FIGURE\\\": () => \\\"figure\\\",\\n  \\\"FOOTER\\\": (e) => closestCrossShadow(e, kAncestorPreventingLandmark) ? null : \\\"contentinfo\\\",\\n  \\\"FORM\\\": (e) => hasExplicitAccessibleName(e) ? \\\"form\\\" : null,\\n  \\\"H1\\\": () => \\\"heading\\\",\\n  \\\"H2\\\": () => \\\"heading\\\",\\n  \\\"H3\\\": () => \\\"heading\\\",\\n  \\\"H4\\\": () => \\\"heading\\\",\\n  \\\"H5\\\": () => \\\"heading\\\",\\n  \\\"H6\\\": () => \\\"heading\\\",\\n  \\\"HEADER\\\": (e) => closestCrossShadow(e, kAncestorPreventingLandmark) ? null : \\\"banner\\\",\\n  \\\"HR\\\": () => \\\"separator\\\",\\n  \\\"HTML\\\": () => \\\"document\\\",\\n  \\\"IMG\\\": (e) => e.getAttribute(\\\"alt\\\") === \\\"\\\" && !e.getAttribute(\\\"title\\\") && !hasGlobalAriaAttribute(e) && !hasTabIndex(e) ? \\\"presentation\\\" : \\\"img\\\",\\n  \\\"INPUT\\\": (e) => {\\n    const type = e.type.toLowerCase();\\n    if (type === \\\"search\\\")\\n      return e.hasAttribute(\\\"list\\\") ? \\\"combobox\\\" : \\\"searchbox\\\";\\n    if ([\\\"email\\\", \\\"tel\\\", \\\"text\\\", \\\"url\\\", \\\"\\\"].includes(type)) {\\n      const list = getIdRefs(e, e.getAttribute(\\\"list\\\"))[0];\\n      return list && elementSafeTagName(list) === \\\"DATALIST\\\" ? \\\"combobox\\\" : \\\"textbox\\\";\\n    }\\n    if (type === \\\"hidden\\\")\\n      return null;\\n    if (type === \\\"file\\\")\\n      return \\\"button\\\";\\n    return inputTypeToRole[type] || \\\"textbox\\\";\\n  },\\n  \\\"INS\\\": () => \\\"insertion\\\",\\n  \\\"LI\\\": () => \\\"listitem\\\",\\n  \\\"MAIN\\\": () => \\\"main\\\",\\n  \\\"MARK\\\": () => \\\"mark\\\",\\n  \\\"MATH\\\": () => \\\"math\\\",\\n  \\\"MENU\\\": () => \\\"list\\\",\\n  \\\"METER\\\": () => \\\"meter\\\",\\n  \\\"NAV\\\": () => \\\"navigation\\\",\\n  \\\"OL\\\": () => \\\"list\\\",\\n  \\\"OPTGROUP\\\": () => \\\"group\\\",\\n  \\\"OPTION\\\": () => \\\"option\\\",\\n  \\\"OUTPUT\\\": () => \\\"status\\\",\\n  \\\"P\\\": () => \\\"paragraph\\\",\\n  \\\"PROGRESS\\\": () => \\\"progressbar\\\",\\n  \\\"SEARCH\\\": () => \\\"search\\\",\\n  \\\"SECTION\\\": (e) => hasExplicitAccessibleName(e) ? \\\"region\\\" : null,\\n  \\\"SELECT\\\": (e) => e.hasAttribute(\\\"multiple\\\") || e.size > 1 ? \\\"listbox\\\" : \\\"combobox\\\",\\n  \\\"STRONG\\\": () => \\\"strong\\\",\\n  \\\"SUB\\\": () => \\\"subscript\\\",\\n  \\\"SUP\\\": () => \\\"superscript\\\",\\n  // For <svg> we default to Chrome behavior:\\n  // - Chrome reports 'img'.\\n  // - Firefox reports 'diagram' that is not in official ARIA spec yet.\\n  // - Safari reports 'no role', but still computes accessible name.\\n  \\\"SVG\\\": () => \\\"img\\\",\\n  \\\"TABLE\\\": () => \\\"table\\\",\\n  \\\"TBODY\\\": () => \\\"rowgroup\\\",\\n  \\\"TD\\\": (e) => {\\n    const table = closestCrossShadow(e, \\\"table\\\");\\n    const role = table ? getExplicitAriaRole(table) : \\\"\\\";\\n    return role === \\\"grid\\\" || role === \\\"treegrid\\\" ? \\\"gridcell\\\" : \\\"cell\\\";\\n  },\\n  \\\"TEXTAREA\\\": () => \\\"textbox\\\",\\n  \\\"TFOOT\\\": () => \\\"rowgroup\\\",\\n  \\\"TH\\\": (e) => {\\n    const scope = e.getAttribute(\\\"scope\\\");\\n    if (scope === \\\"col\\\" || scope === \\\"colgroup\\\")\\n      return \\\"columnheader\\\";\\n    if (scope === \\\"row\\\" || scope === \\\"rowgroup\\\")\\n      return \\\"rowheader\\\";\\n    const nextSibling = e.nextElementSibling;\\n    const prevSibling = e.previousElementSibling;\\n    const row = !!e.parentElement && elementSafeTagName(e.parentElement) === \\\"TR\\\" ? e.parentElement : void 0;\\n    if (!nextSibling && !prevSibling) {\\n      if (row) {\\n        const table = closestCrossShadow(row, \\\"table\\\");\\n        if (table && table.rows.length <= 1)\\n          return null;\\n      }\\n      return \\\"columnheader\\\";\\n    }\\n    if (isHeaderCell(nextSibling) && isHeaderCell(prevSibling))\\n      return \\\"columnheader\\\";\\n    if (isNonEmptyDataCell(nextSibling) || isNonEmptyDataCell(prevSibling))\\n      return \\\"rowheader\\\";\\n    return \\\"columnheader\\\";\\n  },\\n  \\\"THEAD\\\": () => \\\"rowgroup\\\",\\n  \\\"TIME\\\": () => \\\"time\\\",\\n  \\\"TR\\\": () => \\\"row\\\",\\n  \\\"UL\\\": () => \\\"list\\\"\\n};\\nfunction isHeaderCell(element) {\\n  return !!element && elementSafeTagName(element) === \\\"TH\\\";\\n}\\nfunction isNonEmptyDataCell(element) {\\n  var _a;\\n  if (!element || elementSafeTagName(element) !== \\\"TD\\\")\\n    return false;\\n  return !!(((_a = element.textContent) == null ? void 0 : _a.trim()) || element.children.length > 0);\\n}\\nvar kPresentationInheritanceParents = {\\n  \\\"DD\\\": [\\\"DL\\\", \\\"DIV\\\"],\\n  \\\"DIV\\\": [\\\"DL\\\"],\\n  \\\"DT\\\": [\\\"DL\\\", \\\"DIV\\\"],\\n  \\\"LI\\\": [\\\"OL\\\", \\\"UL\\\"],\\n  \\\"TBODY\\\": [\\\"TABLE\\\"],\\n  \\\"TD\\\": [\\\"TR\\\"],\\n  \\\"TFOOT\\\": [\\\"TABLE\\\"],\\n  \\\"TH\\\": [\\\"TR\\\"],\\n  \\\"THEAD\\\": [\\\"TABLE\\\"],\\n  \\\"TR\\\": [\\\"THEAD\\\", \\\"TBODY\\\", \\\"TFOOT\\\", \\\"TABLE\\\"]\\n};\\nfunction getImplicitAriaRole(element) {\\n  var _a;\\n  const implicitRole = ((_a = kImplicitRoleByTagName[elementSafeTagName(element)]) == null ? void 0 : _a.call(kImplicitRoleByTagName, element)) || \\\"\\\";\\n  if (!implicitRole)\\n    return null;\\n  let ancestor = element;\\n  while (ancestor) {\\n    const parent = parentElementOrShadowHost(ancestor);\\n    const parents = kPresentationInheritanceParents[elementSafeTagName(ancestor)];\\n    if (!parents || !parent || !parents.includes(elementSafeTagName(parent)))\\n      break;\\n    const parentExplicitRole = getExplicitAriaRole(parent);\\n    if ((parentExplicitRole === \\\"none\\\" || parentExplicitRole === \\\"presentation\\\") && !hasPresentationConflictResolution(parent, parentExplicitRole))\\n      return parentExplicitRole;\\n    ancestor = parent;\\n  }\\n  return implicitRole;\\n}\\nvar validRoles = [\\n  \\\"alert\\\",\\n  \\\"alertdialog\\\",\\n  \\\"application\\\",\\n  \\\"article\\\",\\n  \\\"banner\\\",\\n  \\\"blockquote\\\",\\n  \\\"button\\\",\\n  \\\"caption\\\",\\n  \\\"cell\\\",\\n  \\\"checkbox\\\",\\n  \\\"code\\\",\\n  \\\"columnheader\\\",\\n  \\\"combobox\\\",\\n  \\\"complementary\\\",\\n  \\\"contentinfo\\\",\\n  \\\"definition\\\",\\n  \\\"deletion\\\",\\n  \\\"dialog\\\",\\n  \\\"directory\\\",\\n  \\\"document\\\",\\n  \\\"emphasis\\\",\\n  \\\"feed\\\",\\n  \\\"figure\\\",\\n  \\\"form\\\",\\n  \\\"generic\\\",\\n  \\\"grid\\\",\\n  \\\"gridcell\\\",\\n  \\\"group\\\",\\n  \\\"heading\\\",\\n  \\\"img\\\",\\n  \\\"insertion\\\",\\n  \\\"link\\\",\\n  \\\"list\\\",\\n  \\\"listbox\\\",\\n  \\\"listitem\\\",\\n  \\\"log\\\",\\n  \\\"main\\\",\\n  \\\"mark\\\",\\n  \\\"marquee\\\",\\n  \\\"math\\\",\\n  \\\"meter\\\",\\n  \\\"menu\\\",\\n  \\\"menubar\\\",\\n  \\\"menuitem\\\",\\n  \\\"menuitemcheckbox\\\",\\n  \\\"menuitemradio\\\",\\n  \\\"navigation\\\",\\n  \\\"none\\\",\\n  \\\"note\\\",\\n  \\\"option\\\",\\n  \\\"paragraph\\\",\\n  \\\"presentation\\\",\\n  \\\"progressbar\\\",\\n  \\\"radio\\\",\\n  \\\"radiogroup\\\",\\n  \\\"region\\\",\\n  \\\"row\\\",\\n  \\\"rowgroup\\\",\\n  \\\"rowheader\\\",\\n  \\\"scrollbar\\\",\\n  \\\"search\\\",\\n  \\\"searchbox\\\",\\n  \\\"separator\\\",\\n  \\\"slider\\\",\\n  \\\"spinbutton\\\",\\n  \\\"status\\\",\\n  \\\"strong\\\",\\n  \\\"subscript\\\",\\n  \\\"superscript\\\",\\n  \\\"switch\\\",\\n  \\\"tab\\\",\\n  \\\"table\\\",\\n  \\\"tablist\\\",\\n  \\\"tabpanel\\\",\\n  \\\"term\\\",\\n  \\\"textbox\\\",\\n  \\\"time\\\",\\n  \\\"timer\\\",\\n  \\\"toolbar\\\",\\n  \\\"tooltip\\\",\\n  \\\"tree\\\",\\n  \\\"treegrid\\\",\\n  \\\"treeitem\\\"\\n];\\nfunction getExplicitAriaRole(element) {\\n  const roles = (element.getAttribute(\\\"role\\\") || \\\"\\\").split(\\\" \\\").map((role) => role.trim());\\n  return roles.find((role) => validRoles.includes(role)) || null;\\n}\\nfunction hasPresentationConflictResolution(element, role) {\\n  return hasGlobalAriaAttribute(element, role) || isFocusable(element);\\n}\\nfunction getAriaRole(element) {\\n  const explicitRole = getExplicitAriaRole(element);\\n  if (!explicitRole)\\n    return getImplicitAriaRole(element);\\n  if (explicitRole === \\\"none\\\" || explicitRole === \\\"presentation\\\") {\\n    const implicitRole = getImplicitAriaRole(element);\\n    if (hasPresentationConflictResolution(element, implicitRole))\\n      return implicitRole;\\n  }\\n  return explicitRole;\\n}\\nfunction getAriaBoolean(attr) {\\n  return attr === null ? void 0 : attr.toLowerCase() === \\\"true\\\";\\n}\\nfunction isElementIgnoredForAria(element) {\\n  return [\\\"STYLE\\\", \\\"SCRIPT\\\", \\\"NOSCRIPT\\\", \\\"TEMPLATE\\\"].includes(elementSafeTagName(element));\\n}\\nfunction isElementHiddenForAria(element) {\\n  if (isElementIgnoredForAria(element))\\n    return true;\\n  const style = getElementComputedStyle(element);\\n  const isSlot = element.nodeName === \\\"SLOT\\\";\\n  if ((style == null ? void 0 : style.display) === \\\"contents\\\" && !isSlot) {\\n    for (let child = element.firstChild; child; child = child.nextSibling) {\\n      if (child.nodeType === 1 && !isElementHiddenForAria(child))\\n        return false;\\n      if (child.nodeType === 3 && isVisibleTextNode(child))\\n        return false;\\n    }\\n    return true;\\n  }\\n  const isOptionInsideSelect = element.nodeName === \\\"OPTION\\\" && !!element.closest(\\\"select\\\");\\n  if (!isOptionInsideSelect && !isSlot && !isElementStyleVisibilityVisible(element, style))\\n    return true;\\n  return belongsToDisplayNoneOrAriaHiddenOrNonSlotted(element);\\n}\\nfunction belongsToDisplayNoneOrAriaHiddenOrNonSlotted(element) {\\n  let hidden = cacheIsHidden == null ? void 0 : cacheIsHidden.get(element);\\n  if (hidden === void 0) {\\n    hidden = false;\\n    if (element.parentElement && element.parentElement.shadowRoot && !element.assignedSlot)\\n      hidden = true;\\n    if (!hidden) {\\n      const style = getElementComputedStyle(element);\\n      hidden = !style || style.display === \\\"none\\\" || getAriaBoolean(element.getAttribute(\\\"aria-hidden\\\")) === true;\\n    }\\n    if (!hidden) {\\n      const parent = parentElementOrShadowHost(element);\\n      if (parent)\\n        hidden = belongsToDisplayNoneOrAriaHiddenOrNonSlotted(parent);\\n    }\\n    cacheIsHidden == null ? void 0 : cacheIsHidden.set(element, hidden);\\n  }\\n  return hidden;\\n}\\nfunction getIdRefs(element, ref) {\\n  if (!ref)\\n    return [];\\n  const root = enclosingShadowRootOrDocument(element);\\n  if (!root)\\n    return [];\\n  try {\\n    const ids = ref.split(\\\" \\\").filter((id) => !!id);\\n    const result = [];\\n    for (const id of ids) {\\n      const firstElement = root.querySelector(\\\"#\\\" + CSS.escape(id));\\n      if (firstElement && !result.includes(firstElement))\\n        result.push(firstElement);\\n    }\\n    return result;\\n  } catch (e) {\\n    return [];\\n  }\\n}\\nfunction trimFlatString(s) {\\n  return s.trim();\\n}\\nfunction asFlatString(s) {\\n  return s.split(\\\"\\\\xA0\\\").map((chunk) => chunk.replace(/\\\\r\\\\n/g, \\\"\\\\n\\\").replace(/[\\\\u200b\\\\u00ad]/g, \\\"\\\").replace(/\\\\s\\\\s*/g, \\\" \\\")).join(\\\"\\\\xA0\\\").trim();\\n}\\nfunction queryInAriaOwned(element, selector) {\\n  const result = [...element.querySelectorAll(selector)];\\n  for (const owned of getIdRefs(element, element.getAttribute(\\\"aria-owns\\\"))) {\\n    if (owned.matches(selector))\\n      result.push(owned);\\n    result.push(...owned.querySelectorAll(selector));\\n  }\\n  return result;\\n}\\nfunction getCSSContent(element, pseudo) {\\n  const cache = pseudo === \\\"::before\\\" ? cachePseudoContentBefore : pseudo === \\\"::after\\\" ? cachePseudoContentAfter : cachePseudoContent;\\n  if (cache == null ? void 0 : cache.has(element))\\n    return cache == null ? void 0 : cache.get(element);\\n  const style = getElementComputedStyle(element, pseudo);\\n  let content;\\n  if (style) {\\n    const contentValue = style.content;\\n    if (contentValue && contentValue !== \\\"none\\\" && contentValue !== \\\"normal\\\") {\\n      if (style.display !== \\\"none\\\" && style.visibility !== \\\"hidden\\\") {\\n        content = parseCSSContentPropertyAsString(element, contentValue, !!pseudo);\\n      }\\n    }\\n  }\\n  if (pseudo && content !== void 0) {\\n    const display = (style == null ? void 0 : style.display) || \\\"inline\\\";\\n    if (display !== \\\"inline\\\")\\n      content = \\\" \\\" + content + \\\" \\\";\\n  }\\n  if (cache)\\n    cache.set(element, content);\\n  return content;\\n}\\nfunction parseCSSContentPropertyAsString(element, content, isPseudo) {\\n  if (!content || content === \\\"none\\\" || content === \\\"normal\\\") {\\n    return;\\n  }\\n  try {\\n    let tokens = tokenize(content).filter((token) => !(token instanceof WhitespaceToken));\\n    const delimIndex = tokens.findIndex((token) => token instanceof DelimToken && token.value === \\\"/\\\");\\n    if (delimIndex !== -1) {\\n      tokens = tokens.slice(delimIndex + 1);\\n    } else if (!isPseudo) {\\n      return;\\n    }\\n    const accumulated = [];\\n    let index = 0;\\n    while (index < tokens.length) {\\n      if (tokens[index] instanceof StringToken) {\\n        accumulated.push(tokens[index].value);\\n        index++;\\n      } else if (index + 2 < tokens.length && tokens[index] instanceof FunctionToken && tokens[index].value === \\\"attr\\\" && tokens[index + 1] instanceof IdentToken && tokens[index + 2] instanceof CloseParenToken) {\\n        const attrName = tokens[index + 1].value;\\n        accumulated.push(element.getAttribute(attrName) || \\\"\\\");\\n        index += 3;\\n      } else {\\n        return;\\n      }\\n    }\\n    return accumulated.join(\\\"\\\");\\n  } catch {\\n  }\\n}\\nfunction getAriaLabelledByElements(element) {\\n  const ref = element.getAttribute(\\\"aria-labelledby\\\");\\n  if (ref === null)\\n    return null;\\n  const refs = getIdRefs(element, ref);\\n  return refs.length ? refs : null;\\n}\\nfunction allowsNameFromContent(role, targetDescendant) {\\n  const alwaysAllowsNameFromContent = [\\\"button\\\", \\\"cell\\\", \\\"checkbox\\\", \\\"columnheader\\\", \\\"gridcell\\\", \\\"heading\\\", \\\"link\\\", \\\"menuitem\\\", \\\"menuitemcheckbox\\\", \\\"menuitemradio\\\", \\\"option\\\", \\\"radio\\\", \\\"row\\\", \\\"rowheader\\\", \\\"switch\\\", \\\"tab\\\", \\\"tooltip\\\", \\\"treeitem\\\"].includes(role);\\n  const descendantAllowsNameFromContent = targetDescendant && [\\\"\\\", \\\"caption\\\", \\\"code\\\", \\\"contentinfo\\\", \\\"definition\\\", \\\"deletion\\\", \\\"emphasis\\\", \\\"insertion\\\", \\\"list\\\", \\\"listitem\\\", \\\"mark\\\", \\\"none\\\", \\\"paragraph\\\", \\\"presentation\\\", \\\"region\\\", \\\"row\\\", \\\"rowgroup\\\", \\\"section\\\", \\\"strong\\\", \\\"subscript\\\", \\\"superscript\\\", \\\"table\\\", \\\"term\\\", \\\"time\\\"].includes(role);\\n  return alwaysAllowsNameFromContent || descendantAllowsNameFromContent;\\n}\\nfunction getElementAccessibleName(element, includeHidden) {\\n  const cache = includeHidden ? cacheAccessibleNameHidden : cacheAccessibleName;\\n  let accessibleName = cache == null ? void 0 : cache.get(element);\\n  if (accessibleName === void 0) {\\n    accessibleName = \\\"\\\";\\n    const elementProhibitsNaming = [\\\"caption\\\", \\\"code\\\", \\\"definition\\\", \\\"deletion\\\", \\\"emphasis\\\", \\\"generic\\\", \\\"insertion\\\", \\\"mark\\\", \\\"paragraph\\\", \\\"presentation\\\", \\\"strong\\\", \\\"subscript\\\", \\\"suggestion\\\", \\\"superscript\\\", \\\"term\\\", \\\"time\\\"].includes(getAriaRole(element) || \\\"\\\");\\n    if (!elementProhibitsNaming) {\\n      accessibleName = asFlatString(getTextAlternativeInternal(element, {\\n        includeHidden,\\n        visitedElements: /* @__PURE__ */ new Set(),\\n        embeddedInTargetElement: \\\"self\\\"\\n      }));\\n    }\\n    cache == null ? void 0 : cache.set(element, accessibleName);\\n  }\\n  return accessibleName;\\n}\\nfunction getElementAccessibleDescription(element, includeHidden) {\\n  const cache = includeHidden ? cacheAccessibleDescriptionHidden : cacheAccessibleDescription;\\n  let accessibleDescription = cache == null ? void 0 : cache.get(element);\\n  if (accessibleDescription === void 0) {\\n    accessibleDescription = \\\"\\\";\\n    if (element.hasAttribute(\\\"aria-describedby\\\")) {\\n      const describedBy = getIdRefs(element, element.getAttribute(\\\"aria-describedby\\\"));\\n      accessibleDescription = asFlatString(describedBy.map((ref) => getTextAlternativeInternal(ref, {\\n        includeHidden,\\n        visitedElements: /* @__PURE__ */ new Set(),\\n        embeddedInDescribedBy: { element: ref, hidden: isElementHiddenForAria(ref) }\\n      })).join(\\\" \\\"));\\n    } else if (element.hasAttribute(\\\"aria-description\\\")) {\\n      accessibleDescription = asFlatString(element.getAttribute(\\\"aria-description\\\") || \\\"\\\");\\n    } else {\\n      accessibleDescription = asFlatString(element.getAttribute(\\\"title\\\") || \\\"\\\");\\n    }\\n    cache == null ? void 0 : cache.set(element, accessibleDescription);\\n  }\\n  return accessibleDescription;\\n}\\nfunction getAriaInvalid(element) {\\n  const ariaInvalid = element.getAttribute(\\\"aria-invalid\\\");\\n  if (!ariaInvalid || ariaInvalid.trim() === \\\"\\\" || ariaInvalid.toLocaleLowerCase() === \\\"false\\\")\\n    return \\\"false\\\";\\n  if (ariaInvalid === \\\"true\\\" || ariaInvalid === \\\"grammar\\\" || ariaInvalid === \\\"spelling\\\")\\n    return ariaInvalid;\\n  return \\\"true\\\";\\n}\\nfunction getValidityInvalid(element) {\\n  if (\\\"validity\\\" in element) {\\n    const validity = element.validity;\\n    return (validity == null ? void 0 : validity.valid) === false;\\n  }\\n  return false;\\n}\\nfunction getElementAccessibleErrorMessage(element) {\\n  const cache = cacheAccessibleErrorMessage;\\n  let accessibleErrorMessage = cacheAccessibleErrorMessage == null ? void 0 : cacheAccessibleErrorMessage.get(element);\\n  if (accessibleErrorMessage === void 0) {\\n    accessibleErrorMessage = \\\"\\\";\\n    const isAriaInvalid = getAriaInvalid(element) !== \\\"false\\\";\\n    const isValidityInvalid = getValidityInvalid(element);\\n    if (isAriaInvalid || isValidityInvalid) {\\n      const errorMessageId = element.getAttribute(\\\"aria-errormessage\\\");\\n      const errorMessages = getIdRefs(element, errorMessageId);\\n      const parts = errorMessages.map((errorMessage) => asFlatString(\\n        getTextAlternativeInternal(errorMessage, {\\n          visitedElements: /* @__PURE__ */ new Set(),\\n          embeddedInDescribedBy: { element: errorMessage, hidden: isElementHiddenForAria(errorMessage) }\\n        })\\n      ));\\n      accessibleErrorMessage = parts.join(\\\" \\\").trim();\\n    }\\n    cache == null ? void 0 : cache.set(element, accessibleErrorMessage);\\n  }\\n  return accessibleErrorMessage;\\n}\\nfunction getTextAlternativeInternal(element, options) {\\n  var _a, _b, _c, _d;\\n  if (options.visitedElements.has(element))\\n    return \\\"\\\";\\n  const childOptions = {\\n    ...options,\\n    embeddedInTargetElement: options.embeddedInTargetElement === \\\"self\\\" ? \\\"descendant\\\" : options.embeddedInTargetElement\\n  };\\n  if (!options.includeHidden) {\\n    const isEmbeddedInHiddenReferenceTraversal = !!((_a = options.embeddedInLabelledBy) == null ? void 0 : _a.hidden) || !!((_b = options.embeddedInDescribedBy) == null ? void 0 : _b.hidden) || !!((_c = options.embeddedInNativeTextAlternative) == null ? void 0 : _c.hidden) || !!((_d = options.embeddedInLabel) == null ? void 0 : _d.hidden);\\n    if (isElementIgnoredForAria(element) || !isEmbeddedInHiddenReferenceTraversal && isElementHiddenForAria(element)) {\\n      options.visitedElements.add(element);\\n      return \\\"\\\";\\n    }\\n  }\\n  const labelledBy = getAriaLabelledByElements(element);\\n  if (!options.embeddedInLabelledBy) {\\n    const accessibleName = (labelledBy || []).map((ref) => getTextAlternativeInternal(ref, {\\n      ...options,\\n      embeddedInLabelledBy: { element: ref, hidden: isElementHiddenForAria(ref) },\\n      embeddedInDescribedBy: void 0,\\n      embeddedInTargetElement: void 0,\\n      embeddedInLabel: void 0,\\n      embeddedInNativeTextAlternative: void 0\\n    })).join(\\\" \\\");\\n    if (accessibleName)\\n      return accessibleName;\\n  }\\n  const role = getAriaRole(element) || \\\"\\\";\\n  const tagName = elementSafeTagName(element);\\n  if (!!options.embeddedInLabel || !!options.embeddedInLabelledBy || options.embeddedInTargetElement === \\\"descendant\\\") {\\n    const isOwnLabel = [...element.labels || []].includes(element);\\n    const isOwnLabelledBy = (labelledBy || []).includes(element);\\n    if (!isOwnLabel && !isOwnLabelledBy) {\\n      if (role === \\\"textbox\\\") {\\n        options.visitedElements.add(element);\\n        if (tagName === \\\"INPUT\\\" || tagName === \\\"TEXTAREA\\\")\\n          return element.value;\\n        return element.textContent || \\\"\\\";\\n      }\\n      if ([\\\"combobox\\\", \\\"listbox\\\"].includes(role)) {\\n        options.visitedElements.add(element);\\n        let selectedOptions;\\n        if (tagName === \\\"SELECT\\\") {\\n          selectedOptions = [...element.selectedOptions];\\n          if (!selectedOptions.length && element.options.length)\\n            selectedOptions.push(element.options[0]);\\n        } else {\\n          const listbox = role === \\\"combobox\\\" ? queryInAriaOwned(element, \\\"*\\\").find((e) => getAriaRole(e) === \\\"listbox\\\") : element;\\n          selectedOptions = listbox ? queryInAriaOwned(listbox, '[aria-selected=\\\"true\\\"]').filter((e) => getAriaRole(e) === \\\"option\\\") : [];\\n        }\\n        if (!selectedOptions.length && tagName === \\\"INPUT\\\") {\\n          return element.value;\\n        }\\n        return selectedOptions.map((option) => getTextAlternativeInternal(option, childOptions)).join(\\\" \\\");\\n      }\\n      if ([\\\"progressbar\\\", \\\"scrollbar\\\", \\\"slider\\\", \\\"spinbutton\\\", \\\"meter\\\"].includes(role)) {\\n        options.visitedElements.add(element);\\n        if (element.hasAttribute(\\\"aria-valuetext\\\"))\\n          return element.getAttribute(\\\"aria-valuetext\\\") || \\\"\\\";\\n        if (element.hasAttribute(\\\"aria-valuenow\\\"))\\n          return element.getAttribute(\\\"aria-valuenow\\\") || \\\"\\\";\\n        return element.getAttribute(\\\"value\\\") || \\\"\\\";\\n      }\\n      if ([\\\"menu\\\"].includes(role)) {\\n        options.visitedElements.add(element);\\n        return \\\"\\\";\\n      }\\n    }\\n  }\\n  const ariaLabel = element.getAttribute(\\\"aria-label\\\") || \\\"\\\";\\n  if (trimFlatString(ariaLabel)) {\\n    options.visitedElements.add(element);\\n    return ariaLabel;\\n  }\\n  if (![\\\"presentation\\\", \\\"none\\\"].includes(role)) {\\n    if (tagName === \\\"INPUT\\\" && [\\\"button\\\", \\\"submit\\\", \\\"reset\\\"].includes(element.type)) {\\n      options.visitedElements.add(element);\\n      const value = element.value || \\\"\\\";\\n      if (trimFlatString(value))\\n        return value;\\n      if (element.type === \\\"submit\\\")\\n        return \\\"Submit\\\";\\n      if (element.type === \\\"reset\\\")\\n        return \\\"Reset\\\";\\n      const title = element.getAttribute(\\\"title\\\") || \\\"\\\";\\n      return title;\\n    }\\n    if (tagName === \\\"INPUT\\\" && element.type === \\\"file\\\") {\\n      options.visitedElements.add(element);\\n      const labels = element.labels || [];\\n      if (labels.length && !options.embeddedInLabelledBy)\\n        return getAccessibleNameFromAssociatedLabels(labels, options);\\n      return \\\"Choose File\\\";\\n    }\\n    if (tagName === \\\"INPUT\\\" && element.type === \\\"image\\\") {\\n      options.visitedElements.add(element);\\n      const labels = element.labels || [];\\n      if (labels.length && !options.embeddedInLabelledBy)\\n        return getAccessibleNameFromAssociatedLabels(labels, options);\\n      const alt = element.getAttribute(\\\"alt\\\") || \\\"\\\";\\n      if (trimFlatString(alt))\\n        return alt;\\n      const title = element.getAttribute(\\\"title\\\") || \\\"\\\";\\n      if (trimFlatString(title))\\n        return title;\\n      return \\\"Submit\\\";\\n    }\\n    if (!labelledBy && tagName === \\\"BUTTON\\\") {\\n      options.visitedElements.add(element);\\n      const labels = element.labels || [];\\n      if (labels.length)\\n        return getAccessibleNameFromAssociatedLabels(labels, options);\\n    }\\n    if (!labelledBy && tagName === \\\"OUTPUT\\\") {\\n      options.visitedElements.add(element);\\n      const labels = element.labels || [];\\n      if (labels.length)\\n        return getAccessibleNameFromAssociatedLabels(labels, options);\\n      return element.getAttribute(\\\"title\\\") || \\\"\\\";\\n    }\\n    if (!labelledBy && (tagName === \\\"TEXTAREA\\\" || tagName === \\\"SELECT\\\" || tagName === \\\"INPUT\\\")) {\\n      options.visitedElements.add(element);\\n      const labels = element.labels || [];\\n      if (labels.length)\\n        return getAccessibleNameFromAssociatedLabels(labels, options);\\n      const usePlaceholder = tagName === \\\"INPUT\\\" && [\\\"text\\\", \\\"password\\\", \\\"search\\\", \\\"tel\\\", \\\"email\\\", \\\"url\\\"].includes(element.type) || tagName === \\\"TEXTAREA\\\";\\n      const placeholder = element.getAttribute(\\\"placeholder\\\") || \\\"\\\";\\n      const title = element.getAttribute(\\\"title\\\") || \\\"\\\";\\n      if (!usePlaceholder || title)\\n        return title;\\n      return placeholder;\\n    }\\n    if (!labelledBy && tagName === \\\"FIELDSET\\\") {\\n      options.visitedElements.add(element);\\n      for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\\n        if (elementSafeTagName(child) === \\\"LEGEND\\\") {\\n          return getTextAlternativeInternal(child, {\\n            ...childOptions,\\n            embeddedInNativeTextAlternative: { element: child, hidden: isElementHiddenForAria(child) }\\n          });\\n        }\\n      }\\n      const title = element.getAttribute(\\\"title\\\") || \\\"\\\";\\n      return title;\\n    }\\n    if (!labelledBy && tagName === \\\"FIGURE\\\") {\\n      options.visitedElements.add(element);\\n      for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\\n        if (elementSafeTagName(child) === \\\"FIGCAPTION\\\") {\\n          return getTextAlternativeInternal(child, {\\n            ...childOptions,\\n            embeddedInNativeTextAlternative: { element: child, hidden: isElementHiddenForAria(child) }\\n          });\\n        }\\n      }\\n      const title = element.getAttribute(\\\"title\\\") || \\\"\\\";\\n      return title;\\n    }\\n    if (tagName === \\\"IMG\\\") {\\n      options.visitedElements.add(element);\\n      const alt = element.getAttribute(\\\"alt\\\") || \\\"\\\";\\n      if (trimFlatString(alt))\\n        return alt;\\n      const title = element.getAttribute(\\\"title\\\") || \\\"\\\";\\n      return title;\\n    }\\n    if (tagName === \\\"TABLE\\\") {\\n      options.visitedElements.add(element);\\n      for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\\n        if (elementSafeTagName(child) === \\\"CAPTION\\\") {\\n          return getTextAlternativeInternal(child, {\\n            ...childOptions,\\n            embeddedInNativeTextAlternative: { element: child, hidden: isElementHiddenForAria(child) }\\n          });\\n        }\\n      }\\n      const summary = element.getAttribute(\\\"summary\\\") || \\\"\\\";\\n      if (summary)\\n        return summary;\\n    }\\n    if (tagName === \\\"AREA\\\") {\\n      options.visitedElements.add(element);\\n      const alt = element.getAttribute(\\\"alt\\\") || \\\"\\\";\\n      if (trimFlatString(alt))\\n        return alt;\\n      const title = element.getAttribute(\\\"title\\\") || \\\"\\\";\\n      return title;\\n    }\\n    if (tagName === \\\"SVG\\\" || element.ownerSVGElement) {\\n      options.visitedElements.add(element);\\n      for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\\n        if (elementSafeTagName(child) === \\\"TITLE\\\" && child.ownerSVGElement) {\\n          return getTextAlternativeInternal(child, {\\n            ...childOptions,\\n            embeddedInLabelledBy: { element: child, hidden: isElementHiddenForAria(child) }\\n          });\\n        }\\n      }\\n    }\\n    if (element.ownerSVGElement && tagName === \\\"A\\\") {\\n      const title = element.getAttribute(\\\"xlink:title\\\") || \\\"\\\";\\n      if (trimFlatString(title)) {\\n        options.visitedElements.add(element);\\n        return title;\\n      }\\n    }\\n  }\\n  const shouldNameFromContentForSummary = tagName === \\\"SUMMARY\\\" && ![\\\"presentation\\\", \\\"none\\\"].includes(role);\\n  if (allowsNameFromContent(role, options.embeddedInTargetElement === \\\"descendant\\\") || shouldNameFromContentForSummary || !!options.embeddedInLabelledBy || !!options.embeddedInDescribedBy || !!options.embeddedInLabel || !!options.embeddedInNativeTextAlternative) {\\n    options.visitedElements.add(element);\\n    const accessibleName = innerAccumulatedElementText(element, childOptions);\\n    const maybeTrimmedAccessibleName = options.embeddedInTargetElement === \\\"self\\\" ? trimFlatString(accessibleName) : accessibleName;\\n    if (maybeTrimmedAccessibleName)\\n      return accessibleName;\\n  }\\n  if (![\\\"presentation\\\", \\\"none\\\"].includes(role) || tagName === \\\"IFRAME\\\") {\\n    options.visitedElements.add(element);\\n    const title = element.getAttribute(\\\"title\\\") || \\\"\\\";\\n    if (trimFlatString(title))\\n      return title;\\n  }\\n  options.visitedElements.add(element);\\n  return \\\"\\\";\\n}\\nfunction innerAccumulatedElementText(element, options) {\\n  const tokens = [];\\n  const visit = (node, skipSlotted) => {\\n    var _a;\\n    if (skipSlotted && node.assignedSlot)\\n      return;\\n    if (node.nodeType === 1) {\\n      const display = ((_a = getElementComputedStyle(node)) == null ? void 0 : _a.display) || \\\"inline\\\";\\n      let token = getTextAlternativeInternal(node, options);\\n      if (display !== \\\"inline\\\" || node.nodeName === \\\"BR\\\")\\n        token = \\\" \\\" + token + \\\" \\\";\\n      tokens.push(token);\\n    } else if (node.nodeType === 3) {\\n      tokens.push(node.textContent || \\\"\\\");\\n    }\\n  };\\n  tokens.push(getCSSContent(element, \\\"::before\\\") || \\\"\\\");\\n  const content = getCSSContent(element);\\n  if (content !== void 0) {\\n    tokens.push(content);\\n  } else {\\n    const assignedNodes = element.nodeName === \\\"SLOT\\\" ? element.assignedNodes() : [];\\n    if (assignedNodes.length) {\\n      for (const child of assignedNodes)\\n        visit(child, false);\\n    } else {\\n      for (let child = element.firstChild; child; child = child.nextSibling)\\n        visit(child, true);\\n      if (element.shadowRoot) {\\n        for (let child = element.shadowRoot.firstChild; child; child = child.nextSibling)\\n          visit(child, true);\\n      }\\n      for (const owned of getIdRefs(element, element.getAttribute(\\\"aria-owns\\\")))\\n        visit(owned, true);\\n    }\\n  }\\n  tokens.push(getCSSContent(element, \\\"::after\\\") || \\\"\\\");\\n  return tokens.join(\\\"\\\");\\n}\\nvar kAriaSelectedRoles = [\\\"gridcell\\\", \\\"option\\\", \\\"row\\\", \\\"tab\\\", \\\"rowheader\\\", \\\"columnheader\\\", \\\"treeitem\\\"];\\nfunction getAriaSelected(element) {\\n  if (elementSafeTagName(element) === \\\"OPTION\\\")\\n    return element.selected;\\n  if (kAriaSelectedRoles.includes(getAriaRole(element) || \\\"\\\"))\\n    return getAriaBoolean(element.getAttribute(\\\"aria-selected\\\")) === true;\\n  return false;\\n}\\nvar kAriaCheckedRoles = [\\\"checkbox\\\", \\\"menuitemcheckbox\\\", \\\"option\\\", \\\"radio\\\", \\\"switch\\\", \\\"menuitemradio\\\", \\\"treeitem\\\"];\\nfunction getAriaChecked(element) {\\n  const result = getChecked(element, true);\\n  return result === \\\"error\\\" ? false : result;\\n}\\nfunction getCheckedAllowMixed(element) {\\n  return getChecked(element, true);\\n}\\nfunction getCheckedWithoutMixed(element) {\\n  const result = getChecked(element, false);\\n  return result;\\n}\\nfunction getChecked(element, allowMixed) {\\n  const tagName = elementSafeTagName(element);\\n  if (allowMixed && tagName === \\\"INPUT\\\" && element.indeterminate)\\n    return \\\"mixed\\\";\\n  if (tagName === \\\"INPUT\\\" && [\\\"checkbox\\\", \\\"radio\\\"].includes(element.type))\\n    return element.checked;\\n  if (kAriaCheckedRoles.includes(getAriaRole(element) || \\\"\\\")) {\\n    const checked = element.getAttribute(\\\"aria-checked\\\");\\n    if (checked === \\\"true\\\")\\n      return true;\\n    if (allowMixed && checked === \\\"mixed\\\")\\n      return \\\"mixed\\\";\\n    return false;\\n  }\\n  return \\\"error\\\";\\n}\\nvar kAriaReadonlyRoles = [\\\"checkbox\\\", \\\"combobox\\\", \\\"grid\\\", \\\"gridcell\\\", \\\"listbox\\\", \\\"radiogroup\\\", \\\"slider\\\", \\\"spinbutton\\\", \\\"textbox\\\", \\\"columnheader\\\", \\\"rowheader\\\", \\\"searchbox\\\", \\\"switch\\\", \\\"treegrid\\\"];\\nfunction getReadonly(element) {\\n  const tagName = elementSafeTagName(element);\\n  if ([\\\"INPUT\\\", \\\"TEXTAREA\\\", \\\"SELECT\\\"].includes(tagName))\\n    return element.hasAttribute(\\\"readonly\\\");\\n  if (kAriaReadonlyRoles.includes(getAriaRole(element) || \\\"\\\"))\\n    return element.getAttribute(\\\"aria-readonly\\\") === \\\"true\\\";\\n  if (element.isContentEditable)\\n    return false;\\n  return \\\"error\\\";\\n}\\nvar kAriaPressedRoles = [\\\"button\\\"];\\nfunction getAriaPressed(element) {\\n  if (kAriaPressedRoles.includes(getAriaRole(element) || \\\"\\\")) {\\n    const pressed = element.getAttribute(\\\"aria-pressed\\\");\\n    if (pressed === \\\"true\\\")\\n      return true;\\n    if (pressed === \\\"mixed\\\")\\n      return \\\"mixed\\\";\\n  }\\n  return false;\\n}\\nvar kAriaExpandedRoles = [\\\"application\\\", \\\"button\\\", \\\"checkbox\\\", \\\"combobox\\\", \\\"gridcell\\\", \\\"link\\\", \\\"listbox\\\", \\\"menuitem\\\", \\\"row\\\", \\\"rowheader\\\", \\\"tab\\\", \\\"treeitem\\\", \\\"columnheader\\\", \\\"menuitemcheckbox\\\", \\\"menuitemradio\\\", \\\"rowheader\\\", \\\"switch\\\"];\\nfunction getAriaExpanded(element) {\\n  if (elementSafeTagName(element) === \\\"DETAILS\\\")\\n    return element.open;\\n  if (kAriaExpandedRoles.includes(getAriaRole(element) || \\\"\\\")) {\\n    const expanded = element.getAttribute(\\\"aria-expanded\\\");\\n    if (expanded === null)\\n      return void 0;\\n    if (expanded === \\\"true\\\")\\n      return true;\\n    return false;\\n  }\\n  return void 0;\\n}\\nvar kAriaLevelRoles = [\\\"heading\\\", \\\"listitem\\\", \\\"row\\\", \\\"treeitem\\\"];\\nfunction getAriaLevel(element) {\\n  const native = { \\\"H1\\\": 1, \\\"H2\\\": 2, \\\"H3\\\": 3, \\\"H4\\\": 4, \\\"H5\\\": 5, \\\"H6\\\": 6 }[elementSafeTagName(element)];\\n  if (native)\\n    return native;\\n  if (kAriaLevelRoles.includes(getAriaRole(element) || \\\"\\\")) {\\n    const attr = element.getAttribute(\\\"aria-level\\\");\\n    const value = attr === null ? Number.NaN : Number(attr);\\n    if (Number.isInteger(value) && value >= 1)\\n      return value;\\n  }\\n  return 0;\\n}\\nvar kAriaDisabledRoles = [\\\"application\\\", \\\"button\\\", \\\"composite\\\", \\\"gridcell\\\", \\\"group\\\", \\\"input\\\", \\\"link\\\", \\\"menuitem\\\", \\\"scrollbar\\\", \\\"separator\\\", \\\"tab\\\", \\\"checkbox\\\", \\\"columnheader\\\", \\\"combobox\\\", \\\"grid\\\", \\\"listbox\\\", \\\"menu\\\", \\\"menubar\\\", \\\"menuitemcheckbox\\\", \\\"menuitemradio\\\", \\\"option\\\", \\\"radio\\\", \\\"radiogroup\\\", \\\"row\\\", \\\"rowheader\\\", \\\"searchbox\\\", \\\"select\\\", \\\"slider\\\", \\\"spinbutton\\\", \\\"switch\\\", \\\"tablist\\\", \\\"textbox\\\", \\\"toolbar\\\", \\\"tree\\\", \\\"treegrid\\\", \\\"treeitem\\\"];\\nfunction getAriaDisabled(element) {\\n  return isNativelyDisabled(element) || hasExplicitAriaDisabled(element);\\n}\\nfunction isNativelyDisabled(element) {\\n  const isNativeFormControl = [\\\"BUTTON\\\", \\\"INPUT\\\", \\\"SELECT\\\", \\\"TEXTAREA\\\", \\\"OPTION\\\", \\\"OPTGROUP\\\"].includes(elementSafeTagName(element));\\n  return isNativeFormControl && (element.hasAttribute(\\\"disabled\\\") || belongsToDisabledOptGroup(element) || belongsToDisabledFieldSet(element));\\n}\\nfunction belongsToDisabledOptGroup(element) {\\n  return elementSafeTagName(element) === \\\"OPTION\\\" && !!element.closest(\\\"OPTGROUP[DISABLED]\\\");\\n}\\nfunction belongsToDisabledFieldSet(element) {\\n  const fieldSetElement = element == null ? void 0 : element.closest(\\\"FIELDSET[DISABLED]\\\");\\n  if (!fieldSetElement)\\n    return false;\\n  const legendElement = fieldSetElement.querySelector(\\\":scope > LEGEND\\\");\\n  return !legendElement || !legendElement.contains(element);\\n}\\nfunction hasExplicitAriaDisabled(element, isAncestor = false) {\\n  if (!element)\\n    return false;\\n  if (isAncestor || kAriaDisabledRoles.includes(getAriaRole(element) || \\\"\\\")) {\\n    const attribute = (element.getAttribute(\\\"aria-disabled\\\") || \\\"\\\").toLowerCase();\\n    if (attribute === \\\"true\\\")\\n      return true;\\n    if (attribute === \\\"false\\\")\\n      return false;\\n    return hasExplicitAriaDisabled(parentElementOrShadowHost(element), true);\\n  }\\n  return false;\\n}\\nfunction getAccessibleNameFromAssociatedLabels(labels, options) {\\n  return [...labels].map((label) => getTextAlternativeInternal(label, {\\n    ...options,\\n    embeddedInLabel: { element: label, hidden: isElementHiddenForAria(label) },\\n    embeddedInNativeTextAlternative: void 0,\\n    embeddedInLabelledBy: void 0,\\n    embeddedInDescribedBy: void 0,\\n    embeddedInTargetElement: void 0\\n  })).filter((accessibleName) => !!accessibleName).join(\\\" \\\");\\n}\\nfunction receivesPointerEvents(element) {\\n  const cache = cachePointerEvents;\\n  let e = element;\\n  let result;\\n  const parents = [];\\n  for (; e; e = parentElementOrShadowHost(e)) {\\n    const cached = cache.get(e);\\n    if (cached !== void 0) {\\n      result = cached;\\n      break;\\n    }\\n    parents.push(e);\\n    const style = getElementComputedStyle(e);\\n    if (!style) {\\n      result = true;\\n      break;\\n    }\\n    const value = style.pointerEvents;\\n    if (value) {\\n      result = value !== \\\"none\\\";\\n      break;\\n    }\\n  }\\n  if (result === void 0)\\n    result = true;\\n  for (const parent of parents)\\n    cache.set(parent, result);\\n  return result;\\n}\\nvar cacheAccessibleName;\\nvar cacheAccessibleNameHidden;\\nvar cacheAccessibleDescription;\\nvar cacheAccessibleDescriptionHidden;\\nvar cacheAccessibleErrorMessage;\\nvar cacheIsHidden;\\nvar cachePseudoContent;\\nvar cachePseudoContentBefore;\\nvar cachePseudoContentAfter;\\nvar cachePointerEvents;\\nvar cachesCounter2 = 0;\\nfunction beginAriaCaches() {\\n  beginDOMCaches();\\n  ++cachesCounter2;\\n  cacheAccessibleName != null ? cacheAccessibleName : cacheAccessibleName = /* @__PURE__ */ new Map();\\n  cacheAccessibleNameHidden != null ? cacheAccessibleNameHidden : cacheAccessibleNameHidden = /* @__PURE__ */ new Map();\\n  cacheAccessibleDescription != null ? cacheAccessibleDescription : cacheAccessibleDescription = /* @__PURE__ */ new Map();\\n  cacheAccessibleDescriptionHidden != null ? cacheAccessibleDescriptionHidden : cacheAccessibleDescriptionHidden = /* @__PURE__ */ new Map();\\n  cacheAccessibleErrorMessage != null ? cacheAccessibleErrorMessage : cacheAccessibleErrorMessage = /* @__PURE__ */ new Map();\\n  cacheIsHidden != null ? cacheIsHidden : cacheIsHidden = /* @__PURE__ */ new Map();\\n  cachePseudoContent != null ? cachePseudoContent : cachePseudoContent = /* @__PURE__ */ new Map();\\n  cachePseudoContentBefore != null ? cachePseudoContentBefore : cachePseudoContentBefore = /* @__PURE__ */ new Map();\\n  cachePseudoContentAfter != null ? cachePseudoContentAfter : cachePseudoContentAfter = /* @__PURE__ */ new Map();\\n  cachePointerEvents != null ? cachePointerEvents : cachePointerEvents = /* @__PURE__ */ new Map();\\n}\\nfunction endAriaCaches() {\\n  if (!--cachesCounter2) {\\n    cacheAccessibleName = void 0;\\n    cacheAccessibleNameHidden = void 0;\\n    cacheAccessibleDescription = void 0;\\n    cacheAccessibleDescriptionHidden = void 0;\\n    cacheAccessibleErrorMessage = void 0;\\n    cacheIsHidden = void 0;\\n    cachePseudoContent = void 0;\\n    cachePseudoContentBefore = void 0;\\n    cachePseudoContentAfter = void 0;\\n    cachePointerEvents = void 0;\\n  }\\n  endDOMCaches();\\n}\\nvar inputTypeToRole = {\\n  \\\"button\\\": \\\"button\\\",\\n  \\\"checkbox\\\": \\\"checkbox\\\",\\n  \\\"image\\\": \\\"button\\\",\\n  \\\"number\\\": \\\"spinbutton\\\",\\n  \\\"radio\\\": \\\"radio\\\",\\n  \\\"range\\\": \\\"slider\\\",\\n  \\\"reset\\\": \\\"button\\\",\\n  \\\"submit\\\": \\\"button\\\"\\n};\\n\\n// packages/playwright-injected/src/yaml.ts\\nfunction yamlEscapeKeyIfNeeded(str) {\\n  if (!yamlStringNeedsQuotes(str))\\n    return str;\\n  return `'` + str.replace(/'/g, `''`) + `'`;\\n}\\nfunction yamlEscapeValueIfNeeded(str) {\\n  if (!yamlStringNeedsQuotes(str))\\n    return str;\\n  return '\\\"' + str.replace(/[\\\\\\\\\\\"\\\\x00-\\\\x1f\\\\x7f-\\\\x9f]/g, (c) => {\\n    switch (c) {\\n      case \\\"\\\\\\\\\\\":\\n        return \\\"\\\\\\\\\\\\\\\\\\\";\\n      case '\\\"':\\n        return '\\\\\\\\\\\"';\\n      case \\\"\\\\b\\\":\\n        return \\\"\\\\\\\\b\\\";\\n      case \\\"\\\\f\\\":\\n        return \\\"\\\\\\\\f\\\";\\n      case \\\"\\\\n\\\":\\n        return \\\"\\\\\\\\n\\\";\\n      case \\\"\\\\r\\\":\\n        return \\\"\\\\\\\\r\\\";\\n      case \\\"\\t\\\":\\n        return \\\"\\\\\\\\t\\\";\\n      default:\\n        const code = c.charCodeAt(0);\\n        return \\\"\\\\\\\\x\\\" + code.toString(16).padStart(2, \\\"0\\\");\\n    }\\n  }) + '\\\"';\\n}\\nfunction yamlStringNeedsQuotes(str) {\\n  if (str.length === 0)\\n    return true;\\n  if (/^\\\\s|\\\\s$/.test(str))\\n    return true;\\n  if (/[\\\\x00-\\\\x08\\\\x0b\\\\x0c\\\\x0e-\\\\x1f\\\\x7f-\\\\x9f]/.test(str))\\n    return true;\\n  if (/^-/.test(str))\\n    return true;\\n  if (/[\\\\n:](\\\\s|$)/.test(str))\\n    return true;\\n  if (/\\\\s#/.test(str))\\n    return true;\\n  if (/[\\\\n\\\\r]/.test(str))\\n    return true;\\n  if (/^[&*\\\\],?!>|@\\\"'#%]/.test(str))\\n    return true;\\n  if (/[{}`]/.test(str))\\n    return true;\\n  if (/^\\\\[/.test(str))\\n    return true;\\n  if (!isNaN(Number(str)) || [\\\"y\\\", \\\"n\\\", \\\"yes\\\", \\\"no\\\", \\\"true\\\", \\\"false\\\", \\\"on\\\", \\\"off\\\", \\\"null\\\"].includes(str.toLowerCase()))\\n    return true;\\n  return false;\\n}\\n\\n// packages/playwright-injected/src/ariaSnapshot.ts\\nfunction ariaNodesEqual(a, b) {\\n  if (a.role !== b.role || a.name !== b.name)\\n    return false;\\n  if (!ariaPropsEqual(a, b) || hasPointerCursor(a) !== hasPointerCursor(b))\\n    return false;\\n  const aKeys = Object.keys(a.props);\\n  const bKeys = Object.keys(b.props);\\n  return aKeys.length === bKeys.length && aKeys.every((k) => a.props[k] === b.props[k]);\\n}\\nvar lastRef = 0;\\nfunction toInternalOptions(options) {\\n  if (options.mode === \\\"ai\\\") {\\n    return {\\n      visibility: \\\"ariaOrVisible\\\",\\n      refs: \\\"interactable\\\",\\n      refPrefix: options.refPrefix,\\n      includeGenericRole: true,\\n      renderActive: true,\\n      renderCursorPointer: true\\n    };\\n  }\\n  if (options.mode === \\\"autoexpect\\\") {\\n    return { visibility: \\\"ariaAndVisible\\\", refs: \\\"none\\\" };\\n  }\\n  if (options.mode === \\\"codegen\\\") {\\n    return { visibility: \\\"aria\\\", refs: \\\"none\\\", renderStringsAsRegex: true };\\n  }\\n  return { visibility: \\\"aria\\\", refs: \\\"none\\\" };\\n}\\nfunction generateAriaTree(rootElement, publicOptions) {\\n  const options = toInternalOptions(publicOptions);\\n  const visited = /* @__PURE__ */ new Set();\\n  const snapshot = {\\n    root: { role: \\\"fragment\\\", name: \\\"\\\", children: [], element: rootElement, props: {}, box: computeBox(rootElement), receivesPointerEvents: true },\\n    elements: /* @__PURE__ */ new Map(),\\n    refs: /* @__PURE__ */ new Map(),\\n    iframeRefs: []\\n  };\\n  const visit = (ariaNode, node, parentElementVisible) => {\\n    if (visited.has(node))\\n      return;\\n    visited.add(node);\\n    if (node.nodeType === Node.TEXT_NODE && node.nodeValue) {\\n      if (!parentElementVisible)\\n        return;\\n      const text = node.nodeValue;\\n      if (ariaNode.role !== \\\"textbox\\\" && text)\\n        ariaNode.children.push(node.nodeValue || \\\"\\\");\\n      return;\\n    }\\n    if (node.nodeType !== Node.ELEMENT_NODE)\\n      return;\\n    const element = node;\\n    const isElementVisibleForAria = !isElementHiddenForAria(element);\\n    let visible = isElementVisibleForAria;\\n    if (options.visibility === \\\"ariaOrVisible\\\")\\n      visible = isElementVisibleForAria || isElementVisible(element);\\n    if (options.visibility === \\\"ariaAndVisible\\\")\\n      visible = isElementVisibleForAria && isElementVisible(element);\\n    if (options.visibility === \\\"aria\\\" && !visible)\\n      return;\\n    const ariaChildren = [];\\n    if (element.hasAttribute(\\\"aria-owns\\\")) {\\n      const ids = element.getAttribute(\\\"aria-owns\\\").split(/\\\\s+/);\\n      for (const id of ids) {\\n        const ownedElement = rootElement.ownerDocument.getElementById(id);\\n        if (ownedElement)\\n          ariaChildren.push(ownedElement);\\n      }\\n    }\\n    const childAriaNode = visible ? toAriaNode(element, options) : null;\\n    if (childAriaNode) {\\n      if (childAriaNode.ref) {\\n        snapshot.elements.set(childAriaNode.ref, element);\\n        snapshot.refs.set(element, childAriaNode.ref);\\n        if (childAriaNode.role === \\\"iframe\\\")\\n          snapshot.iframeRefs.push(childAriaNode.ref);\\n      }\\n      ariaNode.children.push(childAriaNode);\\n    }\\n    processElement(childAriaNode || ariaNode, element, ariaChildren, visible);\\n  };\\n  function processElement(ariaNode, element, ariaChildren, parentElementVisible) {\\n    var _a;\\n    const display = ((_a = getElementComputedStyle(element)) == null ? void 0 : _a.display) || \\\"inline\\\";\\n    const treatAsBlock = display !== \\\"inline\\\" || element.nodeName === \\\"BR\\\" ? \\\" \\\" : \\\"\\\";\\n    if (treatAsBlock)\\n      ariaNode.children.push(treatAsBlock);\\n    ariaNode.children.push(getCSSContent(element, \\\"::before\\\") || \\\"\\\");\\n    const assignedNodes = element.nodeName === \\\"SLOT\\\" ? element.assignedNodes() : [];\\n    if (assignedNodes.length) {\\n      for (const child of assignedNodes)\\n        visit(ariaNode, child, parentElementVisible);\\n    } else {\\n      for (let child = element.firstChild; child; child = child.nextSibling) {\\n        if (!child.assignedSlot)\\n          visit(ariaNode, child, parentElementVisible);\\n      }\\n      if (element.shadowRoot) {\\n        for (let child = element.shadowRoot.firstChild; child; child = child.nextSibling)\\n          visit(ariaNode, child, parentElementVisible);\\n      }\\n    }\\n    for (const child of ariaChildren)\\n      visit(ariaNode, child, parentElementVisible);\\n    ariaNode.children.push(getCSSContent(element, \\\"::after\\\") || \\\"\\\");\\n    if (treatAsBlock)\\n      ariaNode.children.push(treatAsBlock);\\n    if (ariaNode.children.length === 1 && ariaNode.name === ariaNode.children[0])\\n      ariaNode.children = [];\\n    if (ariaNode.role === \\\"link\\\" && element.hasAttribute(\\\"href\\\")) {\\n      const href = element.getAttribute(\\\"href\\\");\\n      ariaNode.props[\\\"url\\\"] = href;\\n    }\\n    if (ariaNode.role === \\\"textbox\\\" && element.hasAttribute(\\\"placeholder\\\") && element.getAttribute(\\\"placeholder\\\") !== ariaNode.name) {\\n      const placeholder = element.getAttribute(\\\"placeholder\\\");\\n      ariaNode.props[\\\"placeholder\\\"] = placeholder;\\n    }\\n  }\\n  beginAriaCaches();\\n  try {\\n    visit(snapshot.root, rootElement, true);\\n  } finally {\\n    endAriaCaches();\\n  }\\n  normalizeStringChildren(snapshot.root);\\n  normalizeGenericRoles(snapshot.root);\\n  return snapshot;\\n}\\nfunction computeAriaRef(ariaNode, options) {\\n  var _a;\\n  if (options.refs === \\\"none\\\")\\n    return;\\n  if (options.refs === \\\"interactable\\\" && (!ariaNode.box.visible || !ariaNode.receivesPointerEvents))\\n    return;\\n  let ariaRef;\\n  ariaRef = ariaNode.element._ariaRef;\\n  if (!ariaRef || ariaRef.role !== ariaNode.role || ariaRef.name !== ariaNode.name) {\\n    ariaRef = { role: ariaNode.role, name: ariaNode.name, ref: ((_a = options.refPrefix) != null ? _a : \\\"\\\") + \\\"e\\\" + ++lastRef };\\n    ariaNode.element._ariaRef = ariaRef;\\n  }\\n  ariaNode.ref = ariaRef.ref;\\n}\\nfunction toAriaNode(element, options) {\\n  var _a;\\n  const active = element.ownerDocument.activeElement === element;\\n  if (element.nodeName === \\\"IFRAME\\\") {\\n    const ariaNode = {\\n      role: \\\"iframe\\\",\\n      name: \\\"\\\",\\n      children: [],\\n      props: {},\\n      element,\\n      box: computeBox(element),\\n      receivesPointerEvents: true,\\n      active\\n    };\\n    computeAriaRef(ariaNode, options);\\n    return ariaNode;\\n  }\\n  const defaultRole = options.includeGenericRole ? \\\"generic\\\" : null;\\n  const role = (_a = getAriaRole(element)) != null ? _a : defaultRole;\\n  if (!role || role === \\\"presentation\\\" || role === \\\"none\\\")\\n    return null;\\n  const name = normalizeWhiteSpace(getElementAccessibleName(element, false) || \\\"\\\");\\n  const receivesPointerEvents2 = receivesPointerEvents(element);\\n  const box = computeBox(element);\\n  if (role === \\\"generic\\\" && box.inline && element.childNodes.length === 1 && element.childNodes[0].nodeType === Node.TEXT_NODE)\\n    return null;\\n  const result = {\\n    role,\\n    name,\\n    children: [],\\n    props: {},\\n    element,\\n    box,\\n    receivesPointerEvents: receivesPointerEvents2,\\n    active\\n  };\\n  computeAriaRef(result, options);\\n  if (kAriaCheckedRoles.includes(role))\\n    result.checked = getAriaChecked(element);\\n  if (kAriaDisabledRoles.includes(role))\\n    result.disabled = getAriaDisabled(element);\\n  if (kAriaExpandedRoles.includes(role))\\n    result.expanded = getAriaExpanded(element);\\n  if (kAriaLevelRoles.includes(role))\\n    result.level = getAriaLevel(element);\\n  if (kAriaPressedRoles.includes(role))\\n    result.pressed = getAriaPressed(element);\\n  if (kAriaSelectedRoles.includes(role))\\n    result.selected = getAriaSelected(element);\\n  if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {\\n    if (element.type !== \\\"checkbox\\\" && element.type !== \\\"radio\\\" && element.type !== \\\"file\\\")\\n      result.children = [element.value];\\n  }\\n  return result;\\n}\\nfunction normalizeGenericRoles(node) {\\n  const normalizeChildren = (node2) => {\\n    const result = [];\\n    for (const child of node2.children || []) {\\n      if (typeof child === \\\"string\\\") {\\n        result.push(child);\\n        continue;\\n      }\\n      const normalized = normalizeChildren(child);\\n      result.push(...normalized);\\n    }\\n    const removeSelf = node2.role === \\\"generic\\\" && !node2.name && result.length <= 1 && result.every((c) => typeof c !== \\\"string\\\" && !!c.ref);\\n    if (removeSelf)\\n      return result;\\n    node2.children = result;\\n    return [node2];\\n  };\\n  normalizeChildren(node);\\n}\\nfunction normalizeStringChildren(rootA11yNode) {\\n  const flushChildren = (buffer, normalizedChildren) => {\\n    if (!buffer.length)\\n      return;\\n    const text = normalizeWhiteSpace(buffer.join(\\\"\\\"));\\n    if (text)\\n      normalizedChildren.push(text);\\n    buffer.length = 0;\\n  };\\n  const visit = (ariaNode) => {\\n    const normalizedChildren = [];\\n    const buffer = [];\\n    for (const child of ariaNode.children || []) {\\n      if (typeof child === \\\"string\\\") {\\n        buffer.push(child);\\n      } else {\\n        flushChildren(buffer, normalizedChildren);\\n        visit(child);\\n        normalizedChildren.push(child);\\n      }\\n    }\\n    flushChildren(buffer, normalizedChildren);\\n    ariaNode.children = normalizedChildren.length ? normalizedChildren : [];\\n    if (ariaNode.children.length === 1 && ariaNode.children[0] === ariaNode.name)\\n      ariaNode.children = [];\\n  };\\n  visit(rootA11yNode);\\n}\\nfunction matchesStringOrRegex(text, template) {\\n  if (!template)\\n    return true;\\n  if (!text)\\n    return false;\\n  if (typeof template === \\\"string\\\")\\n    return text === template;\\n  return !!text.match(new RegExp(template.pattern));\\n}\\nfunction matchesTextValue(text, template) {\\n  if (!(template == null ? void 0 : template.normalized))\\n    return true;\\n  if (!text)\\n    return false;\\n  if (text === template.normalized)\\n    return true;\\n  if (text === template.raw)\\n    return true;\\n  const regex = cachedRegex(template);\\n  if (regex)\\n    return !!text.match(regex);\\n  return false;\\n}\\nvar cachedRegexSymbol = /* @__PURE__ */ Symbol(\\\"cachedRegex\\\");\\nfunction cachedRegex(template) {\\n  if (template[cachedRegexSymbol] !== void 0)\\n    return template[cachedRegexSymbol];\\n  const { raw } = template;\\n  const canBeRegex = raw.startsWith(\\\"/\\\") && raw.endsWith(\\\"/\\\") && raw.length > 1;\\n  let regex;\\n  try {\\n    regex = canBeRegex ? new RegExp(raw.slice(1, -1)) : null;\\n  } catch (e) {\\n    regex = null;\\n  }\\n  template[cachedRegexSymbol] = regex;\\n  return regex;\\n}\\nfunction matchesExpectAriaTemplate(rootElement, template) {\\n  const snapshot = generateAriaTree(rootElement, { mode: \\\"expect\\\" });\\n  const matches = matchesNodeDeep(snapshot.root, template, false, false);\\n  return {\\n    matches,\\n    received: {\\n      raw: renderAriaTree(snapshot, { mode: \\\"expect\\\" }),\\n      regex: renderAriaTree(snapshot, { mode: \\\"codegen\\\" })\\n    }\\n  };\\n}\\nfunction getAllElementsMatchingExpectAriaTemplate(rootElement, template) {\\n  const root = generateAriaTree(rootElement, { mode: \\\"expect\\\" }).root;\\n  const matches = matchesNodeDeep(root, template, true, false);\\n  return matches.map((n) => n.element);\\n}\\nfunction matchesNode(node, template, isDeepEqual) {\\n  var _a;\\n  if (typeof node === \\\"string\\\" && template.kind === \\\"text\\\")\\n    return matchesTextValue(node, template.text);\\n  if (node === null || typeof node !== \\\"object\\\" || template.kind !== \\\"role\\\")\\n    return false;\\n  if (template.role !== \\\"fragment\\\" && template.role !== node.role)\\n    return false;\\n  if (template.checked !== void 0 && template.checked !== node.checked)\\n    return false;\\n  if (template.disabled !== void 0 && template.disabled !== node.disabled)\\n    return false;\\n  if (template.expanded !== void 0 && template.expanded !== node.expanded)\\n    return false;\\n  if (template.level !== void 0 && template.level !== node.level)\\n    return false;\\n  if (template.pressed !== void 0 && template.pressed !== node.pressed)\\n    return false;\\n  if (template.selected !== void 0 && template.selected !== node.selected)\\n    return false;\\n  if (!matchesStringOrRegex(node.name, template.name))\\n    return false;\\n  if (!matchesTextValue(node.props.url, (_a = template.props) == null ? void 0 : _a.url))\\n    return false;\\n  if (template.containerMode === \\\"contain\\\")\\n    return containsList(node.children || [], template.children || []);\\n  if (template.containerMode === \\\"equal\\\")\\n    return listEqual(node.children || [], template.children || [], false);\\n  if (template.containerMode === \\\"deep-equal\\\" || isDeepEqual)\\n    return listEqual(node.children || [], template.children || [], true);\\n  return containsList(node.children || [], template.children || []);\\n}\\nfunction listEqual(children, template, isDeepEqual) {\\n  if (template.length !== children.length)\\n    return false;\\n  for (let i = 0; i < template.length; ++i) {\\n    if (!matchesNode(children[i], template[i], isDeepEqual))\\n      return false;\\n  }\\n  return true;\\n}\\nfunction containsList(children, template) {\\n  if (template.length > children.length)\\n    return false;\\n  const cc = children.slice();\\n  const tt = template.slice();\\n  for (const t of tt) {\\n    let c = cc.shift();\\n    while (c) {\\n      if (matchesNode(c, t, false))\\n        break;\\n      c = cc.shift();\\n    }\\n    if (!c)\\n      return false;\\n  }\\n  return true;\\n}\\nfunction matchesNodeDeep(root, template, collectAll, isDeepEqual) {\\n  const results = [];\\n  const visit = (node, parent) => {\\n    if (matchesNode(node, template, isDeepEqual)) {\\n      const result = typeof node === \\\"string\\\" ? parent : node;\\n      if (result)\\n        results.push(result);\\n      return !collectAll;\\n    }\\n    if (typeof node === \\\"string\\\")\\n      return false;\\n    for (const child of node.children || []) {\\n      if (visit(child, node))\\n        return true;\\n    }\\n    return false;\\n  };\\n  visit(root, null);\\n  return results;\\n}\\nfunction buildByRefMap(root, map = /* @__PURE__ */ new Map()) {\\n  if (root == null ? void 0 : root.ref)\\n    map.set(root.ref, root);\\n  for (const child of (root == null ? void 0 : root.children) || []) {\\n    if (typeof child !== \\\"string\\\")\\n      buildByRefMap(child, map);\\n  }\\n  return map;\\n}\\nfunction compareSnapshots(ariaSnapshot, previousSnapshot) {\\n  var _a;\\n  const previousByRef = buildByRefMap(previousSnapshot == null ? void 0 : previousSnapshot.root);\\n  const result = /* @__PURE__ */ new Map();\\n  const visit = (ariaNode, previousNode) => {\\n    let same = ariaNode.children.length === (previousNode == null ? void 0 : previousNode.children.length) && ariaNodesEqual(ariaNode, previousNode);\\n    let canBeSkipped = same;\\n    for (let childIndex = 0; childIndex < ariaNode.children.length; childIndex++) {\\n      const child = ariaNode.children[childIndex];\\n      const previousChild = previousNode == null ? void 0 : previousNode.children[childIndex];\\n      if (typeof child === \\\"string\\\") {\\n        same && (same = child === previousChild);\\n        canBeSkipped && (canBeSkipped = child === previousChild);\\n      } else {\\n        let previous = typeof previousChild !== \\\"string\\\" ? previousChild : void 0;\\n        if (child.ref)\\n          previous = previousByRef.get(child.ref);\\n        const sameChild = visit(child, previous);\\n        if (!previous || !sameChild && !child.ref || previous !== previousChild)\\n          canBeSkipped = false;\\n        same && (same = sameChild && previous === previousChild);\\n      }\\n    }\\n    result.set(ariaNode, same ? \\\"same\\\" : canBeSkipped ? \\\"skip\\\" : \\\"changed\\\");\\n    return same;\\n  };\\n  visit(ariaSnapshot.root, previousByRef.get((_a = previousSnapshot == null ? void 0 : previousSnapshot.root) == null ? void 0 : _a.ref));\\n  return result;\\n}\\nfunction filterSnapshotDiff(nodes, statusMap) {\\n  const result = [];\\n  const visit = (ariaNode) => {\\n    const status = statusMap.get(ariaNode);\\n    if (status === \\\"same\\\") {\\n    } else if (status === \\\"skip\\\") {\\n      for (const child of ariaNode.children) {\\n        if (typeof child !== \\\"string\\\")\\n          visit(child);\\n      }\\n    } else {\\n      result.push(ariaNode);\\n    }\\n  };\\n  for (const node of nodes) {\\n    if (typeof node === \\\"string\\\")\\n      result.push(node);\\n    else\\n      visit(node);\\n  }\\n  return result;\\n}\\nfunction renderAriaTree(ariaSnapshot, publicOptions, previousSnapshot) {\\n  const options = toInternalOptions(publicOptions);\\n  const lines = [];\\n  const includeText = options.renderStringsAsRegex ? textContributesInfo : () => true;\\n  const renderString = options.renderStringsAsRegex ? convertToBestGuessRegex : (str) => str;\\n  let nodesToRender = ariaSnapshot.root.role === \\\"fragment\\\" ? ariaSnapshot.root.children : [ariaSnapshot.root];\\n  const statusMap = compareSnapshots(ariaSnapshot, previousSnapshot);\\n  if (previousSnapshot)\\n    nodesToRender = filterSnapshotDiff(nodesToRender, statusMap);\\n  const visitText = (text, indent) => {\\n    const escaped = yamlEscapeValueIfNeeded(renderString(text));\\n    if (escaped)\\n      lines.push(indent + \\\"- text: \\\" + escaped);\\n  };\\n  const createKey = (ariaNode, renderCursorPointer) => {\\n    let key = ariaNode.role;\\n    if (ariaNode.name && ariaNode.name.length <= 900) {\\n      const name = renderString(ariaNode.name);\\n      if (name) {\\n        const stringifiedName = name.startsWith(\\\"/\\\") && name.endsWith(\\\"/\\\") ? name : JSON.stringify(name);\\n        key += \\\" \\\" + stringifiedName;\\n      }\\n    }\\n    if (ariaNode.checked === \\\"mixed\\\")\\n      key += ` [checked=mixed]`;\\n    if (ariaNode.checked === true)\\n      key += ` [checked]`;\\n    if (ariaNode.disabled)\\n      key += ` [disabled]`;\\n    if (ariaNode.expanded)\\n      key += ` [expanded]`;\\n    if (ariaNode.active && options.renderActive)\\n      key += ` [active]`;\\n    if (ariaNode.level)\\n      key += ` [level=${ariaNode.level}]`;\\n    if (ariaNode.pressed === \\\"mixed\\\")\\n      key += ` [pressed=mixed]`;\\n    if (ariaNode.pressed === true)\\n      key += ` [pressed]`;\\n    if (ariaNode.selected === true)\\n      key += ` [selected]`;\\n    if (ariaNode.ref) {\\n      key += ` [ref=${ariaNode.ref}]`;\\n      if (renderCursorPointer && hasPointerCursor(ariaNode))\\n        key += \\\" [cursor=pointer]\\\";\\n    }\\n    return key;\\n  };\\n  const getSingleInlinedTextChild = (ariaNode) => {\\n    return (ariaNode == null ? void 0 : ariaNode.children.length) === 1 && typeof ariaNode.children[0] === \\\"string\\\" && !Object.keys(ariaNode.props).length ? ariaNode.children[0] : void 0;\\n  };\\n  const visit = (ariaNode, indent, renderCursorPointer) => {\\n    if (statusMap.get(ariaNode) === \\\"same\\\" && ariaNode.ref) {\\n      lines.push(indent + `- ref=${ariaNode.ref} [unchanged]`);\\n      return;\\n    }\\n    const isDiffRoot = !!previousSnapshot && !indent;\\n    const escapedKey = indent + \\\"- \\\" + (isDiffRoot ? \\\"<changed> \\\" : \\\"\\\") + yamlEscapeKeyIfNeeded(createKey(ariaNode, renderCursorPointer));\\n    const singleInlinedTextChild = getSingleInlinedTextChild(ariaNode);\\n    if (!ariaNode.children.length && !Object.keys(ariaNode.props).length) {\\n      lines.push(escapedKey);\\n    } else if (singleInlinedTextChild !== void 0) {\\n      const shouldInclude = includeText(ariaNode, singleInlinedTextChild);\\n      if (shouldInclude)\\n        lines.push(escapedKey + \\\": \\\" + yamlEscapeValueIfNeeded(renderString(singleInlinedTextChild)));\\n      else\\n        lines.push(escapedKey);\\n    } else {\\n      lines.push(escapedKey + \\\":\\\");\\n      for (const [name, value] of Object.entries(ariaNode.props))\\n        lines.push(indent + \\\"  - /\\\" + name + \\\": \\\" + yamlEscapeValueIfNeeded(value));\\n      const childIndent = indent + \\\"  \\\";\\n      const inCursorPointer = !!ariaNode.ref && renderCursorPointer && hasPointerCursor(ariaNode);\\n      for (const child of ariaNode.children) {\\n        if (typeof child === \\\"string\\\")\\n          visitText(includeText(ariaNode, child) ? child : \\\"\\\", childIndent);\\n        else\\n          visit(child, childIndent, renderCursorPointer && !inCursorPointer);\\n      }\\n    }\\n  };\\n  for (const nodeToRender of nodesToRender) {\\n    if (typeof nodeToRender === \\\"string\\\")\\n      visitText(nodeToRender, \\\"\\\");\\n    else\\n      visit(nodeToRender, \\\"\\\", !!options.renderCursorPointer);\\n  }\\n  return lines.join(\\\"\\\\n\\\");\\n}\\nfunction convertToBestGuessRegex(text) {\\n  const dynamicContent = [\\n    // 2mb\\n    { regex: /\\\\b[\\\\d,.]+[bkmBKM]+\\\\b/, replacement: \\\"[\\\\\\\\d,.]+[bkmBKM]+\\\" },\\n    // 2ms, 20s\\n    { regex: /\\\\b\\\\d+[hmsp]+\\\\b/, replacement: \\\"\\\\\\\\d+[hmsp]+\\\" },\\n    { regex: /\\\\b[\\\\d,.]+[hmsp]+\\\\b/, replacement: \\\"[\\\\\\\\d,.]+[hmsp]+\\\" },\\n    // Do not replace single digits with regex by default.\\n    // 2+ digits: [Issue 22, 22.3, 2.33, 2,333]\\n    { regex: /\\\\b\\\\d+,\\\\d+\\\\b/, replacement: \\\"\\\\\\\\d+,\\\\\\\\d+\\\" },\\n    { regex: /\\\\b\\\\d+\\\\.\\\\d{2,}\\\\b/, replacement: \\\"\\\\\\\\d+\\\\\\\\.\\\\\\\\d+\\\" },\\n    { regex: /\\\\b\\\\d{2,}\\\\.\\\\d+\\\\b/, replacement: \\\"\\\\\\\\d+\\\\\\\\.\\\\\\\\d+\\\" },\\n    { regex: /\\\\b\\\\d{2,}\\\\b/, replacement: \\\"\\\\\\\\d+\\\" }\\n  ];\\n  let pattern = \\\"\\\";\\n  let lastIndex = 0;\\n  const combinedRegex = new RegExp(dynamicContent.map((r) => \\\"(\\\" + r.regex.source + \\\")\\\").join(\\\"|\\\"), \\\"g\\\");\\n  text.replace(combinedRegex, (match, ...args) => {\\n    const offset = args[args.length - 2];\\n    const groups = args.slice(0, -2);\\n    pattern += escapeRegExp(text.slice(lastIndex, offset));\\n    for (let i = 0; i < groups.length; i++) {\\n      if (groups[i]) {\\n        const { replacement } = dynamicContent[i];\\n        pattern += replacement;\\n        break;\\n      }\\n    }\\n    lastIndex = offset + match.length;\\n    return match;\\n  });\\n  if (!pattern)\\n    return text;\\n  pattern += escapeRegExp(text.slice(lastIndex));\\n  return String(new RegExp(pattern));\\n}\\nfunction textContributesInfo(node, text) {\\n  if (!text.length)\\n    return false;\\n  if (!node.name)\\n    return true;\\n  if (node.name.length > text.length)\\n    return false;\\n  const substr = text.length <= 200 && node.name.length <= 200 ? longestCommonSubstring(text, node.name) : \\\"\\\";\\n  let filtered = text;\\n  while (substr && filtered.includes(substr))\\n    filtered = filtered.replace(substr, \\\"\\\");\\n  return filtered.trim().length / text.length > 0.1;\\n}\\nfunction hasPointerCursor(ariaNode) {\\n  return ariaNode.box.cursor === \\\"pointer\\\";\\n}\\n\\n// packages/playwright-injected/src/highlight.css?inline\\nvar highlight_default = \\\":host{font-size:13px;font-family:system-ui,Ubuntu,Droid Sans,sans-serif;color:#333}svg{position:absolute;height:0}x-pw-tooltip{backdrop-filter:blur(5px);background-color:#fff;border-radius:6px;box-shadow:0 .5rem 1.2rem #0000004d;display:none;font-size:12.8px;font-weight:400;left:0;line-height:1.5;max-width:600px;position:absolute;top:0;padding:0;flex-direction:column;overflow:hidden}x-pw-tooltip-line{display:flex;max-width:600px;padding:6px;user-select:none;cursor:pointer}x-pw-tooltip-footer{display:flex;max-width:600px;padding:6px;user-select:none;color:#777}x-pw-dialog{background-color:#fff;pointer-events:auto;border-radius:6px;box-shadow:0 .5rem 1.2rem #0000004d;display:flex;flex-direction:column;position:absolute;z-index:10;font-size:13px}x-pw-dialog:not(.autosize){width:400px;height:150px}x-pw-dialog-body{display:flex;flex-direction:column;flex:auto}x-pw-dialog-body label{margin:5px 8px;display:flex;flex-direction:row;align-items:center}x-pw-highlight{position:absolute;top:0;left:0;width:0;height:0}x-pw-action-point{position:absolute;width:20px;height:20px;background:red;border-radius:10px;margin:-10px 0 0 -10px;z-index:2}x-pw-separator{height:1px;margin:6px 9px;background:#949494e5}x-pw-tool-gripper{height:28px;width:24px;margin:2px 0;cursor:grab}x-pw-tool-gripper:active{cursor:grabbing}x-pw-tool-gripper>x-div{width:16px;height:16px;margin:6px 4px;clip-path:url(#icon-gripper);background-color:#555}x-pw-tools-list>label{display:flex;align-items:center;margin:0 10px;user-select:none}x-pw-tools-list{display:flex;width:100%;border-bottom:1px solid #dddddd}x-pw-tool-item{pointer-events:auto;height:28px;width:28px;border-radius:3px}x-pw-tool-item:not(.disabled){cursor:pointer}x-pw-tool-item:not(.disabled):hover{background-color:#dbdbdb}x-pw-tool-item.toggled{background-color:#8acae480}x-pw-tool-item.toggled:not(.disabled):hover{background-color:#8acae4c4}x-pw-tool-item>x-div{width:16px;height:16px;margin:6px;background-color:#3a3a3a}x-pw-tool-item.disabled>x-div{background-color:#61616180;cursor:default}x-pw-tool-item.record.toggled{background-color:transparent}x-pw-tool-item.record.toggled:not(.disabled):hover{background-color:#dbdbdb}x-pw-tool-item.record.toggled>x-div{background-color:#a1260d}x-pw-tool-item.record.disabled.toggled>x-div{opacity:.8}x-pw-tool-item.accept>x-div{background-color:#388a34}x-pw-tool-item.record>x-div{clip-path:url(#icon-circle-large-filled)}x-pw-tool-item.record.toggled>x-div{clip-path:url(#icon-stop-circle)}x-pw-tool-item.pick-locator>x-div{clip-path:url(#icon-inspect)}x-pw-tool-item.text>x-div{clip-path:url(#icon-whole-word)}x-pw-tool-item.visibility>x-div{clip-path:url(#icon-eye)}x-pw-tool-item.value>x-div{clip-path:url(#icon-symbol-constant)}x-pw-tool-item.snapshot>x-div{clip-path:url(#icon-gist)}x-pw-tool-item.accept>x-div{clip-path:url(#icon-check)}x-pw-tool-item.cancel>x-div{clip-path:url(#icon-close)}x-pw-tool-item.succeeded>x-div{clip-path:url(#icon-pass);background-color:#388a34!important}x-pw-overlay{position:absolute;top:0;max-width:min-content;z-index:2147483647;background:transparent;pointer-events:auto}x-pw-overlay x-pw-tools-list{background-color:#fffd;box-shadow:#0000001a 0 5px 5px;border-radius:3px;border-bottom:none}x-pw-overlay x-pw-tool-item{margin:2px}textarea.text-editor{font-family:system-ui,Ubuntu,Droid Sans,sans-serif;flex:auto;border:none;margin:6px 10px;color:#333;outline:1px solid transparent!important;resize:none;padding:0;font-size:13px}textarea.text-editor.does-not-match{outline:1px solid red!important}x-div{display:block}x-spacer{flex:auto}*{box-sizing:border-box}*[hidden]{display:none!important}x-locator-editor{flex:none;width:100%;height:60px;padding:4px;border-bottom:1px solid #dddddd;outline:1px solid transparent}x-locator-editor.does-not-match{outline:1px solid red}.CodeMirror{width:100%!important;height:100%!important}x-pw-action-list{flex:auto;display:flex;flex-direction:column;user-select:none}x-pw-action-item{padding:6px 10px;cursor:pointer;overflow:hidden}x-pw-action-item:hover{background-color:#f2f2f2}x-pw-action-item:last-child{border-bottom-left-radius:6px;border-bottom-right-radius:6px}\\\\n\\\";\\n\\n// packages/playwright-injected/src/highlight.ts\\nvar Highlight = class {\\n  constructor(injectedScript) {\\n    this._renderedEntries = [];\\n    this._language = \\\"javascript\\\";\\n    this._injectedScript = injectedScript;\\n    const document = injectedScript.document;\\n    this._isUnderTest = injectedScript.isUnderTest;\\n    this._glassPaneElement = document.createElement(\\\"x-pw-glass\\\");\\n    this._glassPaneElement.style.position = \\\"fixed\\\";\\n    this._glassPaneElement.style.top = \\\"0\\\";\\n    this._glassPaneElement.style.right = \\\"0\\\";\\n    this._glassPaneElement.style.bottom = \\\"0\\\";\\n    this._glassPaneElement.style.left = \\\"0\\\";\\n    this._glassPaneElement.style.zIndex = \\\"2147483647\\\";\\n    this._glassPaneElement.style.pointerEvents = \\\"none\\\";\\n    this._glassPaneElement.style.display = \\\"flex\\\";\\n    this._glassPaneElement.style.backgroundColor = \\\"transparent\\\";\\n    this._actionPointElement = document.createElement(\\\"x-pw-action-point\\\");\\n    this._actionPointElement.setAttribute(\\\"hidden\\\", \\\"true\\\");\\n    this._glassPaneShadow = this._glassPaneElement.attachShadow({ mode: this._isUnderTest ? \\\"open\\\" : \\\"closed\\\" });\\n    if (typeof this._glassPaneShadow.adoptedStyleSheets.push === \\\"function\\\") {\\n      const sheet = new this._injectedScript.window.CSSStyleSheet();\\n      sheet.replaceSync(highlight_default);\\n      this._glassPaneShadow.adoptedStyleSheets.push(sheet);\\n    } else {\\n      const styleElement = this._injectedScript.document.createElement(\\\"style\\\");\\n      styleElement.textContent = highlight_default;\\n      this._glassPaneShadow.appendChild(styleElement);\\n    }\\n    this._glassPaneShadow.appendChild(this._actionPointElement);\\n  }\\n  install() {\\n    if (!this._injectedScript.document.documentElement)\\n      return;\\n    if (!this._injectedScript.document.documentElement.contains(this._glassPaneElement) || this._glassPaneElement.nextElementSibling)\\n      this._injectedScript.document.documentElement.appendChild(this._glassPaneElement);\\n  }\\n  setLanguage(language) {\\n    this._language = language;\\n  }\\n  runHighlightOnRaf(selector) {\\n    if (this._rafRequest)\\n      this._injectedScript.utils.builtins.cancelAnimationFrame(this._rafRequest);\\n    const elements = this._injectedScript.querySelectorAll(selector, this._injectedScript.document.documentElement);\\n    const locator = asLocator(this._language, stringifySelector(selector));\\n    const color = elements.length > 1 ? \\\"#f6b26b7f\\\" : \\\"#6fa8dc7f\\\";\\n    this.updateHighlight(elements.map((element, index) => {\\n      const suffix = elements.length > 1 ? ` [${index + 1} of ${elements.length}]` : \\\"\\\";\\n      return { element, color, tooltipText: locator + suffix };\\n    }));\\n    this._rafRequest = this._injectedScript.utils.builtins.requestAnimationFrame(() => this.runHighlightOnRaf(selector));\\n  }\\n  uninstall() {\\n    if (this._rafRequest)\\n      this._injectedScript.utils.builtins.cancelAnimationFrame(this._rafRequest);\\n    this._glassPaneElement.remove();\\n  }\\n  showActionPoint(x, y) {\\n    this._actionPointElement.style.top = y + \\\"px\\\";\\n    this._actionPointElement.style.left = x + \\\"px\\\";\\n    this._actionPointElement.hidden = false;\\n  }\\n  hideActionPoint() {\\n    this._actionPointElement.hidden = true;\\n  }\\n  clearHighlight() {\\n    var _a, _b;\\n    for (const entry of this._renderedEntries) {\\n      (_a = entry.highlightElement) == null ? void 0 : _a.remove();\\n      (_b = entry.tooltipElement) == null ? void 0 : _b.remove();\\n    }\\n    this._renderedEntries = [];\\n  }\\n  maskElements(elements, color) {\\n    this.updateHighlight(elements.map((element) => ({ element, color })));\\n  }\\n  updateHighlight(entries) {\\n    if (this._highlightIsUpToDate(entries))\\n      return;\\n    this.clearHighlight();\\n    for (const entry of entries) {\\n      const highlightElement = this._createHighlightElement();\\n      this._glassPaneShadow.appendChild(highlightElement);\\n      let tooltipElement;\\n      if (entry.tooltipText) {\\n        tooltipElement = this._injectedScript.document.createElement(\\\"x-pw-tooltip\\\");\\n        this._glassPaneShadow.appendChild(tooltipElement);\\n        tooltipElement.style.top = \\\"0\\\";\\n        tooltipElement.style.left = \\\"0\\\";\\n        tooltipElement.style.display = \\\"flex\\\";\\n        const lineElement = this._injectedScript.document.createElement(\\\"x-pw-tooltip-line\\\");\\n        lineElement.textContent = entry.tooltipText;\\n        tooltipElement.appendChild(lineElement);\\n      }\\n      this._renderedEntries.push({ targetElement: entry.element, color: entry.color, tooltipElement, highlightElement });\\n    }\\n    for (const entry of this._renderedEntries) {\\n      entry.box = entry.targetElement.getBoundingClientRect();\\n      if (!entry.tooltipElement)\\n        continue;\\n      const { anchorLeft, anchorTop } = this.tooltipPosition(entry.box, entry.tooltipElement);\\n      entry.tooltipTop = anchorTop;\\n      entry.tooltipLeft = anchorLeft;\\n    }\\n    for (const entry of this._renderedEntries) {\\n      if (entry.tooltipElement) {\\n        entry.tooltipElement.style.top = entry.tooltipTop + \\\"px\\\";\\n        entry.tooltipElement.style.left = entry.tooltipLeft + \\\"px\\\";\\n      }\\n      const box = entry.box;\\n      entry.highlightElement.style.backgroundColor = entry.color;\\n      entry.highlightElement.style.left = box.x + \\\"px\\\";\\n      entry.highlightElement.style.top = box.y + \\\"px\\\";\\n      entry.highlightElement.style.width = box.width + \\\"px\\\";\\n      entry.highlightElement.style.height = box.height + \\\"px\\\";\\n      entry.highlightElement.style.display = \\\"block\\\";\\n      if (this._isUnderTest)\\n        console.error(\\\"Highlight box for test: \\\" + JSON.stringify({ x: box.x, y: box.y, width: box.width, height: box.height }));\\n    }\\n  }\\n  firstBox() {\\n    var _a;\\n    return (_a = this._renderedEntries[0]) == null ? void 0 : _a.box;\\n  }\\n  firstTooltipBox() {\\n    const entry = this._renderedEntries[0];\\n    if (!entry || !entry.tooltipElement || entry.tooltipLeft === void 0 || entry.tooltipTop === void 0)\\n      return;\\n    return {\\n      x: entry.tooltipLeft,\\n      y: entry.tooltipTop,\\n      left: entry.tooltipLeft,\\n      top: entry.tooltipTop,\\n      width: entry.tooltipElement.offsetWidth,\\n      height: entry.tooltipElement.offsetHeight,\\n      bottom: entry.tooltipTop + entry.tooltipElement.offsetHeight,\\n      right: entry.tooltipLeft + entry.tooltipElement.offsetWidth,\\n      toJSON: () => {\\n      }\\n    };\\n  }\\n  // Note: there is a copy of this method in dialog.tsx. Please fix bugs in both places.\\n  tooltipPosition(box, tooltipElement) {\\n    const tooltipWidth = tooltipElement.offsetWidth;\\n    const tooltipHeight = tooltipElement.offsetHeight;\\n    const totalWidth = this._glassPaneElement.offsetWidth;\\n    const totalHeight = this._glassPaneElement.offsetHeight;\\n    let anchorLeft = Math.max(5, box.left);\\n    if (anchorLeft + tooltipWidth > totalWidth - 5)\\n      anchorLeft = totalWidth - tooltipWidth - 5;\\n    let anchorTop = Math.max(0, box.bottom) + 5;\\n    if (anchorTop + tooltipHeight > totalHeight - 5) {\\n      if (Math.max(0, box.top) > tooltipHeight + 5) {\\n        anchorTop = Math.max(0, box.top) - tooltipHeight - 5;\\n      } else {\\n        anchorTop = totalHeight - 5 - tooltipHeight;\\n      }\\n    }\\n    return { anchorLeft, anchorTop };\\n  }\\n  _highlightIsUpToDate(entries) {\\n    if (entries.length !== this._renderedEntries.length)\\n      return false;\\n    for (let i = 0; i < this._renderedEntries.length; ++i) {\\n      if (entries[i].element !== this._renderedEntries[i].targetElement)\\n        return false;\\n      if (entries[i].color !== this._renderedEntries[i].color)\\n        return false;\\n      const oldBox = this._renderedEntries[i].box;\\n      if (!oldBox)\\n        return false;\\n      const box = entries[i].element.getBoundingClientRect();\\n      if (box.top !== oldBox.top || box.right !== oldBox.right || box.bottom !== oldBox.bottom || box.left !== oldBox.left)\\n        return false;\\n    }\\n    return true;\\n  }\\n  _createHighlightElement() {\\n    return this._injectedScript.document.createElement(\\\"x-pw-highlight\\\");\\n  }\\n  appendChild(element) {\\n    this._glassPaneShadow.appendChild(element);\\n  }\\n  onGlassPaneClick(handler) {\\n    this._glassPaneElement.style.pointerEvents = \\\"auto\\\";\\n    this._glassPaneElement.style.backgroundColor = \\\"rgba(0, 0, 0, 0.3)\\\";\\n    this._glassPaneElement.addEventListener(\\\"click\\\", handler);\\n  }\\n  offGlassPaneClick(handler) {\\n    this._glassPaneElement.style.pointerEvents = \\\"none\\\";\\n    this._glassPaneElement.style.backgroundColor = \\\"transparent\\\";\\n    this._glassPaneElement.removeEventListener(\\\"click\\\", handler);\\n  }\\n};\\n\\n// packages/playwright-injected/src/layoutSelectorUtils.ts\\nfunction boxRightOf(box1, box2, maxDistance) {\\n  const distance = box1.left - box2.right;\\n  if (distance < 0 || maxDistance !== void 0 && distance > maxDistance)\\n    return;\\n  return distance + Math.max(box2.bottom - box1.bottom, 0) + Math.max(box1.top - box2.top, 0);\\n}\\nfunction boxLeftOf(box1, box2, maxDistance) {\\n  const distance = box2.left - box1.right;\\n  if (distance < 0 || maxDistance !== void 0 && distance > maxDistance)\\n    return;\\n  return distance + Math.max(box2.bottom - box1.bottom, 0) + Math.max(box1.top - box2.top, 0);\\n}\\nfunction boxAbove(box1, box2, maxDistance) {\\n  const distance = box2.top - box1.bottom;\\n  if (distance < 0 || maxDistance !== void 0 && distance > maxDistance)\\n    return;\\n  return distance + Math.max(box1.left - box2.left, 0) + Math.max(box2.right - box1.right, 0);\\n}\\nfunction boxBelow(box1, box2, maxDistance) {\\n  const distance = box1.top - box2.bottom;\\n  if (distance < 0 || maxDistance !== void 0 && distance > maxDistance)\\n    return;\\n  return distance + Math.max(box1.left - box2.left, 0) + Math.max(box2.right - box1.right, 0);\\n}\\nfunction boxNear(box1, box2, maxDistance) {\\n  const kThreshold = maxDistance === void 0 ? 50 : maxDistance;\\n  let score = 0;\\n  if (box1.left - box2.right >= 0)\\n    score += box1.left - box2.right;\\n  if (box2.left - box1.right >= 0)\\n    score += box2.left - box1.right;\\n  if (box2.top - box1.bottom >= 0)\\n    score += box2.top - box1.bottom;\\n  if (box1.top - box2.bottom >= 0)\\n    score += box1.top - box2.bottom;\\n  return score > kThreshold ? void 0 : score;\\n}\\nvar kLayoutSelectorNames = [\\\"left-of\\\", \\\"right-of\\\", \\\"above\\\", \\\"below\\\", \\\"near\\\"];\\nfunction layoutSelectorScore(name, element, inner, maxDistance) {\\n  const box = element.getBoundingClientRect();\\n  const scorer = { \\\"left-of\\\": boxLeftOf, \\\"right-of\\\": boxRightOf, \\\"above\\\": boxAbove, \\\"below\\\": boxBelow, \\\"near\\\": boxNear }[name];\\n  let bestScore;\\n  for (const e of inner) {\\n    if (e === element)\\n      continue;\\n    const score = scorer(box, e.getBoundingClientRect(), maxDistance);\\n    if (score === void 0)\\n      continue;\\n    if (bestScore === void 0 || score < bestScore)\\n      bestScore = score;\\n  }\\n  return bestScore;\\n}\\n\\n// packages/playwright-injected/src/selectorUtils.ts\\nfunction matchesComponentAttribute(obj, attr) {\\n  for (const token of attr.jsonPath) {\\n    if (obj !== void 0 && obj !== null)\\n      obj = obj[token];\\n  }\\n  return matchesAttributePart(obj, attr);\\n}\\nfunction matchesAttributePart(value, attr) {\\n  const objValue = typeof value === \\\"string\\\" && !attr.caseSensitive ? value.toUpperCase() : value;\\n  const attrValue = typeof attr.value === \\\"string\\\" && !attr.caseSensitive ? attr.value.toUpperCase() : attr.value;\\n  if (attr.op === \\\"<truthy>\\\")\\n    return !!objValue;\\n  if (attr.op === \\\"=\\\") {\\n    if (attrValue instanceof RegExp)\\n      return typeof objValue === \\\"string\\\" && !!objValue.match(attrValue);\\n    return objValue === attrValue;\\n  }\\n  if (typeof objValue !== \\\"string\\\" || typeof attrValue !== \\\"string\\\")\\n    return false;\\n  if (attr.op === \\\"*=\\\")\\n    return objValue.includes(attrValue);\\n  if (attr.op === \\\"^=\\\")\\n    return objValue.startsWith(attrValue);\\n  if (attr.op === \\\"$=\\\")\\n    return objValue.endsWith(attrValue);\\n  if (attr.op === \\\"|=\\\")\\n    return objValue === attrValue || objValue.startsWith(attrValue + \\\"-\\\");\\n  if (attr.op === \\\"~=\\\")\\n    return objValue.split(\\\" \\\").includes(attrValue);\\n  return false;\\n}\\nfunction shouldSkipForTextMatching(element) {\\n  const document = element.ownerDocument;\\n  return element.nodeName === \\\"SCRIPT\\\" || element.nodeName === \\\"NOSCRIPT\\\" || element.nodeName === \\\"STYLE\\\" || document.head && document.head.contains(element);\\n}\\nfunction elementText(cache, root) {\\n  let value = cache.get(root);\\n  if (value === void 0) {\\n    value = { full: \\\"\\\", normalized: \\\"\\\", immediate: [] };\\n    if (!shouldSkipForTextMatching(root)) {\\n      let currentImmediate = \\\"\\\";\\n      if (root instanceof HTMLInputElement && (root.type === \\\"submit\\\" || root.type === \\\"button\\\")) {\\n        value = { full: root.value, normalized: normalizeWhiteSpace(root.value), immediate: [root.value] };\\n      } else {\\n        for (let child = root.firstChild; child; child = child.nextSibling) {\\n          if (child.nodeType === Node.TEXT_NODE) {\\n            value.full += child.nodeValue || \\\"\\\";\\n            currentImmediate += child.nodeValue || \\\"\\\";\\n          } else if (child.nodeType === Node.COMMENT_NODE) {\\n            continue;\\n          } else {\\n            if (currentImmediate)\\n              value.immediate.push(currentImmediate);\\n            currentImmediate = \\\"\\\";\\n            if (child.nodeType === Node.ELEMENT_NODE)\\n              value.full += elementText(cache, child).full;\\n          }\\n        }\\n        if (currentImmediate)\\n          value.immediate.push(currentImmediate);\\n        if (root.shadowRoot)\\n          value.full += elementText(cache, root.shadowRoot).full;\\n        if (value.full)\\n          value.normalized = normalizeWhiteSpace(value.full);\\n      }\\n    }\\n    cache.set(root, value);\\n  }\\n  return value;\\n}\\nfunction elementMatchesText(cache, element, matcher) {\\n  if (shouldSkipForTextMatching(element))\\n    return \\\"none\\\";\\n  if (!matcher(elementText(cache, element)))\\n    return \\\"none\\\";\\n  for (let child = element.firstChild; child; child = child.nextSibling) {\\n    if (child.nodeType === Node.ELEMENT_NODE && matcher(elementText(cache, child)))\\n      return \\\"selfAndChildren\\\";\\n  }\\n  if (element.shadowRoot && matcher(elementText(cache, element.shadowRoot)))\\n    return \\\"selfAndChildren\\\";\\n  return \\\"self\\\";\\n}\\nfunction getElementLabels(textCache, element) {\\n  const labels = getAriaLabelledByElements(element);\\n  if (labels)\\n    return labels.map((label) => elementText(textCache, label));\\n  const ariaLabel = element.getAttribute(\\\"aria-label\\\");\\n  if (ariaLabel !== null && !!ariaLabel.trim())\\n    return [{ full: ariaLabel, normalized: normalizeWhiteSpace(ariaLabel), immediate: [ariaLabel] }];\\n  const isNonHiddenInput = element.nodeName === \\\"INPUT\\\" && element.type !== \\\"hidden\\\";\\n  if ([\\\"BUTTON\\\", \\\"METER\\\", \\\"OUTPUT\\\", \\\"PROGRESS\\\", \\\"SELECT\\\", \\\"TEXTAREA\\\"].includes(element.nodeName) || isNonHiddenInput) {\\n    const labels2 = element.labels;\\n    if (labels2)\\n      return [...labels2].map((label) => elementText(textCache, label));\\n  }\\n  return [];\\n}\\n\\n// packages/playwright-injected/src/reactSelectorEngine.ts\\nfunction getFunctionComponentName(component) {\\n  return component.displayName || component.name || \\\"Anonymous\\\";\\n}\\nfunction getComponentName(reactElement) {\\n  if (reactElement.type) {\\n    switch (typeof reactElement.type) {\\n      case \\\"function\\\":\\n        return getFunctionComponentName(reactElement.type);\\n      case \\\"string\\\":\\n        return reactElement.type;\\n      case \\\"object\\\":\\n        return reactElement.type.displayName || (reactElement.type.render ? getFunctionComponentName(reactElement.type.render) : \\\"\\\");\\n    }\\n  }\\n  if (reactElement._currentElement) {\\n    const elementType = reactElement._currentElement.type;\\n    if (typeof elementType === \\\"string\\\")\\n      return elementType;\\n    if (typeof elementType === \\\"function\\\")\\n      return elementType.displayName || elementType.name || \\\"Anonymous\\\";\\n  }\\n  return \\\"\\\";\\n}\\nfunction getComponentKey(reactElement) {\\n  var _a, _b;\\n  return (_b = reactElement.key) != null ? _b : (_a = reactElement._currentElement) == null ? void 0 : _a.key;\\n}\\nfunction getChildren(reactElement) {\\n  if (reactElement.child) {\\n    const children = [];\\n    for (let child = reactElement.child; child; child = child.sibling)\\n      children.push(child);\\n    return children;\\n  }\\n  if (!reactElement._currentElement)\\n    return [];\\n  const isKnownElement = (reactElement2) => {\\n    var _a;\\n    const elementType = (_a = reactElement2._currentElement) == null ? void 0 : _a.type;\\n    return typeof elementType === \\\"function\\\" || typeof elementType === \\\"string\\\";\\n  };\\n  if (reactElement._renderedComponent) {\\n    const child = reactElement._renderedComponent;\\n    return isKnownElement(child) ? [child] : [];\\n  }\\n  if (reactElement._renderedChildren)\\n    return [...Object.values(reactElement._renderedChildren)].filter(isKnownElement);\\n  return [];\\n}\\nfunction getProps(reactElement) {\\n  var _a;\\n  const props = (\\n    /* React 16+ */\\n    reactElement.memoizedProps || /* React 15 */\\n    ((_a = reactElement._currentElement) == null ? void 0 : _a.props)\\n  );\\n  if (!props || typeof props === \\\"string\\\")\\n    return props;\\n  const result = { ...props };\\n  delete result.children;\\n  return result;\\n}\\nfunction buildComponentsTree(reactElement) {\\n  var _a;\\n  const treeNode = {\\n    key: getComponentKey(reactElement),\\n    name: getComponentName(reactElement),\\n    children: getChildren(reactElement).map(buildComponentsTree),\\n    rootElements: [],\\n    props: getProps(reactElement)\\n  };\\n  const rootElement = (\\n    /* React 16+ */\\n    reactElement.stateNode || /* React 15 */\\n    reactElement._hostNode || /* React 15 */\\n    ((_a = reactElement._renderedComponent) == null ? void 0 : _a._hostNode)\\n  );\\n  if (rootElement instanceof Element) {\\n    treeNode.rootElements.push(rootElement);\\n  } else {\\n    for (const child of treeNode.children)\\n      treeNode.rootElements.push(...child.rootElements);\\n  }\\n  return treeNode;\\n}\\nfunction filterComponentsTree(treeNode, searchFn, result = []) {\\n  if (searchFn(treeNode))\\n    result.push(treeNode);\\n  for (const child of treeNode.children)\\n    filterComponentsTree(child, searchFn, result);\\n  return result;\\n}\\nfunction findReactRoots(root, roots = []) {\\n  const document = root.ownerDocument || root;\\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\\n  do {\\n    const node = walker.currentNode;\\n    const reactNode = node;\\n    const rootKey = Object.keys(reactNode).find((key) => key.startsWith(\\\"__reactContainer\\\") && reactNode[key] !== null);\\n    if (rootKey) {\\n      roots.push(reactNode[rootKey].stateNode.current);\\n    } else {\\n      const legacyRootKey = \\\"_reactRootContainer\\\";\\n      if (reactNode.hasOwnProperty(legacyRootKey) && reactNode[legacyRootKey] !== null) {\\n        roots.push(reactNode[legacyRootKey]._internalRoot.current);\\n      }\\n    }\\n    if (node instanceof Element && node.hasAttribute(\\\"data-reactroot\\\")) {\\n      for (const key of Object.keys(node)) {\\n        if (key.startsWith(\\\"__reactInternalInstance\\\") || key.startsWith(\\\"__reactFiber\\\"))\\n          roots.push(node[key]);\\n      }\\n    }\\n    const shadowRoot = node instanceof Element ? node.shadowRoot : null;\\n    if (shadowRoot)\\n      findReactRoots(shadowRoot, roots);\\n  } while (walker.nextNode());\\n  return roots;\\n}\\nvar createReactEngine = () => ({\\n  queryAll(scope, selector) {\\n    const { name, attributes } = parseAttributeSelector(selector, false);\\n    const reactRoots = findReactRoots(scope.ownerDocument || scope);\\n    const trees = reactRoots.map((reactRoot) => buildComponentsTree(reactRoot));\\n    const treeNodes = trees.map((tree) => filterComponentsTree(tree, (treeNode) => {\\n      var _a;\\n      const props = (_a = treeNode.props) != null ? _a : {};\\n      if (treeNode.key !== void 0)\\n        props.key = treeNode.key;\\n      if (name && treeNode.name !== name)\\n        return false;\\n      if (treeNode.rootElements.some((domNode) => !isInsideScope(scope, domNode)))\\n        return false;\\n      for (const attr of attributes) {\\n        if (!matchesComponentAttribute(props, attr))\\n          return false;\\n      }\\n      return true;\\n    })).flat();\\n    const allRootElements = /* @__PURE__ */ new Set();\\n    for (const treeNode of treeNodes) {\\n      for (const domNode of treeNode.rootElements)\\n        allRootElements.add(domNode);\\n    }\\n    return [...allRootElements];\\n  }\\n});\\n\\n// packages/playwright-injected/src/roleSelectorEngine.ts\\nvar kSupportedAttributes = [\\\"selected\\\", \\\"checked\\\", \\\"pressed\\\", \\\"expanded\\\", \\\"level\\\", \\\"disabled\\\", \\\"name\\\", \\\"include-hidden\\\"];\\nkSupportedAttributes.sort();\\nfunction validateSupportedRole(attr, roles, role) {\\n  if (!roles.includes(role))\\n    throw new Error(`\\\"${attr}\\\" attribute is only supported for roles: ${roles.slice().sort().map((role2) => `\\\"${role2}\\\"`).join(\\\", \\\")}`);\\n}\\nfunction validateSupportedValues(attr, values) {\\n  if (attr.op !== \\\"<truthy>\\\" && !values.includes(attr.value))\\n    throw new Error(`\\\"${attr.name}\\\" must be one of ${values.map((v) => JSON.stringify(v)).join(\\\", \\\")}`);\\n}\\nfunction validateSupportedOp(attr, ops) {\\n  if (!ops.includes(attr.op))\\n    throw new Error(`\\\"${attr.name}\\\" does not support \\\"${attr.op}\\\" matcher`);\\n}\\nfunction validateAttributes(attrs, role) {\\n  const options = { role };\\n  for (const attr of attrs) {\\n    switch (attr.name) {\\n      case \\\"checked\\\": {\\n        validateSupportedRole(attr.name, kAriaCheckedRoles, role);\\n        validateSupportedValues(attr, [true, false, \\\"mixed\\\"]);\\n        validateSupportedOp(attr, [\\\"<truthy>\\\", \\\"=\\\"]);\\n        options.checked = attr.op === \\\"<truthy>\\\" ? true : attr.value;\\n        break;\\n      }\\n      case \\\"pressed\\\": {\\n        validateSupportedRole(attr.name, kAriaPressedRoles, role);\\n        validateSupportedValues(attr, [true, false, \\\"mixed\\\"]);\\n        validateSupportedOp(attr, [\\\"<truthy>\\\", \\\"=\\\"]);\\n        options.pressed = attr.op === \\\"<truthy>\\\" ? true : attr.value;\\n        break;\\n      }\\n      case \\\"selected\\\": {\\n        validateSupportedRole(attr.name, kAriaSelectedRoles, role);\\n        validateSupportedValues(attr, [true, false]);\\n        validateSupportedOp(attr, [\\\"<truthy>\\\", \\\"=\\\"]);\\n        options.selected = attr.op === \\\"<truthy>\\\" ? true : attr.value;\\n        break;\\n      }\\n      case \\\"expanded\\\": {\\n        validateSupportedRole(attr.name, kAriaExpandedRoles, role);\\n        validateSupportedValues(attr, [true, false]);\\n        validateSupportedOp(attr, [\\\"<truthy>\\\", \\\"=\\\"]);\\n        options.expanded = attr.op === \\\"<truthy>\\\" ? true : attr.value;\\n        break;\\n      }\\n      case \\\"level\\\": {\\n        validateSupportedRole(attr.name, kAriaLevelRoles, role);\\n        if (typeof attr.value === \\\"string\\\")\\n          attr.value = +attr.value;\\n        if (attr.op !== \\\"=\\\" || typeof attr.value !== \\\"number\\\" || Number.isNaN(attr.value))\\n          throw new Error(`\\\"level\\\" attribute must be compared to a number`);\\n        options.level = attr.value;\\n        break;\\n      }\\n      case \\\"disabled\\\": {\\n        validateSupportedValues(attr, [true, false]);\\n        validateSupportedOp(attr, [\\\"<truthy>\\\", \\\"=\\\"]);\\n        options.disabled = attr.op === \\\"<truthy>\\\" ? true : attr.value;\\n        break;\\n      }\\n      case \\\"name\\\": {\\n        if (attr.op === \\\"<truthy>\\\")\\n          throw new Error(`\\\"name\\\" attribute must have a value`);\\n        if (typeof attr.value !== \\\"string\\\" && !(attr.value instanceof RegExp))\\n          throw new Error(`\\\"name\\\" attribute must be a string or a regular expression`);\\n        options.name = attr.value;\\n        options.nameOp = attr.op;\\n        options.exact = attr.caseSensitive;\\n        break;\\n      }\\n      case \\\"include-hidden\\\": {\\n        validateSupportedValues(attr, [true, false]);\\n        validateSupportedOp(attr, [\\\"<truthy>\\\", \\\"=\\\"]);\\n        options.includeHidden = attr.op === \\\"<truthy>\\\" ? true : attr.value;\\n        break;\\n      }\\n      default: {\\n        throw new Error(`Unknown attribute \\\"${attr.name}\\\", must be one of ${kSupportedAttributes.map((a) => `\\\"${a}\\\"`).join(\\\", \\\")}.`);\\n      }\\n    }\\n  }\\n  return options;\\n}\\nfunction queryRole(scope, options, internal) {\\n  const result = [];\\n  const match = (element) => {\\n    if (getAriaRole(element) !== options.role)\\n      return;\\n    if (options.selected !== void 0 && getAriaSelected(element) !== options.selected)\\n      return;\\n    if (options.checked !== void 0 && getAriaChecked(element) !== options.checked)\\n      return;\\n    if (options.pressed !== void 0 && getAriaPressed(element) !== options.pressed)\\n      return;\\n    if (options.expanded !== void 0 && getAriaExpanded(element) !== options.expanded)\\n      return;\\n    if (options.level !== void 0 && getAriaLevel(element) !== options.level)\\n      return;\\n    if (options.disabled !== void 0 && getAriaDisabled(element) !== options.disabled)\\n      return;\\n    if (!options.includeHidden) {\\n      const isHidden = isElementHiddenForAria(element);\\n      if (isHidden)\\n        return;\\n    }\\n    if (options.name !== void 0) {\\n      const accessibleName = normalizeWhiteSpace(getElementAccessibleName(element, !!options.includeHidden));\\n      if (typeof options.name === \\\"string\\\")\\n        options.name = normalizeWhiteSpace(options.name);\\n      if (internal && !options.exact && options.nameOp === \\\"=\\\")\\n        options.nameOp = \\\"*=\\\";\\n      if (!matchesAttributePart(accessibleName, { name: \\\"\\\", jsonPath: [], op: options.nameOp || \\\"=\\\", value: options.name, caseSensitive: !!options.exact }))\\n        return;\\n    }\\n    result.push(element);\\n  };\\n  const query = (root) => {\\n    const shadows = [];\\n    if (root.shadowRoot)\\n      shadows.push(root.shadowRoot);\\n    for (const element of root.querySelectorAll(\\\"*\\\")) {\\n      match(element);\\n      if (element.shadowRoot)\\n        shadows.push(element.shadowRoot);\\n    }\\n    shadows.forEach(query);\\n  };\\n  query(scope);\\n  return result;\\n}\\nfunction createRoleEngine(internal) {\\n  return {\\n    queryAll: (scope, selector) => {\\n      const parsed = parseAttributeSelector(selector, true);\\n      const role = parsed.name.toLowerCase();\\n      if (!role)\\n        throw new Error(`Role must not be empty`);\\n      const options = validateAttributes(parsed.attributes, role);\\n      beginAriaCaches();\\n      try {\\n        return queryRole(scope, options, internal);\\n      } finally {\\n        endAriaCaches();\\n      }\\n    }\\n  };\\n}\\n\\n// packages/playwright-injected/src/selectorEvaluator.ts\\nvar SelectorEvaluatorImpl = class {\\n  constructor() {\\n    this._retainCacheCounter = 0;\\n    this._cacheText = /* @__PURE__ */ new Map();\\n    this._cacheQueryCSS = /* @__PURE__ */ new Map();\\n    this._cacheMatches = /* @__PURE__ */ new Map();\\n    this._cacheQuery = /* @__PURE__ */ new Map();\\n    this._cacheMatchesSimple = /* @__PURE__ */ new Map();\\n    this._cacheMatchesParents = /* @__PURE__ */ new Map();\\n    this._cacheCallMatches = /* @__PURE__ */ new Map();\\n    this._cacheCallQuery = /* @__PURE__ */ new Map();\\n    this._cacheQuerySimple = /* @__PURE__ */ new Map();\\n    this._engines = /* @__PURE__ */ new Map();\\n    this._engines.set(\\\"not\\\", notEngine);\\n    this._engines.set(\\\"is\\\", isEngine);\\n    this._engines.set(\\\"where\\\", isEngine);\\n    this._engines.set(\\\"has\\\", hasEngine);\\n    this._engines.set(\\\"scope\\\", scopeEngine);\\n    this._engines.set(\\\"light\\\", lightEngine);\\n    this._engines.set(\\\"visible\\\", visibleEngine);\\n    this._engines.set(\\\"text\\\", textEngine);\\n    this._engines.set(\\\"text-is\\\", textIsEngine);\\n    this._engines.set(\\\"text-matches\\\", textMatchesEngine);\\n    this._engines.set(\\\"has-text\\\", hasTextEngine);\\n    this._engines.set(\\\"right-of\\\", createLayoutEngine(\\\"right-of\\\"));\\n    this._engines.set(\\\"left-of\\\", createLayoutEngine(\\\"left-of\\\"));\\n    this._engines.set(\\\"above\\\", createLayoutEngine(\\\"above\\\"));\\n    this._engines.set(\\\"below\\\", createLayoutEngine(\\\"below\\\"));\\n    this._engines.set(\\\"near\\\", createLayoutEngine(\\\"near\\\"));\\n    this._engines.set(\\\"nth-match\\\", nthMatchEngine);\\n    const allNames = [...this._engines.keys()];\\n    allNames.sort();\\n    const parserNames = [...customCSSNames];\\n    parserNames.sort();\\n    if (allNames.join(\\\"|\\\") !== parserNames.join(\\\"|\\\"))\\n      throw new Error(`Please keep customCSSNames in sync with evaluator engines: ${allNames.join(\\\"|\\\")} vs ${parserNames.join(\\\"|\\\")}`);\\n  }\\n  begin() {\\n    ++this._retainCacheCounter;\\n  }\\n  end() {\\n    --this._retainCacheCounter;\\n    if (!this._retainCacheCounter) {\\n      this._cacheQueryCSS.clear();\\n      this._cacheMatches.clear();\\n      this._cacheQuery.clear();\\n      this._cacheMatchesSimple.clear();\\n      this._cacheMatchesParents.clear();\\n      this._cacheCallMatches.clear();\\n      this._cacheCallQuery.clear();\\n      this._cacheQuerySimple.clear();\\n      this._cacheText.clear();\\n    }\\n  }\\n  _cached(cache, main, rest, cb) {\\n    if (!cache.has(main))\\n      cache.set(main, []);\\n    const entries = cache.get(main);\\n    const entry = entries.find((e) => rest.every((value, index) => e.rest[index] === value));\\n    if (entry)\\n      return entry.result;\\n    const result = cb();\\n    entries.push({ rest, result });\\n    return result;\\n  }\\n  _checkSelector(s) {\\n    const wellFormed = typeof s === \\\"object\\\" && s && (Array.isArray(s) || \\\"simples\\\" in s && s.simples.length);\\n    if (!wellFormed)\\n      throw new Error(`Malformed selector \\\"${s}\\\"`);\\n    return s;\\n  }\\n  matches(element, s, context) {\\n    const selector = this._checkSelector(s);\\n    this.begin();\\n    try {\\n      return this._cached(this._cacheMatches, element, [selector, context.scope, context.pierceShadow, context.originalScope], () => {\\n        if (Array.isArray(selector))\\n          return this._matchesEngine(isEngine, element, selector, context);\\n        if (this._hasScopeClause(selector))\\n          context = this._expandContextForScopeMatching(context);\\n        if (!this._matchesSimple(element, selector.simples[selector.simples.length - 1].selector, context))\\n          return false;\\n        return this._matchesParents(element, selector, selector.simples.length - 2, context);\\n      });\\n    } finally {\\n      this.end();\\n    }\\n  }\\n  query(context, s) {\\n    const selector = this._checkSelector(s);\\n    this.begin();\\n    try {\\n      return this._cached(this._cacheQuery, selector, [context.scope, context.pierceShadow, context.originalScope], () => {\\n        if (Array.isArray(selector))\\n          return this._queryEngine(isEngine, context, selector);\\n        if (this._hasScopeClause(selector))\\n          context = this._expandContextForScopeMatching(context);\\n        const previousScoreMap = this._scoreMap;\\n        this._scoreMap = /* @__PURE__ */ new Map();\\n        let elements = this._querySimple(context, selector.simples[selector.simples.length - 1].selector);\\n        elements = elements.filter((element) => this._matchesParents(element, selector, selector.simples.length - 2, context));\\n        if (this._scoreMap.size) {\\n          elements.sort((a, b) => {\\n            const aScore = this._scoreMap.get(a);\\n            const bScore = this._scoreMap.get(b);\\n            if (aScore === bScore)\\n              return 0;\\n            if (aScore === void 0)\\n              return 1;\\n            if (bScore === void 0)\\n              return -1;\\n            return aScore - bScore;\\n          });\\n        }\\n        this._scoreMap = previousScoreMap;\\n        return elements;\\n      });\\n    } finally {\\n      this.end();\\n    }\\n  }\\n  _markScore(element, score) {\\n    if (this._scoreMap)\\n      this._scoreMap.set(element, score);\\n  }\\n  _hasScopeClause(selector) {\\n    return selector.simples.some((simple) => simple.selector.functions.some((f) => f.name === \\\"scope\\\"));\\n  }\\n  _expandContextForScopeMatching(context) {\\n    if (context.scope.nodeType !== 1)\\n      return context;\\n    const scope = parentElementOrShadowHost(context.scope);\\n    if (!scope)\\n      return context;\\n    return { ...context, scope, originalScope: context.originalScope || context.scope };\\n  }\\n  _matchesSimple(element, simple, context) {\\n    return this._cached(this._cacheMatchesSimple, element, [simple, context.scope, context.pierceShadow, context.originalScope], () => {\\n      if (element === context.scope)\\n        return false;\\n      if (simple.css && !this._matchesCSS(element, simple.css))\\n        return false;\\n      for (const func of simple.functions) {\\n        if (!this._matchesEngine(this._getEngine(func.name), element, func.args, context))\\n          return false;\\n      }\\n      return true;\\n    });\\n  }\\n  _querySimple(context, simple) {\\n    if (!simple.functions.length)\\n      return this._queryCSS(context, simple.css || \\\"*\\\");\\n    return this._cached(this._cacheQuerySimple, simple, [context.scope, context.pierceShadow, context.originalScope], () => {\\n      let css = simple.css;\\n      const funcs = simple.functions;\\n      if (css === \\\"*\\\" && funcs.length)\\n        css = void 0;\\n      let elements;\\n      let firstIndex = -1;\\n      if (css !== void 0) {\\n        elements = this._queryCSS(context, css);\\n      } else {\\n        firstIndex = funcs.findIndex((func) => this._getEngine(func.name).query !== void 0);\\n        if (firstIndex === -1)\\n          firstIndex = 0;\\n        elements = this._queryEngine(this._getEngine(funcs[firstIndex].name), context, funcs[firstIndex].args);\\n      }\\n      for (let i = 0; i < funcs.length; i++) {\\n        if (i === firstIndex)\\n          continue;\\n        const engine = this._getEngine(funcs[i].name);\\n        if (engine.matches !== void 0)\\n          elements = elements.filter((e) => this._matchesEngine(engine, e, funcs[i].args, context));\\n      }\\n      for (let i = 0; i < funcs.length; i++) {\\n        if (i === firstIndex)\\n          continue;\\n        const engine = this._getEngine(funcs[i].name);\\n        if (engine.matches === void 0)\\n          elements = elements.filter((e) => this._matchesEngine(engine, e, funcs[i].args, context));\\n      }\\n      return elements;\\n    });\\n  }\\n  _matchesParents(element, complex, index, context) {\\n    if (index < 0)\\n      return true;\\n    return this._cached(this._cacheMatchesParents, element, [complex, index, context.scope, context.pierceShadow, context.originalScope], () => {\\n      const { selector: simple, combinator } = complex.simples[index];\\n      if (combinator === \\\">\\\") {\\n        const parent = parentElementOrShadowHostInContext(element, context);\\n        if (!parent || !this._matchesSimple(parent, simple, context))\\n          return false;\\n        return this._matchesParents(parent, complex, index - 1, context);\\n      }\\n      if (combinator === \\\"+\\\") {\\n        const previousSibling = previousSiblingInContext(element, context);\\n        if (!previousSibling || !this._matchesSimple(previousSibling, simple, context))\\n          return false;\\n        return this._matchesParents(previousSibling, complex, index - 1, context);\\n      }\\n      if (combinator === \\\"\\\") {\\n        let parent = parentElementOrShadowHostInContext(element, context);\\n        while (parent) {\\n          if (this._matchesSimple(parent, simple, context)) {\\n            if (this._matchesParents(parent, complex, index - 1, context))\\n              return true;\\n            if (complex.simples[index - 1].combinator === \\\"\\\")\\n              break;\\n          }\\n          parent = parentElementOrShadowHostInContext(parent, context);\\n        }\\n        return false;\\n      }\\n      if (combinator === \\\"~\\\") {\\n        let previousSibling = previousSiblingInContext(element, context);\\n        while (previousSibling) {\\n          if (this._matchesSimple(previousSibling, simple, context)) {\\n            if (this._matchesParents(previousSibling, complex, index - 1, context))\\n              return true;\\n            if (complex.simples[index - 1].combinator === \\\"~\\\")\\n              break;\\n          }\\n          previousSibling = previousSiblingInContext(previousSibling, context);\\n        }\\n        return false;\\n      }\\n      if (combinator === \\\">=\\\") {\\n        let parent = element;\\n        while (parent) {\\n          if (this._matchesSimple(parent, simple, context)) {\\n            if (this._matchesParents(parent, complex, index - 1, context))\\n              return true;\\n            if (complex.simples[index - 1].combinator === \\\"\\\")\\n              break;\\n          }\\n          parent = parentElementOrShadowHostInContext(parent, context);\\n        }\\n        return false;\\n      }\\n      throw new Error(`Unsupported combinator \\\"${combinator}\\\"`);\\n    });\\n  }\\n  _matchesEngine(engine, element, args, context) {\\n    if (engine.matches)\\n      return this._callMatches(engine, element, args, context);\\n    if (engine.query)\\n      return this._callQuery(engine, args, context).includes(element);\\n    throw new Error(`Selector engine should implement \\\"matches\\\" or \\\"query\\\"`);\\n  }\\n  _queryEngine(engine, context, args) {\\n    if (engine.query)\\n      return this._callQuery(engine, args, context);\\n    if (engine.matches)\\n      return this._queryCSS(context, \\\"*\\\").filter((element) => this._callMatches(engine, element, args, context));\\n    throw new Error(`Selector engine should implement \\\"matches\\\" or \\\"query\\\"`);\\n  }\\n  _callMatches(engine, element, args, context) {\\n    return this._cached(this._cacheCallMatches, element, [engine, context.scope, context.pierceShadow, context.originalScope, ...args], () => {\\n      return engine.matches(element, args, context, this);\\n    });\\n  }\\n  _callQuery(engine, args, context) {\\n    return this._cached(this._cacheCallQuery, engine, [context.scope, context.pierceShadow, context.originalScope, ...args], () => {\\n      return engine.query(context, args, this);\\n    });\\n  }\\n  _matchesCSS(element, css) {\\n    return element.matches(css);\\n  }\\n  _queryCSS(context, css) {\\n    return this._cached(this._cacheQueryCSS, css, [context.scope, context.pierceShadow, context.originalScope], () => {\\n      let result = [];\\n      function query(root) {\\n        result = result.concat([...root.querySelectorAll(css)]);\\n        if (!context.pierceShadow)\\n          return;\\n        if (root.shadowRoot)\\n          query(root.shadowRoot);\\n        for (const element of root.querySelectorAll(\\\"*\\\")) {\\n          if (element.shadowRoot)\\n            query(element.shadowRoot);\\n        }\\n      }\\n      query(context.scope);\\n      return result;\\n    });\\n  }\\n  _getEngine(name) {\\n    const engine = this._engines.get(name);\\n    if (!engine)\\n      throw new Error(`Unknown selector engine \\\"${name}\\\"`);\\n    return engine;\\n  }\\n};\\nvar isEngine = {\\n  matches(element, args, context, evaluator) {\\n    if (args.length === 0)\\n      throw new Error(`\\\"is\\\" engine expects non-empty selector list`);\\n    return args.some((selector) => evaluator.matches(element, selector, context));\\n  },\\n  query(context, args, evaluator) {\\n    if (args.length === 0)\\n      throw new Error(`\\\"is\\\" engine expects non-empty selector list`);\\n    let elements = [];\\n    for (const arg of args)\\n      elements = elements.concat(evaluator.query(context, arg));\\n    return args.length === 1 ? elements : sortInDOMOrder(elements);\\n  }\\n};\\nvar hasEngine = {\\n  matches(element, args, context, evaluator) {\\n    if (args.length === 0)\\n      throw new Error(`\\\"has\\\" engine expects non-empty selector list`);\\n    return evaluator.query({ ...context, scope: element }, args).length > 0;\\n  }\\n  // TODO: we can implement efficient \\\"query\\\" by matching \\\"args\\\" and returning\\n  // all parents/descendants, just have to be careful with the \\\":scope\\\" matching.\\n};\\nvar scopeEngine = {\\n  matches(element, args, context, evaluator) {\\n    if (args.length !== 0)\\n      throw new Error(`\\\"scope\\\" engine expects no arguments`);\\n    const actualScope = context.originalScope || context.scope;\\n    if (actualScope.nodeType === 9)\\n      return element === actualScope.documentElement;\\n    return element === actualScope;\\n  },\\n  query(context, args, evaluator) {\\n    if (args.length !== 0)\\n      throw new Error(`\\\"scope\\\" engine expects no arguments`);\\n    const actualScope = context.originalScope || context.scope;\\n    if (actualScope.nodeType === 9) {\\n      const root = actualScope.documentElement;\\n      return root ? [root] : [];\\n    }\\n    if (actualScope.nodeType === 1)\\n      return [actualScope];\\n    return [];\\n  }\\n};\\nvar notEngine = {\\n  matches(element, args, context, evaluator) {\\n    if (args.length === 0)\\n      throw new Error(`\\\"not\\\" engine expects non-empty selector list`);\\n    return !evaluator.matches(element, args, context);\\n  }\\n};\\nvar lightEngine = {\\n  query(context, args, evaluator) {\\n    return evaluator.query({ ...context, pierceShadow: false }, args);\\n  },\\n  matches(element, args, context, evaluator) {\\n    return evaluator.matches(element, args, { ...context, pierceShadow: false });\\n  }\\n};\\nvar visibleEngine = {\\n  matches(element, args, context, evaluator) {\\n    if (args.length)\\n      throw new Error(`\\\"visible\\\" engine expects no arguments`);\\n    return isElementVisible(element);\\n  }\\n};\\nvar textEngine = {\\n  matches(element, args, context, evaluator) {\\n    if (args.length !== 1 || typeof args[0] !== \\\"string\\\")\\n      throw new Error(`\\\"text\\\" engine expects a single string`);\\n    const text = normalizeWhiteSpace(args[0]).toLowerCase();\\n    const matcher = (elementText2) => elementText2.normalized.toLowerCase().includes(text);\\n    return elementMatchesText(evaluator._cacheText, element, matcher) === \\\"self\\\";\\n  }\\n};\\nvar textIsEngine = {\\n  matches(element, args, context, evaluator) {\\n    if (args.length !== 1 || typeof args[0] !== \\\"string\\\")\\n      throw new Error(`\\\"text-is\\\" engine expects a single string`);\\n    const text = normalizeWhiteSpace(args[0]);\\n    const matcher = (elementText2) => {\\n      if (!text && !elementText2.immediate.length)\\n        return true;\\n      return elementText2.immediate.some((s) => normalizeWhiteSpace(s) === text);\\n    };\\n    return elementMatchesText(evaluator._cacheText, element, matcher) !== \\\"none\\\";\\n  }\\n};\\nvar textMatchesEngine = {\\n  matches(element, args, context, evaluator) {\\n    if (args.length === 0 || typeof args[0] !== \\\"string\\\" || args.length > 2 || args.length === 2 && typeof args[1] !== \\\"string\\\")\\n      throw new Error(`\\\"text-matches\\\" engine expects a regexp body and optional regexp flags`);\\n    const re = new RegExp(args[0], args.length === 2 ? args[1] : void 0);\\n    const matcher = (elementText2) => re.test(elementText2.full);\\n    return elementMatchesText(evaluator._cacheText, element, matcher) === \\\"self\\\";\\n  }\\n};\\nvar hasTextEngine = {\\n  matches(element, args, context, evaluator) {\\n    if (args.length !== 1 || typeof args[0] !== \\\"string\\\")\\n      throw new Error(`\\\"has-text\\\" engine expects a single string`);\\n    if (shouldSkipForTextMatching(element))\\n      return false;\\n    const text = normalizeWhiteSpace(args[0]).toLowerCase();\\n    const matcher = (elementText2) => elementText2.normalized.toLowerCase().includes(text);\\n    return matcher(elementText(evaluator._cacheText, element));\\n  }\\n};\\nfunction createLayoutEngine(name) {\\n  return {\\n    matches(element, args, context, evaluator) {\\n      const maxDistance = args.length && typeof args[args.length - 1] === \\\"number\\\" ? args[args.length - 1] : void 0;\\n      const queryArgs = maxDistance === void 0 ? args : args.slice(0, args.length - 1);\\n      if (args.length < 1 + (maxDistance === void 0 ? 0 : 1))\\n        throw new Error(`\\\"${name}\\\" engine expects a selector list and optional maximum distance in pixels`);\\n      const inner = evaluator.query(context, queryArgs);\\n      const score = layoutSelectorScore(name, element, inner, maxDistance);\\n      if (score === void 0)\\n        return false;\\n      evaluator._markScore(element, score);\\n      return true;\\n    }\\n  };\\n}\\nvar nthMatchEngine = {\\n  query(context, args, evaluator) {\\n    let index = args[args.length - 1];\\n    if (args.length < 2)\\n      throw new Error(`\\\"nth-match\\\" engine expects non-empty selector list and an index argument`);\\n    if (typeof index !== \\\"number\\\" || index < 1)\\n      throw new Error(`\\\"nth-match\\\" engine expects a one-based index as the last argument`);\\n    const elements = isEngine.query(context, args.slice(0, args.length - 1), evaluator);\\n    index--;\\n    return index < elements.length ? [elements[index]] : [];\\n  }\\n};\\nfunction parentElementOrShadowHostInContext(element, context) {\\n  if (element === context.scope)\\n    return;\\n  if (!context.pierceShadow)\\n    return element.parentElement || void 0;\\n  return parentElementOrShadowHost(element);\\n}\\nfunction previousSiblingInContext(element, context) {\\n  if (element === context.scope)\\n    return;\\n  return element.previousElementSibling || void 0;\\n}\\nfunction sortInDOMOrder(elements) {\\n  const elementToEntry = /* @__PURE__ */ new Map();\\n  const roots = [];\\n  const result = [];\\n  function append(element) {\\n    let entry = elementToEntry.get(element);\\n    if (entry)\\n      return entry;\\n    const parent = parentElementOrShadowHost(element);\\n    if (parent) {\\n      const parentEntry = append(parent);\\n      parentEntry.children.push(element);\\n    } else {\\n      roots.push(element);\\n    }\\n    entry = { children: [], taken: false };\\n    elementToEntry.set(element, entry);\\n    return entry;\\n  }\\n  for (const e of elements)\\n    append(e).taken = true;\\n  function visit(element) {\\n    const entry = elementToEntry.get(element);\\n    if (entry.taken)\\n      result.push(element);\\n    if (entry.children.length > 1) {\\n      const set = new Set(entry.children);\\n      entry.children = [];\\n      let child = element.firstElementChild;\\n      while (child && entry.children.length < set.size) {\\n        if (set.has(child))\\n          entry.children.push(child);\\n        child = child.nextElementSibling;\\n      }\\n      child = element.shadowRoot ? element.shadowRoot.firstElementChild : null;\\n      while (child && entry.children.length < set.size) {\\n        if (set.has(child))\\n          entry.children.push(child);\\n        child = child.nextElementSibling;\\n      }\\n    }\\n    entry.children.forEach(visit);\\n  }\\n  roots.forEach(visit);\\n  return result;\\n}\\n\\n// packages/playwright-injected/src/selectorGenerator.ts\\nvar kTextScoreRange = 10;\\nvar kExactPenalty = kTextScoreRange / 2;\\nvar kTestIdScore = 1;\\nvar kOtherTestIdScore = 2;\\nvar kIframeByAttributeScore = 10;\\nvar kBeginPenalizedScore = 50;\\nvar kRoleWithNameScore = 100;\\nvar kPlaceholderScore = 120;\\nvar kLabelScore = 140;\\nvar kAltTextScore = 160;\\nvar kTextScore = 180;\\nvar kTitleScore = 200;\\nvar kTextScoreRegex = 250;\\nvar kPlaceholderScoreExact = kPlaceholderScore + kExactPenalty;\\nvar kLabelScoreExact = kLabelScore + kExactPenalty;\\nvar kRoleWithNameScoreExact = kRoleWithNameScore + kExactPenalty;\\nvar kAltTextScoreExact = kAltTextScore + kExactPenalty;\\nvar kTextScoreExact = kTextScore + kExactPenalty;\\nvar kTitleScoreExact = kTitleScore + kExactPenalty;\\nvar kEndPenalizedScore = 300;\\nvar kCSSIdScore = 500;\\nvar kRoleWithoutNameScore = 510;\\nvar kCSSInputTypeNameScore = 520;\\nvar kCSSTagNameScore = 530;\\nvar kNthScore = 1e4;\\nvar kCSSFallbackScore = 1e7;\\nvar kScoreThresholdForTextExpect = 1e3;\\nfunction generateSelector(injectedScript, targetElement, options) {\\n  var _a;\\n  injectedScript._evaluator.begin();\\n  const cache = { allowText: /* @__PURE__ */ new Map(), disallowText: /* @__PURE__ */ new Map() };\\n  beginAriaCaches();\\n  beginDOMCaches();\\n  try {\\n    let selectors = [];\\n    if (options.forTextExpect) {\\n      let targetTokens = cssFallback(injectedScript, targetElement.ownerDocument.documentElement, options);\\n      for (let element = targetElement; element; element = parentElementOrShadowHost(element)) {\\n        const tokens = generateSelectorFor(cache, injectedScript, element, { ...options, noText: true });\\n        if (!tokens)\\n          continue;\\n        const score = combineScores(tokens);\\n        if (score <= kScoreThresholdForTextExpect) {\\n          targetTokens = tokens;\\n          break;\\n        }\\n      }\\n      selectors = [joinTokens(targetTokens)];\\n    } else {\\n      if (!targetElement.matches(\\\"input,textarea,select\\\") && !targetElement.isContentEditable) {\\n        const interactiveParent = closestCrossShadow(targetElement, \\\"button,select,input,[role=button],[role=checkbox],[role=radio],a,[role=link]\\\", options.root);\\n        if (interactiveParent && isElementVisible(interactiveParent))\\n          targetElement = interactiveParent;\\n      }\\n      if (options.multiple) {\\n        const withText = generateSelectorFor(cache, injectedScript, targetElement, options);\\n        const withoutText = generateSelectorFor(cache, injectedScript, targetElement, { ...options, noText: true });\\n        let tokens = [withText, withoutText];\\n        cache.allowText.clear();\\n        cache.disallowText.clear();\\n        if (withText && hasCSSIdToken(withText))\\n          tokens.push(generateSelectorFor(cache, injectedScript, targetElement, { ...options, noCSSId: true }));\\n        if (withoutText && hasCSSIdToken(withoutText))\\n          tokens.push(generateSelectorFor(cache, injectedScript, targetElement, { ...options, noText: true, noCSSId: true }));\\n        tokens = tokens.filter(Boolean);\\n        if (!tokens.length) {\\n          const css = cssFallback(injectedScript, targetElement, options);\\n          tokens.push(css);\\n          if (hasCSSIdToken(css))\\n            tokens.push(cssFallback(injectedScript, targetElement, { ...options, noCSSId: true }));\\n        }\\n        selectors = [...new Set(tokens.map((t) => joinTokens(t)))];\\n      } else {\\n        const targetTokens = generateSelectorFor(cache, injectedScript, targetElement, options) || cssFallback(injectedScript, targetElement, options);\\n        selectors = [joinTokens(targetTokens)];\\n      }\\n    }\\n    const selector = selectors[0];\\n    const parsedSelector = injectedScript.parseSelector(selector);\\n    return {\\n      selector,\\n      selectors,\\n      elements: injectedScript.querySelectorAll(parsedSelector, (_a = options.root) != null ? _a : targetElement.ownerDocument)\\n    };\\n  } finally {\\n    endDOMCaches();\\n    endAriaCaches();\\n    injectedScript._evaluator.end();\\n  }\\n}\\nfunction generateSelectorFor(cache, injectedScript, targetElement, options) {\\n  var _a;\\n  if (options.root && !isInsideScope(options.root, targetElement))\\n    throw new Error(`Target element must belong to the root's subtree`);\\n  if (targetElement === options.root)\\n    return [{ engine: \\\"css\\\", selector: \\\":scope\\\", score: 1 }];\\n  if (targetElement.ownerDocument.documentElement === targetElement)\\n    return [{ engine: \\\"css\\\", selector: \\\"html\\\", score: 1 }];\\n  let result = null;\\n  const updateResult = (candidate) => {\\n    if (!result || combineScores(candidate) < combineScores(result))\\n      result = candidate;\\n  };\\n  const candidates = [];\\n  if (!options.noText) {\\n    for (const candidate of buildTextCandidates(injectedScript, targetElement, !options.isRecursive))\\n      candidates.push({ candidate, isTextCandidate: true });\\n  }\\n  for (const token of buildNoTextCandidates(injectedScript, targetElement, options)) {\\n    if (options.omitInternalEngines && token.engine.startsWith(\\\"internal:\\\"))\\n      continue;\\n    candidates.push({ candidate: [token], isTextCandidate: false });\\n  }\\n  candidates.sort((a, b) => combineScores(a.candidate) - combineScores(b.candidate));\\n  for (const { candidate, isTextCandidate } of candidates) {\\n    const elements = injectedScript.querySelectorAll(injectedScript.parseSelector(joinTokens(candidate)), (_a = options.root) != null ? _a : targetElement.ownerDocument);\\n    if (!elements.includes(targetElement)) {\\n      continue;\\n    }\\n    if (elements.length === 1) {\\n      updateResult(candidate);\\n      break;\\n    }\\n    const index = elements.indexOf(targetElement);\\n    if (index > 5) {\\n      continue;\\n    }\\n    updateResult([...candidate, { engine: \\\"nth\\\", selector: String(index), score: kNthScore }]);\\n    if (options.isRecursive) {\\n      continue;\\n    }\\n    for (let parent = parentElementOrShadowHost(targetElement); parent && parent !== options.root; parent = parentElementOrShadowHost(parent)) {\\n      const filtered = elements.filter((e) => isInsideScope(parent, e) && e !== parent);\\n      const newIndex = filtered.indexOf(targetElement);\\n      if (filtered.length > 5 || newIndex === -1 || newIndex === index && filtered.length > 1) {\\n        continue;\\n      }\\n      const inParent = filtered.length === 1 ? candidate : [...candidate, { engine: \\\"nth\\\", selector: String(newIndex), score: kNthScore }];\\n      const idealSelectorForParent = { engine: \\\"\\\", selector: \\\"\\\", score: 1 };\\n      if (result && combineScores([idealSelectorForParent, ...inParent]) >= combineScores(result)) {\\n        continue;\\n      }\\n      const noText = !!options.noText || isTextCandidate;\\n      const cacheMap = noText ? cache.disallowText : cache.allowText;\\n      let parentTokens = cacheMap.get(parent);\\n      if (parentTokens === void 0) {\\n        parentTokens = generateSelectorFor(cache, injectedScript, parent, { ...options, isRecursive: true, noText }) || cssFallback(injectedScript, parent, options);\\n        cacheMap.set(parent, parentTokens);\\n      }\\n      if (!parentTokens)\\n        continue;\\n      updateResult([...parentTokens, ...inParent]);\\n    }\\n  }\\n  return result;\\n}\\nfunction buildNoTextCandidates(injectedScript, element, options) {\\n  const candidates = [];\\n  {\\n    for (const attr of [\\\"data-testid\\\", \\\"data-test-id\\\", \\\"data-test\\\"]) {\\n      if (attr !== options.testIdAttributeName && element.getAttribute(attr))\\n        candidates.push({ engine: \\\"css\\\", selector: `[${attr}=${quoteCSSAttributeValue(element.getAttribute(attr))}]`, score: kOtherTestIdScore });\\n    }\\n    if (!options.noCSSId) {\\n      const idAttr = element.getAttribute(\\\"id\\\");\\n      if (idAttr && !isGuidLike(idAttr))\\n        candidates.push({ engine: \\\"css\\\", selector: makeSelectorForId(idAttr), score: kCSSIdScore });\\n    }\\n    candidates.push({ engine: \\\"css\\\", selector: escapeNodeName(element), score: kCSSTagNameScore });\\n  }\\n  if (element.nodeName === \\\"IFRAME\\\") {\\n    for (const attribute of [\\\"name\\\", \\\"title\\\"]) {\\n      if (element.getAttribute(attribute))\\n        candidates.push({ engine: \\\"css\\\", selector: `${escapeNodeName(element)}[${attribute}=${quoteCSSAttributeValue(element.getAttribute(attribute))}]`, score: kIframeByAttributeScore });\\n    }\\n    if (element.getAttribute(options.testIdAttributeName))\\n      candidates.push({ engine: \\\"css\\\", selector: `[${options.testIdAttributeName}=${quoteCSSAttributeValue(element.getAttribute(options.testIdAttributeName))}]`, score: kTestIdScore });\\n    penalizeScoreForLength([candidates]);\\n    return candidates;\\n  }\\n  if (element.getAttribute(options.testIdAttributeName))\\n    candidates.push({ engine: \\\"internal:testid\\\", selector: `[${options.testIdAttributeName}=${escapeForAttributeSelector(element.getAttribute(options.testIdAttributeName), true)}]`, score: kTestIdScore });\\n  if (element.nodeName === \\\"INPUT\\\" || element.nodeName === \\\"TEXTAREA\\\") {\\n    const input = element;\\n    if (input.placeholder) {\\n      candidates.push({ engine: \\\"internal:attr\\\", selector: `[placeholder=${escapeForAttributeSelector(input.placeholder, true)}]`, score: kPlaceholderScoreExact });\\n      for (const alternative of suitableTextAlternatives(input.placeholder))\\n        candidates.push({ engine: \\\"internal:attr\\\", selector: `[placeholder=${escapeForAttributeSelector(alternative.text, false)}]`, score: kPlaceholderScore - alternative.scoreBonus });\\n    }\\n  }\\n  const labels = getElementLabels(injectedScript._evaluator._cacheText, element);\\n  for (const label of labels) {\\n    const labelText = label.normalized;\\n    candidates.push({ engine: \\\"internal:label\\\", selector: escapeForTextSelector(labelText, true), score: kLabelScoreExact });\\n    for (const alternative of suitableTextAlternatives(labelText))\\n      candidates.push({ engine: \\\"internal:label\\\", selector: escapeForTextSelector(alternative.text, false), score: kLabelScore - alternative.scoreBonus });\\n  }\\n  const ariaRole = getAriaRole(element);\\n  if (ariaRole && ![\\\"none\\\", \\\"presentation\\\"].includes(ariaRole))\\n    candidates.push({ engine: \\\"internal:role\\\", selector: ariaRole, score: kRoleWithoutNameScore });\\n  if (element.getAttribute(\\\"name\\\") && [\\\"BUTTON\\\", \\\"FORM\\\", \\\"FIELDSET\\\", \\\"FRAME\\\", \\\"IFRAME\\\", \\\"INPUT\\\", \\\"KEYGEN\\\", \\\"OBJECT\\\", \\\"OUTPUT\\\", \\\"SELECT\\\", \\\"TEXTAREA\\\", \\\"MAP\\\", \\\"META\\\", \\\"PARAM\\\"].includes(element.nodeName))\\n    candidates.push({ engine: \\\"css\\\", selector: `${escapeNodeName(element)}[name=${quoteCSSAttributeValue(element.getAttribute(\\\"name\\\"))}]`, score: kCSSInputTypeNameScore });\\n  if ([\\\"INPUT\\\", \\\"TEXTAREA\\\"].includes(element.nodeName) && element.getAttribute(\\\"type\\\") !== \\\"hidden\\\") {\\n    if (element.getAttribute(\\\"type\\\"))\\n      candidates.push({ engine: \\\"css\\\", selector: `${escapeNodeName(element)}[type=${quoteCSSAttributeValue(element.getAttribute(\\\"type\\\"))}]`, score: kCSSInputTypeNameScore });\\n  }\\n  if ([\\\"INPUT\\\", \\\"TEXTAREA\\\", \\\"SELECT\\\"].includes(element.nodeName) && element.getAttribute(\\\"type\\\") !== \\\"hidden\\\")\\n    candidates.push({ engine: \\\"css\\\", selector: escapeNodeName(element), score: kCSSInputTypeNameScore + 1 });\\n  penalizeScoreForLength([candidates]);\\n  return candidates;\\n}\\nfunction buildTextCandidates(injectedScript, element, isTargetNode) {\\n  if (element.nodeName === \\\"SELECT\\\")\\n    return [];\\n  const candidates = [];\\n  const title = element.getAttribute(\\\"title\\\");\\n  if (title) {\\n    candidates.push([{ engine: \\\"internal:attr\\\", selector: `[title=${escapeForAttributeSelector(title, true)}]`, score: kTitleScoreExact }]);\\n    for (const alternative of suitableTextAlternatives(title))\\n      candidates.push([{ engine: \\\"internal:attr\\\", selector: `[title=${escapeForAttributeSelector(alternative.text, false)}]`, score: kTitleScore - alternative.scoreBonus }]);\\n  }\\n  const alt = element.getAttribute(\\\"alt\\\");\\n  if (alt && [\\\"APPLET\\\", \\\"AREA\\\", \\\"IMG\\\", \\\"INPUT\\\"].includes(element.nodeName)) {\\n    candidates.push([{ engine: \\\"internal:attr\\\", selector: `[alt=${escapeForAttributeSelector(alt, true)}]`, score: kAltTextScoreExact }]);\\n    for (const alternative of suitableTextAlternatives(alt))\\n      candidates.push([{ engine: \\\"internal:attr\\\", selector: `[alt=${escapeForAttributeSelector(alternative.text, false)}]`, score: kAltTextScore - alternative.scoreBonus }]);\\n  }\\n  const text = elementText(injectedScript._evaluator._cacheText, element).normalized;\\n  const textAlternatives = text ? suitableTextAlternatives(text) : [];\\n  if (text) {\\n    if (isTargetNode) {\\n      if (text.length <= 80)\\n        candidates.push([{ engine: \\\"internal:text\\\", selector: escapeForTextSelector(text, true), score: kTextScoreExact }]);\\n      for (const alternative of textAlternatives)\\n        candidates.push([{ engine: \\\"internal:text\\\", selector: escapeForTextSelector(alternative.text, false), score: kTextScore - alternative.scoreBonus }]);\\n    }\\n    const cssToken = { engine: \\\"css\\\", selector: escapeNodeName(element), score: kCSSTagNameScore };\\n    for (const alternative of textAlternatives)\\n      candidates.push([cssToken, { engine: \\\"internal:has-text\\\", selector: escapeForTextSelector(alternative.text, false), score: kTextScore - alternative.scoreBonus }]);\\n    if (isTargetNode && text.length <= 80) {\\n      const re = new RegExp(\\\"^\\\" + escapeRegExp(text) + \\\"$\\\");\\n      candidates.push([cssToken, { engine: \\\"internal:has-text\\\", selector: escapeForTextSelector(re, false), score: kTextScoreRegex }]);\\n    }\\n  }\\n  const ariaRole = getAriaRole(element);\\n  if (ariaRole && ![\\\"none\\\", \\\"presentation\\\"].includes(ariaRole)) {\\n    const ariaName = getElementAccessibleName(element, false);\\n    if (ariaName && !ariaName.match(/^\\\\p{Co}+$/u)) {\\n      const roleToken = { engine: \\\"internal:role\\\", selector: `${ariaRole}[name=${escapeForAttributeSelector(ariaName, true)}]`, score: kRoleWithNameScoreExact };\\n      candidates.push([roleToken]);\\n      for (const alternative of suitableTextAlternatives(ariaName))\\n        candidates.push([{ engine: \\\"internal:role\\\", selector: `${ariaRole}[name=${escapeForAttributeSelector(alternative.text, false)}]`, score: kRoleWithNameScore - alternative.scoreBonus }]);\\n    } else {\\n      const roleToken = { engine: \\\"internal:role\\\", selector: `${ariaRole}`, score: kRoleWithoutNameScore };\\n      for (const alternative of textAlternatives)\\n        candidates.push([roleToken, { engine: \\\"internal:has-text\\\", selector: escapeForTextSelector(alternative.text, false), score: kTextScore - alternative.scoreBonus }]);\\n      if (isTargetNode && text.length <= 80) {\\n        const re = new RegExp(\\\"^\\\" + escapeRegExp(text) + \\\"$\\\");\\n        candidates.push([roleToken, { engine: \\\"internal:has-text\\\", selector: escapeForTextSelector(re, false), score: kTextScoreRegex }]);\\n      }\\n    }\\n  }\\n  penalizeScoreForLength(candidates);\\n  return candidates;\\n}\\nfunction makeSelectorForId(id) {\\n  return /^[a-zA-Z][a-zA-Z0-9\\\\-\\\\_]+$/.test(id) ? \\\"#\\\" + id : `[id=${quoteCSSAttributeValue(id)}]`;\\n}\\nfunction hasCSSIdToken(tokens) {\\n  return tokens.some((token) => token.engine === \\\"css\\\" && (token.selector.startsWith(\\\"#\\\") || token.selector.startsWith('[id=\\\"')));\\n}\\nfunction cssFallback(injectedScript, targetElement, options) {\\n  var _a;\\n  const root = (_a = options.root) != null ? _a : targetElement.ownerDocument;\\n  const tokens = [];\\n  function uniqueCSSSelector(prefix) {\\n    const path = tokens.slice();\\n    if (prefix)\\n      path.unshift(prefix);\\n    const selector = path.join(\\\" > \\\");\\n    const parsedSelector = injectedScript.parseSelector(selector);\\n    const node = injectedScript.querySelector(parsedSelector, root, false);\\n    return node === targetElement ? selector : void 0;\\n  }\\n  function makeStrict(selector) {\\n    const token = { engine: \\\"css\\\", selector, score: kCSSFallbackScore };\\n    const parsedSelector = injectedScript.parseSelector(selector);\\n    const elements = injectedScript.querySelectorAll(parsedSelector, root);\\n    if (elements.length === 1)\\n      return [token];\\n    const nth = { engine: \\\"nth\\\", selector: String(elements.indexOf(targetElement)), score: kNthScore };\\n    return [token, nth];\\n  }\\n  for (let element = targetElement; element && element !== root; element = parentElementOrShadowHost(element)) {\\n    let bestTokenForLevel = \\\"\\\";\\n    if (element.id && !options.noCSSId) {\\n      const token = makeSelectorForId(element.id);\\n      const selector = uniqueCSSSelector(token);\\n      if (selector)\\n        return makeStrict(selector);\\n      bestTokenForLevel = token;\\n    }\\n    const parent = element.parentNode;\\n    const classes = [...element.classList].map(escapeClassName);\\n    for (let i = 0; i < classes.length; ++i) {\\n      const token = \\\".\\\" + classes.slice(0, i + 1).join(\\\".\\\");\\n      const selector = uniqueCSSSelector(token);\\n      if (selector)\\n        return makeStrict(selector);\\n      if (!bestTokenForLevel && parent) {\\n        const sameClassSiblings = parent.querySelectorAll(token);\\n        if (sameClassSiblings.length === 1)\\n          bestTokenForLevel = token;\\n      }\\n    }\\n    if (parent) {\\n      const siblings = [...parent.children];\\n      const nodeName = element.nodeName;\\n      const sameTagSiblings = siblings.filter((sibling) => sibling.nodeName === nodeName);\\n      const token = sameTagSiblings.indexOf(element) === 0 ? escapeNodeName(element) : `${escapeNodeName(element)}:nth-child(${1 + siblings.indexOf(element)})`;\\n      const selector = uniqueCSSSelector(token);\\n      if (selector)\\n        return makeStrict(selector);\\n      if (!bestTokenForLevel)\\n        bestTokenForLevel = token;\\n    } else if (!bestTokenForLevel) {\\n      bestTokenForLevel = escapeNodeName(element);\\n    }\\n    tokens.unshift(bestTokenForLevel);\\n  }\\n  return makeStrict(uniqueCSSSelector());\\n}\\nfunction penalizeScoreForLength(groups) {\\n  for (const group of groups) {\\n    for (const token of group) {\\n      if (token.score > kBeginPenalizedScore && token.score < kEndPenalizedScore)\\n        token.score += Math.min(kTextScoreRange, token.selector.length / 10 | 0);\\n    }\\n  }\\n}\\nfunction joinTokens(tokens) {\\n  const parts = [];\\n  let lastEngine = \\\"\\\";\\n  for (const { engine, selector } of tokens) {\\n    if (parts.length && (lastEngine !== \\\"css\\\" || engine !== \\\"css\\\" || selector.startsWith(\\\":nth-match(\\\")))\\n      parts.push(\\\">>\\\");\\n    lastEngine = engine;\\n    if (engine === \\\"css\\\")\\n      parts.push(selector);\\n    else\\n      parts.push(`${engine}=${selector}`);\\n  }\\n  return parts.join(\\\" \\\");\\n}\\nfunction combineScores(tokens) {\\n  let score = 0;\\n  for (let i = 0; i < tokens.length; i++)\\n    score += tokens[i].score * (tokens.length - i);\\n  return score;\\n}\\nfunction isGuidLike(id) {\\n  let lastCharacterType;\\n  let transitionCount = 0;\\n  for (let i = 0; i < id.length; ++i) {\\n    const c = id[i];\\n    let characterType;\\n    if (c === \\\"-\\\" || c === \\\"_\\\")\\n      continue;\\n    if (c >= \\\"a\\\" && c <= \\\"z\\\")\\n      characterType = \\\"lower\\\";\\n    else if (c >= \\\"A\\\" && c <= \\\"Z\\\")\\n      characterType = \\\"upper\\\";\\n    else if (c >= \\\"0\\\" && c <= \\\"9\\\")\\n      characterType = \\\"digit\\\";\\n    else\\n      characterType = \\\"other\\\";\\n    if (characterType === \\\"lower\\\" && lastCharacterType === \\\"upper\\\") {\\n      lastCharacterType = characterType;\\n      continue;\\n    }\\n    if (lastCharacterType && lastCharacterType !== characterType)\\n      ++transitionCount;\\n    lastCharacterType = characterType;\\n  }\\n  return transitionCount >= id.length / 4;\\n}\\nfunction trimWordBoundary(text, maxLength) {\\n  if (text.length <= maxLength)\\n    return text;\\n  text = text.substring(0, maxLength);\\n  const match = text.match(/^(.*)\\\\b(.+?)$/);\\n  if (!match)\\n    return \\\"\\\";\\n  return match[1].trimEnd();\\n}\\nfunction suitableTextAlternatives(text) {\\n  let result = [];\\n  {\\n    const match = text.match(/^([\\\\d.,]+)[^.,\\\\w]/);\\n    const leadingNumberLength = match ? match[1].length : 0;\\n    if (leadingNumberLength) {\\n      const alt = trimWordBoundary(text.substring(leadingNumberLength).trimStart(), 80);\\n      result.push({ text: alt, scoreBonus: alt.length <= 30 ? 2 : 1 });\\n    }\\n  }\\n  {\\n    const match = text.match(/[^.,\\\\w]([\\\\d.,]+)$/);\\n    const trailingNumberLength = match ? match[1].length : 0;\\n    if (trailingNumberLength) {\\n      const alt = trimWordBoundary(text.substring(0, text.length - trailingNumberLength).trimEnd(), 80);\\n      result.push({ text: alt, scoreBonus: alt.length <= 30 ? 2 : 1 });\\n    }\\n  }\\n  if (text.length <= 30) {\\n    result.push({ text, scoreBonus: 0 });\\n  } else {\\n    result.push({ text: trimWordBoundary(text, 80), scoreBonus: 0 });\\n    result.push({ text: trimWordBoundary(text, 30), scoreBonus: 1 });\\n  }\\n  result = result.filter((r) => r.text);\\n  if (!result.length)\\n    result.push({ text: text.substring(0, 80), scoreBonus: 0 });\\n  return result;\\n}\\nfunction escapeNodeName(node) {\\n  return node.nodeName.toLocaleLowerCase().replace(/[:\\\\.]/g, (char) => \\\"\\\\\\\\\\\" + char);\\n}\\nfunction escapeClassName(className) {\\n  let result = \\\"\\\";\\n  for (let i = 0; i < className.length; i++)\\n    result += cssEscapeCharacter(className, i);\\n  return result;\\n}\\nfunction cssEscapeCharacter(s, i) {\\n  const c = s.charCodeAt(i);\\n  if (c === 0)\\n    return \\\"\\\\uFFFD\\\";\\n  if (c >= 1 && c <= 31 || c >= 48 && c <= 57 && (i === 0 || i === 1 && s.charCodeAt(0) === 45))\\n    return \\\"\\\\\\\\\\\" + c.toString(16) + \\\" \\\";\\n  if (i === 0 && c === 45 && s.length === 1)\\n    return \\\"\\\\\\\\\\\" + s.charAt(i);\\n  if (c >= 128 || c === 45 || c === 95 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122)\\n    return s.charAt(i);\\n  return \\\"\\\\\\\\\\\" + s.charAt(i);\\n}\\n\\n// packages/playwright-injected/src/vueSelectorEngine.ts\\nfunction basename(filename, ext) {\\n  const normalized = filename.replace(/^[a-zA-Z]:/, \\\"\\\").replace(/\\\\\\\\/g, \\\"/\\\");\\n  let result = normalized.substring(normalized.lastIndexOf(\\\"/\\\") + 1);\\n  if (ext && result.endsWith(ext))\\n    result = result.substring(0, result.length - ext.length);\\n  return result;\\n}\\nfunction toUpper(_, c) {\\n  return c ? c.toUpperCase() : \\\"\\\";\\n}\\nvar classifyRE = /(?:^|[-_/])(\\\\w)/g;\\nvar classify = (str) => {\\n  return str && str.replace(classifyRE, toUpper);\\n};\\nfunction buildComponentsTreeVue3(instance) {\\n  function getComponentTypeName(options) {\\n    const name = options.name || options._componentTag || options.__playwright_guessedName;\\n    if (name)\\n      return name;\\n    const file = options.__file;\\n    if (file)\\n      return classify(basename(file, \\\".vue\\\"));\\n  }\\n  function saveComponentName(instance2, key) {\\n    instance2.type.__playwright_guessedName = key;\\n    return key;\\n  }\\n  function getInstanceName(instance2) {\\n    var _a, _b, _c, _d;\\n    const name = getComponentTypeName(instance2.type || {});\\n    if (name)\\n      return name;\\n    if (instance2.root === instance2)\\n      return \\\"Root\\\";\\n    for (const key in (_b = (_a = instance2.parent) == null ? void 0 : _a.type) == null ? void 0 : _b.components) {\\n      if (((_c = instance2.parent) == null ? void 0 : _c.type.components[key]) === instance2.type)\\n        return saveComponentName(instance2, key);\\n    }\\n    for (const key in (_d = instance2.appContext) == null ? void 0 : _d.components) {\\n      if (instance2.appContext.components[key] === instance2.type)\\n        return saveComponentName(instance2, key);\\n    }\\n    return \\\"Anonymous Component\\\";\\n  }\\n  function isBeingDestroyed(instance2) {\\n    return instance2._isBeingDestroyed || instance2.isUnmounted;\\n  }\\n  function isFragment(instance2) {\\n    return instance2.subTree.type.toString() === \\\"Symbol(Fragment)\\\";\\n  }\\n  function getInternalInstanceChildren(subTree) {\\n    const list = [];\\n    if (subTree.component)\\n      list.push(subTree.component);\\n    if (subTree.suspense)\\n      list.push(...getInternalInstanceChildren(subTree.suspense.activeBranch));\\n    if (Array.isArray(subTree.children)) {\\n      subTree.children.forEach((childSubTree) => {\\n        if (childSubTree.component)\\n          list.push(childSubTree.component);\\n        else\\n          list.push(...getInternalInstanceChildren(childSubTree));\\n      });\\n    }\\n    return list.filter((child) => {\\n      var _a;\\n      return !isBeingDestroyed(child) && !((_a = child.type.devtools) == null ? void 0 : _a.hide);\\n    });\\n  }\\n  function getRootElementsFromComponentInstance(instance2) {\\n    if (isFragment(instance2))\\n      return getFragmentRootElements(instance2.subTree);\\n    return [instance2.subTree.el];\\n  }\\n  function getFragmentRootElements(vnode) {\\n    if (!vnode.children)\\n      return [];\\n    const list = [];\\n    for (let i = 0, l = vnode.children.length; i < l; i++) {\\n      const childVnode = vnode.children[i];\\n      if (childVnode.component)\\n        list.push(...getRootElementsFromComponentInstance(childVnode.component));\\n      else if (childVnode.el)\\n        list.push(childVnode.el);\\n    }\\n    return list;\\n  }\\n  function buildComponentsTree2(instance2) {\\n    return {\\n      name: getInstanceName(instance2),\\n      children: getInternalInstanceChildren(instance2.subTree).map(buildComponentsTree2),\\n      rootElements: getRootElementsFromComponentInstance(instance2),\\n      props: instance2.props\\n    };\\n  }\\n  return buildComponentsTree2(instance);\\n}\\nfunction buildComponentsTreeVue2(instance) {\\n  function getComponentName2(options) {\\n    const name = options.displayName || options.name || options._componentTag;\\n    if (name)\\n      return name;\\n    const file = options.__file;\\n    if (file)\\n      return classify(basename(file, \\\".vue\\\"));\\n  }\\n  function getInstanceName(instance2) {\\n    const name = getComponentName2(instance2.$options || instance2.fnOptions || {});\\n    if (name)\\n      return name;\\n    return instance2.$root === instance2 ? \\\"Root\\\" : \\\"Anonymous Component\\\";\\n  }\\n  function getInternalInstanceChildren(instance2) {\\n    if (instance2.$children)\\n      return instance2.$children;\\n    if (Array.isArray(instance2.subTree.children))\\n      return instance2.subTree.children.filter((vnode) => !!vnode.component).map((vnode) => vnode.component);\\n    return [];\\n  }\\n  function buildComponentsTree2(instance2) {\\n    return {\\n      name: getInstanceName(instance2),\\n      children: getInternalInstanceChildren(instance2).map(buildComponentsTree2),\\n      rootElements: [instance2.$el],\\n      props: instance2._props\\n    };\\n  }\\n  return buildComponentsTree2(instance);\\n}\\nfunction filterComponentsTree2(treeNode, searchFn, result = []) {\\n  if (searchFn(treeNode))\\n    result.push(treeNode);\\n  for (const child of treeNode.children)\\n    filterComponentsTree2(child, searchFn, result);\\n  return result;\\n}\\nfunction findVueRoots(root, roots = []) {\\n  const document = root.ownerDocument || root;\\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\\n  const vue2Roots = /* @__PURE__ */ new Set();\\n  do {\\n    const node = walker.currentNode;\\n    if (node.__vue__)\\n      vue2Roots.add(node.__vue__.$root);\\n    if (node.__vue_app__ && node._vnode && node._vnode.component)\\n      roots.push({ root: node._vnode.component, version: 3 });\\n    const shadowRoot = node instanceof Element ? node.shadowRoot : null;\\n    if (shadowRoot)\\n      findVueRoots(shadowRoot, roots);\\n  } while (walker.nextNode());\\n  for (const vue2root of vue2Roots) {\\n    roots.push({\\n      version: 2,\\n      root: vue2root\\n    });\\n  }\\n  return roots;\\n}\\nvar createVueEngine = () => ({\\n  queryAll(scope, selector) {\\n    const document = scope.ownerDocument || scope;\\n    const { name, attributes } = parseAttributeSelector(selector, false);\\n    const vueRoots = findVueRoots(document);\\n    const trees = vueRoots.map((vueRoot) => vueRoot.version === 3 ? buildComponentsTreeVue3(vueRoot.root) : buildComponentsTreeVue2(vueRoot.root));\\n    const treeNodes = trees.map((tree) => filterComponentsTree2(tree, (treeNode) => {\\n      if (name && treeNode.name !== name)\\n        return false;\\n      if (treeNode.rootElements.some((rootElement) => !isInsideScope(scope, rootElement)))\\n        return false;\\n      for (const attr of attributes) {\\n        if (!matchesComponentAttribute(treeNode.props, attr))\\n          return false;\\n      }\\n      return true;\\n    })).flat();\\n    const allRootElements = /* @__PURE__ */ new Set();\\n    for (const treeNode of treeNodes) {\\n      for (const rootElement of treeNode.rootElements)\\n        allRootElements.add(rootElement);\\n    }\\n    return [...allRootElements];\\n  }\\n});\\n\\n// packages/playwright-injected/src/xpathSelectorEngine.ts\\nvar XPathEngine = {\\n  queryAll(root, selector) {\\n    if (selector.startsWith(\\\"/\\\") && root.nodeType !== Node.DOCUMENT_NODE)\\n      selector = \\\".\\\" + selector;\\n    const result = [];\\n    const document = root.ownerDocument || root;\\n    if (!document)\\n      return result;\\n    const it = document.evaluate(selector, root, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE);\\n    for (let node = it.iterateNext(); node; node = it.iterateNext()) {\\n      if (node.nodeType === Node.ELEMENT_NODE)\\n        result.push(node);\\n    }\\n    return result;\\n  }\\n};\\n\\n// packages/playwright-core/src/utils/isomorphic/locatorUtils.ts\\nfunction getByAttributeTextSelector(attrName, text, options) {\\n  return `internal:attr=[${attrName}=${escapeForAttributeSelector(text, (options == null ? void 0 : options.exact) || false)}]`;\\n}\\nfunction getByTestIdSelector(testIdAttributeName, testId) {\\n  return `internal:testid=[${testIdAttributeName}=${escapeForAttributeSelector(testId, true)}]`;\\n}\\nfunction getByLabelSelector(text, options) {\\n  return \\\"internal:label=\\\" + escapeForTextSelector(text, !!(options == null ? void 0 : options.exact));\\n}\\nfunction getByAltTextSelector(text, options) {\\n  return getByAttributeTextSelector(\\\"alt\\\", text, options);\\n}\\nfunction getByTitleSelector(text, options) {\\n  return getByAttributeTextSelector(\\\"title\\\", text, options);\\n}\\nfunction getByPlaceholderSelector(text, options) {\\n  return getByAttributeTextSelector(\\\"placeholder\\\", text, options);\\n}\\nfunction getByTextSelector(text, options) {\\n  return \\\"internal:text=\\\" + escapeForTextSelector(text, !!(options == null ? void 0 : options.exact));\\n}\\nfunction getByRoleSelector(role, options = {}) {\\n  const props = [];\\n  if (options.checked !== void 0)\\n    props.push([\\\"checked\\\", String(options.checked)]);\\n  if (options.disabled !== void 0)\\n    props.push([\\\"disabled\\\", String(options.disabled)]);\\n  if (options.selected !== void 0)\\n    props.push([\\\"selected\\\", String(options.selected)]);\\n  if (options.expanded !== void 0)\\n    props.push([\\\"expanded\\\", String(options.expanded)]);\\n  if (options.includeHidden !== void 0)\\n    props.push([\\\"include-hidden\\\", String(options.includeHidden)]);\\n  if (options.level !== void 0)\\n    props.push([\\\"level\\\", String(options.level)]);\\n  if (options.name !== void 0)\\n    props.push([\\\"name\\\", escapeForAttributeSelector(options.name, !!options.exact)]);\\n  if (options.pressed !== void 0)\\n    props.push([\\\"pressed\\\", String(options.pressed)]);\\n  return `internal:role=${role}${props.map(([n, v]) => `[${n}=${v}]`).join(\\\"\\\")}`;\\n}\\n\\n// packages/playwright-injected/src/consoleApi.ts\\nvar selectorSymbol = /* @__PURE__ */ Symbol(\\\"selector\\\");\\nselectorSymbol;\\nvar _Locator = class _Locator {\\n  constructor(injectedScript, selector, options) {\\n    if (options == null ? void 0 : options.hasText)\\n      selector += ` >> internal:has-text=${escapeForTextSelector(options.hasText, false)}`;\\n    if (options == null ? void 0 : options.hasNotText)\\n      selector += ` >> internal:has-not-text=${escapeForTextSelector(options.hasNotText, false)}`;\\n    if (options == null ? void 0 : options.has)\\n      selector += ` >> internal:has=` + JSON.stringify(options.has[selectorSymbol]);\\n    if (options == null ? void 0 : options.hasNot)\\n      selector += ` >> internal:has-not=` + JSON.stringify(options.hasNot[selectorSymbol]);\\n    if ((options == null ? void 0 : options.visible) !== void 0)\\n      selector += ` >> visible=${options.visible ? \\\"true\\\" : \\\"false\\\"}`;\\n    this[selectorSymbol] = selector;\\n    if (selector) {\\n      const parsed = injectedScript.parseSelector(selector);\\n      this.element = injectedScript.querySelector(parsed, injectedScript.document, false);\\n      this.elements = injectedScript.querySelectorAll(parsed, injectedScript.document);\\n    }\\n    const selectorBase = selector;\\n    const self = this;\\n    self.locator = (selector2, options2) => {\\n      return new _Locator(injectedScript, selectorBase ? selectorBase + \\\" >> \\\" + selector2 : selector2, options2);\\n    };\\n    self.getByTestId = (testId) => self.locator(getByTestIdSelector(injectedScript.testIdAttributeNameForStrictErrorAndConsoleCodegen(), testId));\\n    self.getByAltText = (text, options2) => self.locator(getByAltTextSelector(text, options2));\\n    self.getByLabel = (text, options2) => self.locator(getByLabelSelector(text, options2));\\n    self.getByPlaceholder = (text, options2) => self.locator(getByPlaceholderSelector(text, options2));\\n    self.getByText = (text, options2) => self.locator(getByTextSelector(text, options2));\\n    self.getByTitle = (text, options2) => self.locator(getByTitleSelector(text, options2));\\n    self.getByRole = (role, options2 = {}) => self.locator(getByRoleSelector(role, options2));\\n    self.filter = (options2) => new _Locator(injectedScript, selector, options2);\\n    self.first = () => self.locator(\\\"nth=0\\\");\\n    self.last = () => self.locator(\\\"nth=-1\\\");\\n    self.nth = (index) => self.locator(`nth=${index}`);\\n    self.and = (locator) => new _Locator(injectedScript, selectorBase + ` >> internal:and=` + JSON.stringify(locator[selectorSymbol]));\\n    self.or = (locator) => new _Locator(injectedScript, selectorBase + ` >> internal:or=` + JSON.stringify(locator[selectorSymbol]));\\n  }\\n};\\nvar Locator = _Locator;\\nvar ConsoleAPI = class {\\n  constructor(injectedScript) {\\n    this._injectedScript = injectedScript;\\n  }\\n  install() {\\n    if (this._injectedScript.window.playwright)\\n      return;\\n    this._injectedScript.window.playwright = {\\n      $: (selector, strict) => this._querySelector(selector, !!strict),\\n      $$: (selector) => this._querySelectorAll(selector),\\n      inspect: (selector) => this._inspect(selector),\\n      selector: (element) => this._selector(element),\\n      generateLocator: (element, language) => this._generateLocator(element, language),\\n      ariaSnapshot: (element, options) => {\\n        return this._injectedScript.ariaSnapshot(element || this._injectedScript.document.body, options || { mode: \\\"expect\\\" });\\n      },\\n      resume: () => this._resume(),\\n      ...new Locator(this._injectedScript, \\\"\\\")\\n    };\\n    delete this._injectedScript.window.playwright.filter;\\n    delete this._injectedScript.window.playwright.first;\\n    delete this._injectedScript.window.playwright.last;\\n    delete this._injectedScript.window.playwright.nth;\\n    delete this._injectedScript.window.playwright.and;\\n    delete this._injectedScript.window.playwright.or;\\n  }\\n  _querySelector(selector, strict) {\\n    if (typeof selector !== \\\"string\\\")\\n      throw new Error(`Usage: playwright.query('Playwright >> selector').`);\\n    const parsed = this._injectedScript.parseSelector(selector);\\n    return this._injectedScript.querySelector(parsed, this._injectedScript.document, strict);\\n  }\\n  _querySelectorAll(selector) {\\n    if (typeof selector !== \\\"string\\\")\\n      throw new Error(`Usage: playwright.$$('Playwright >> selector').`);\\n    const parsed = this._injectedScript.parseSelector(selector);\\n    return this._injectedScript.querySelectorAll(parsed, this._injectedScript.document);\\n  }\\n  _inspect(selector) {\\n    if (typeof selector !== \\\"string\\\")\\n      throw new Error(`Usage: playwright.inspect('Playwright >> selector').`);\\n    this._injectedScript.window.inspect(this._querySelector(selector, false));\\n  }\\n  _selector(element) {\\n    if (!(element instanceof Element))\\n      throw new Error(`Usage: playwright.selector(element).`);\\n    return this._injectedScript.generateSelectorSimple(element);\\n  }\\n  _generateLocator(element, language) {\\n    if (!(element instanceof Element))\\n      throw new Error(`Usage: playwright.locator(element).`);\\n    const selector = this._injectedScript.generateSelectorSimple(element);\\n    return asLocator(language || \\\"javascript\\\", selector);\\n  }\\n  _resume() {\\n    if (!this._injectedScript.window.__pw_resume)\\n      return false;\\n    this._injectedScript.window.__pw_resume().catch(() => {\\n    });\\n  }\\n};\\n\\n// packages/playwright-core/src/utils/isomorphic/utilityScriptSerializers.ts\\nfunction isRegExp2(obj) {\\n  try {\\n    return obj instanceof RegExp || Object.prototype.toString.call(obj) === \\\"[object RegExp]\\\";\\n  } catch (error) {\\n    return false;\\n  }\\n}\\nfunction isDate(obj) {\\n  try {\\n    return obj instanceof Date || Object.prototype.toString.call(obj) === \\\"[object Date]\\\";\\n  } catch (error) {\\n    return false;\\n  }\\n}\\nfunction isURL(obj) {\\n  try {\\n    return obj instanceof URL || Object.prototype.toString.call(obj) === \\\"[object URL]\\\";\\n  } catch (error) {\\n    return false;\\n  }\\n}\\nfunction isError(obj) {\\n  var _a;\\n  try {\\n    return obj instanceof Error || obj && ((_a = Object.getPrototypeOf(obj)) == null ? void 0 : _a.name) === \\\"Error\\\";\\n  } catch (error) {\\n    return false;\\n  }\\n}\\nfunction isTypedArray(obj, constructor) {\\n  try {\\n    return obj instanceof constructor || Object.prototype.toString.call(obj) === `[object ${constructor.name}]`;\\n  } catch (error) {\\n    return false;\\n  }\\n}\\nvar typedArrayConstructors = {\\n  i8: Int8Array,\\n  ui8: Uint8Array,\\n  ui8c: Uint8ClampedArray,\\n  i16: Int16Array,\\n  ui16: Uint16Array,\\n  i32: Int32Array,\\n  ui32: Uint32Array,\\n  // TODO: add Float16Array once it's in baseline\\n  f32: Float32Array,\\n  f64: Float64Array,\\n  bi64: BigInt64Array,\\n  bui64: BigUint64Array\\n};\\nfunction typedArrayToBase64(array) {\\n  if (\\\"toBase64\\\" in array)\\n    return array.toBase64();\\n  const binary = Array.from(new Uint8Array(array.buffer, array.byteOffset, array.byteLength)).map((b) => String.fromCharCode(b)).join(\\\"\\\");\\n  return btoa(binary);\\n}\\nfunction base64ToTypedArray(base64, TypedArrayConstructor) {\\n  const binary = atob(base64);\\n  const bytes = new Uint8Array(binary.length);\\n  for (let i = 0; i < binary.length; i++)\\n    bytes[i] = binary.charCodeAt(i);\\n  return new TypedArrayConstructor(bytes.buffer);\\n}\\nfunction parseEvaluationResultValue(value, handles = [], refs = /* @__PURE__ */ new Map()) {\\n  if (Object.is(value, void 0))\\n    return void 0;\\n  if (typeof value === \\\"object\\\" && value) {\\n    if (\\\"ref\\\" in value)\\n      return refs.get(value.ref);\\n    if (\\\"v\\\" in value) {\\n      if (value.v === \\\"undefined\\\")\\n        return void 0;\\n      if (value.v === \\\"null\\\")\\n        return null;\\n      if (value.v === \\\"NaN\\\")\\n        return NaN;\\n      if (value.v === \\\"Infinity\\\")\\n        return Infinity;\\n      if (value.v === \\\"-Infinity\\\")\\n        return -Infinity;\\n      if (value.v === \\\"-0\\\")\\n        return -0;\\n      return void 0;\\n    }\\n    if (\\\"d\\\" in value) {\\n      return new Date(value.d);\\n    }\\n    if (\\\"u\\\" in value)\\n      return new URL(value.u);\\n    if (\\\"bi\\\" in value)\\n      return BigInt(value.bi);\\n    if (\\\"e\\\" in value) {\\n      const error = new Error(value.e.m);\\n      error.name = value.e.n;\\n      error.stack = value.e.s;\\n      return error;\\n    }\\n    if (\\\"r\\\" in value)\\n      return new RegExp(value.r.p, value.r.f);\\n    if (\\\"a\\\" in value) {\\n      const result = [];\\n      refs.set(value.id, result);\\n      for (const a of value.a)\\n        result.push(parseEvaluationResultValue(a, handles, refs));\\n      return result;\\n    }\\n    if (\\\"o\\\" in value) {\\n      const result = {};\\n      refs.set(value.id, result);\\n      for (const { k, v } of value.o) {\\n        if (k === \\\"__proto__\\\")\\n          continue;\\n        result[k] = parseEvaluationResultValue(v, handles, refs);\\n      }\\n      return result;\\n    }\\n    if (\\\"h\\\" in value)\\n      return handles[value.h];\\n    if (\\\"ta\\\" in value)\\n      return base64ToTypedArray(value.ta.b, typedArrayConstructors[value.ta.k]);\\n  }\\n  return value;\\n}\\nfunction serializeAsCallArgument(value, handleSerializer) {\\n  return serialize(value, handleSerializer, { visited: /* @__PURE__ */ new Map(), lastId: 0 });\\n}\\nfunction serialize(value, handleSerializer, visitorInfo) {\\n  if (value && typeof value === \\\"object\\\") {\\n    if (typeof globalThis.Window === \\\"function\\\" && value instanceof globalThis.Window)\\n      return \\\"ref: <Window>\\\";\\n    if (typeof globalThis.Document === \\\"function\\\" && value instanceof globalThis.Document)\\n      return \\\"ref: <Document>\\\";\\n    if (typeof globalThis.Node === \\\"function\\\" && value instanceof globalThis.Node)\\n      return \\\"ref: <Node>\\\";\\n  }\\n  return innerSerialize(value, handleSerializer, visitorInfo);\\n}\\nfunction innerSerialize(value, handleSerializer, visitorInfo) {\\n  var _a;\\n  const result = handleSerializer(value);\\n  if (\\\"fallThrough\\\" in result)\\n    value = result.fallThrough;\\n  else\\n    return result;\\n  if (typeof value === \\\"symbol\\\")\\n    return { v: \\\"undefined\\\" };\\n  if (Object.is(value, void 0))\\n    return { v: \\\"undefined\\\" };\\n  if (Object.is(value, null))\\n    return { v: \\\"null\\\" };\\n  if (Object.is(value, NaN))\\n    return { v: \\\"NaN\\\" };\\n  if (Object.is(value, Infinity))\\n    return { v: \\\"Infinity\\\" };\\n  if (Object.is(value, -Infinity))\\n    return { v: \\\"-Infinity\\\" };\\n  if (Object.is(value, -0))\\n    return { v: \\\"-0\\\" };\\n  if (typeof value === \\\"boolean\\\")\\n    return value;\\n  if (typeof value === \\\"number\\\")\\n    return value;\\n  if (typeof value === \\\"string\\\")\\n    return value;\\n  if (typeof value === \\\"bigint\\\")\\n    return { bi: value.toString() };\\n  if (isError(value)) {\\n    let stack;\\n    if ((_a = value.stack) == null ? void 0 : _a.startsWith(value.name + \\\": \\\" + value.message)) {\\n      stack = value.stack;\\n    } else {\\n      stack = `${value.name}: ${value.message}\\n${value.stack}`;\\n    }\\n    return { e: { n: value.name, m: value.message, s: stack } };\\n  }\\n  if (isDate(value))\\n    return { d: value.toJSON() };\\n  if (isURL(value))\\n    return { u: value.toJSON() };\\n  if (isRegExp2(value))\\n    return { r: { p: value.source, f: value.flags } };\\n  for (const [k, ctor] of Object.entries(typedArrayConstructors)) {\\n    if (isTypedArray(value, ctor))\\n      return { ta: { b: typedArrayToBase64(value), k } };\\n  }\\n  const id = visitorInfo.visited.get(value);\\n  if (id)\\n    return { ref: id };\\n  if (Array.isArray(value)) {\\n    const a = [];\\n    const id2 = ++visitorInfo.lastId;\\n    visitorInfo.visited.set(value, id2);\\n    for (let i = 0; i < value.length; ++i)\\n      a.push(serialize(value[i], handleSerializer, visitorInfo));\\n    return { a, id: id2 };\\n  }\\n  if (typeof value === \\\"object\\\") {\\n    const o = [];\\n    const id2 = ++visitorInfo.lastId;\\n    visitorInfo.visited.set(value, id2);\\n    for (const name of Object.keys(value)) {\\n      let item;\\n      try {\\n        item = value[name];\\n      } catch (e) {\\n        continue;\\n      }\\n      if (name === \\\"toJSON\\\" && typeof item === \\\"function\\\")\\n        o.push({ k: name, v: { o: [], id: 0 } });\\n      else\\n        o.push({ k: name, v: serialize(item, handleSerializer, visitorInfo) });\\n    }\\n    let jsonWrapper;\\n    try {\\n      if (o.length === 0 && value.toJSON && typeof value.toJSON === \\\"function\\\")\\n        jsonWrapper = { value: value.toJSON() };\\n    } catch (e) {\\n    }\\n    if (jsonWrapper)\\n      return innerSerialize(jsonWrapper.value, handleSerializer, visitorInfo);\\n    return { o, id: id2 };\\n  }\\n}\\n\\n// packages/playwright-injected/src/utilityScript.ts\\nvar UtilityScript = class {\\n  constructor(global, isUnderTest) {\\n    var _a, _b, _c, _d, _e, _f, _g, _h;\\n    this.global = global;\\n    this.isUnderTest = isUnderTest;\\n    if (global.__pwClock) {\\n      this.builtins = global.__pwClock.builtins;\\n    } else {\\n      this.builtins = {\\n        setTimeout: (_a = global.setTimeout) == null ? void 0 : _a.bind(global),\\n        clearTimeout: (_b = global.clearTimeout) == null ? void 0 : _b.bind(global),\\n        setInterval: (_c = global.setInterval) == null ? void 0 : _c.bind(global),\\n        clearInterval: (_d = global.clearInterval) == null ? void 0 : _d.bind(global),\\n        requestAnimationFrame: (_e = global.requestAnimationFrame) == null ? void 0 : _e.bind(global),\\n        cancelAnimationFrame: (_f = global.cancelAnimationFrame) == null ? void 0 : _f.bind(global),\\n        requestIdleCallback: (_g = global.requestIdleCallback) == null ? void 0 : _g.bind(global),\\n        cancelIdleCallback: (_h = global.cancelIdleCallback) == null ? void 0 : _h.bind(global),\\n        performance: global.performance,\\n        Intl: global.Intl,\\n        Date: global.Date\\n      };\\n    }\\n    if (this.isUnderTest)\\n      global.builtins = this.builtins;\\n  }\\n  evaluate(isFunction, returnByValue, expression, argCount, ...argsAndHandles) {\\n    const args = argsAndHandles.slice(0, argCount);\\n    const handles = argsAndHandles.slice(argCount);\\n    const parameters = [];\\n    for (let i = 0; i < args.length; i++)\\n      parameters[i] = parseEvaluationResultValue(args[i], handles);\\n    let result = this.global.eval(expression);\\n    if (isFunction === true) {\\n      result = result(...parameters);\\n    } else if (isFunction === false) {\\n      result = result;\\n    } else {\\n      if (typeof result === \\\"function\\\")\\n        result = result(...parameters);\\n    }\\n    return returnByValue ? this._promiseAwareJsonValueNoThrow(result) : result;\\n  }\\n  jsonValue(returnByValue, value) {\\n    if (value === void 0)\\n      return void 0;\\n    return serializeAsCallArgument(value, (value2) => ({ fallThrough: value2 }));\\n  }\\n  _promiseAwareJsonValueNoThrow(value) {\\n    const safeJson = (value2) => {\\n      try {\\n        return this.jsonValue(true, value2);\\n      } catch (e) {\\n        return void 0;\\n      }\\n    };\\n    if (value && typeof value === \\\"object\\\" && typeof value.then === \\\"function\\\") {\\n      return (async () => {\\n        const promiseValue = await value;\\n        return safeJson(promiseValue);\\n      })();\\n    }\\n    return safeJson(value);\\n  }\\n};\\n\\n// packages/playwright-injected/src/injectedScript.ts\\nvar InjectedScript = class {\\n  constructor(window, options) {\\n    this._testIdAttributeNameForStrictErrorAndConsoleCodegen = \\\"data-testid\\\";\\n    this._lastAriaSnapshotForTrack = /* @__PURE__ */ new Map();\\n    // Recorder must use any external dependencies through InjectedScript.\\n    // Otherwise it will end up with a copy of all modules it uses, and any\\n    // module-level globals will be duplicated, which leads to subtle bugs.\\n    this.utils = {\\n      asLocator,\\n      cacheNormalizedWhitespaces,\\n      elementText,\\n      getAriaRole,\\n      getElementAccessibleDescription,\\n      getElementAccessibleName,\\n      isElementVisible,\\n      isInsideScope,\\n      normalizeWhiteSpace,\\n      parseAriaSnapshot,\\n      generateAriaTree,\\n      // Builtins protect injected code from clock emulation.\\n      builtins: null\\n    };\\n    this.window = window;\\n    this.document = window.document;\\n    this.isUnderTest = options.isUnderTest;\\n    this.utils.builtins = new UtilityScript(window, options.isUnderTest).builtins;\\n    this._sdkLanguage = options.sdkLanguage;\\n    this._testIdAttributeNameForStrictErrorAndConsoleCodegen = options.testIdAttributeName;\\n    this._evaluator = new SelectorEvaluatorImpl();\\n    this.consoleApi = new ConsoleAPI(this);\\n    this.onGlobalListenersRemoved = /* @__PURE__ */ new Set();\\n    this._autoClosingTags = /* @__PURE__ */ new Set([\\\"AREA\\\", \\\"BASE\\\", \\\"BR\\\", \\\"COL\\\", \\\"COMMAND\\\", \\\"EMBED\\\", \\\"HR\\\", \\\"IMG\\\", \\\"INPUT\\\", \\\"KEYGEN\\\", \\\"LINK\\\", \\\"MENUITEM\\\", \\\"META\\\", \\\"PARAM\\\", \\\"SOURCE\\\", \\\"TRACK\\\", \\\"WBR\\\"]);\\n    this._booleanAttributes = /* @__PURE__ */ new Set([\\\"checked\\\", \\\"selected\\\", \\\"disabled\\\", \\\"readonly\\\", \\\"multiple\\\"]);\\n    this._eventTypes = /* @__PURE__ */ new Map([\\n      [\\\"auxclick\\\", \\\"mouse\\\"],\\n      [\\\"click\\\", \\\"mouse\\\"],\\n      [\\\"dblclick\\\", \\\"mouse\\\"],\\n      [\\\"mousedown\\\", \\\"mouse\\\"],\\n      [\\\"mouseeenter\\\", \\\"mouse\\\"],\\n      [\\\"mouseleave\\\", \\\"mouse\\\"],\\n      [\\\"mousemove\\\", \\\"mouse\\\"],\\n      [\\\"mouseout\\\", \\\"mouse\\\"],\\n      [\\\"mouseover\\\", \\\"mouse\\\"],\\n      [\\\"mouseup\\\", \\\"mouse\\\"],\\n      [\\\"mouseleave\\\", \\\"mouse\\\"],\\n      [\\\"mousewheel\\\", \\\"mouse\\\"],\\n      [\\\"keydown\\\", \\\"keyboard\\\"],\\n      [\\\"keyup\\\", \\\"keyboard\\\"],\\n      [\\\"keypress\\\", \\\"keyboard\\\"],\\n      [\\\"textInput\\\", \\\"keyboard\\\"],\\n      [\\\"touchstart\\\", \\\"touch\\\"],\\n      [\\\"touchmove\\\", \\\"touch\\\"],\\n      [\\\"touchend\\\", \\\"touch\\\"],\\n      [\\\"touchcancel\\\", \\\"touch\\\"],\\n      [\\\"pointerover\\\", \\\"pointer\\\"],\\n      [\\\"pointerout\\\", \\\"pointer\\\"],\\n      [\\\"pointerenter\\\", \\\"pointer\\\"],\\n      [\\\"pointerleave\\\", \\\"pointer\\\"],\\n      [\\\"pointerdown\\\", \\\"pointer\\\"],\\n      [\\\"pointerup\\\", \\\"pointer\\\"],\\n      [\\\"pointermove\\\", \\\"pointer\\\"],\\n      [\\\"pointercancel\\\", \\\"pointer\\\"],\\n      [\\\"gotpointercapture\\\", \\\"pointer\\\"],\\n      [\\\"lostpointercapture\\\", \\\"pointer\\\"],\\n      [\\\"focus\\\", \\\"focus\\\"],\\n      [\\\"blur\\\", \\\"focus\\\"],\\n      [\\\"drag\\\", \\\"drag\\\"],\\n      [\\\"dragstart\\\", \\\"drag\\\"],\\n      [\\\"dragend\\\", \\\"drag\\\"],\\n      [\\\"dragover\\\", \\\"drag\\\"],\\n      [\\\"dragenter\\\", \\\"drag\\\"],\\n      [\\\"dragleave\\\", \\\"drag\\\"],\\n      [\\\"dragexit\\\", \\\"drag\\\"],\\n      [\\\"drop\\\", \\\"drag\\\"],\\n      [\\\"wheel\\\", \\\"wheel\\\"],\\n      [\\\"deviceorientation\\\", \\\"deviceorientation\\\"],\\n      [\\\"deviceorientationabsolute\\\", \\\"deviceorientation\\\"],\\n      [\\\"devicemotion\\\", \\\"devicemotion\\\"]\\n    ]);\\n    this._hoverHitTargetInterceptorEvents = /* @__PURE__ */ new Set([\\\"mousemove\\\"]);\\n    this._tapHitTargetInterceptorEvents = /* @__PURE__ */ new Set([\\\"pointerdown\\\", \\\"pointerup\\\", \\\"touchstart\\\", \\\"touchend\\\", \\\"touchcancel\\\"]);\\n    this._mouseHitTargetInterceptorEvents = /* @__PURE__ */ new Set([\\\"mousedown\\\", \\\"mouseup\\\", \\\"pointerdown\\\", \\\"pointerup\\\", \\\"click\\\", \\\"auxclick\\\", \\\"dblclick\\\", \\\"contextmenu\\\"]);\\n    this._allHitTargetInterceptorEvents = /* @__PURE__ */ new Set([...this._hoverHitTargetInterceptorEvents, ...this._tapHitTargetInterceptorEvents, ...this._mouseHitTargetInterceptorEvents]);\\n    this._engines = /* @__PURE__ */ new Map();\\n    this._engines.set(\\\"xpath\\\", XPathEngine);\\n    this._engines.set(\\\"xpath:light\\\", XPathEngine);\\n    this._engines.set(\\\"_react\\\", createReactEngine());\\n    this._engines.set(\\\"_vue\\\", createVueEngine());\\n    this._engines.set(\\\"role\\\", createRoleEngine(false));\\n    this._engines.set(\\\"text\\\", this._createTextEngine(true, false));\\n    this._engines.set(\\\"text:light\\\", this._createTextEngine(false, false));\\n    this._engines.set(\\\"id\\\", this._createAttributeEngine(\\\"id\\\", true));\\n    this._engines.set(\\\"id:light\\\", this._createAttributeEngine(\\\"id\\\", false));\\n    this._engines.set(\\\"data-testid\\\", this._createAttributeEngine(\\\"data-testid\\\", true));\\n    this._engines.set(\\\"data-testid:light\\\", this._createAttributeEngine(\\\"data-testid\\\", false));\\n    this._engines.set(\\\"data-test-id\\\", this._createAttributeEngine(\\\"data-test-id\\\", true));\\n    this._engines.set(\\\"data-test-id:light\\\", this._createAttributeEngine(\\\"data-test-id\\\", false));\\n    this._engines.set(\\\"data-test\\\", this._createAttributeEngine(\\\"data-test\\\", true));\\n    this._engines.set(\\\"data-test:light\\\", this._createAttributeEngine(\\\"data-test\\\", false));\\n    this._engines.set(\\\"css\\\", this._createCSSEngine());\\n    this._engines.set(\\\"nth\\\", { queryAll: () => [] });\\n    this._engines.set(\\\"visible\\\", this._createVisibleEngine());\\n    this._engines.set(\\\"internal:control\\\", this._createControlEngine());\\n    this._engines.set(\\\"internal:has\\\", this._createHasEngine());\\n    this._engines.set(\\\"internal:has-not\\\", this._createHasNotEngine());\\n    this._engines.set(\\\"internal:and\\\", { queryAll: () => [] });\\n    this._engines.set(\\\"internal:or\\\", { queryAll: () => [] });\\n    this._engines.set(\\\"internal:chain\\\", this._createInternalChainEngine());\\n    this._engines.set(\\\"internal:label\\\", this._createInternalLabelEngine());\\n    this._engines.set(\\\"internal:text\\\", this._createTextEngine(true, true));\\n    this._engines.set(\\\"internal:has-text\\\", this._createInternalHasTextEngine());\\n    this._engines.set(\\\"internal:has-not-text\\\", this._createInternalHasNotTextEngine());\\n    this._engines.set(\\\"internal:attr\\\", this._createNamedAttributeEngine());\\n    this._engines.set(\\\"internal:testid\\\", this._createNamedAttributeEngine());\\n    this._engines.set(\\\"internal:role\\\", createRoleEngine(true));\\n    this._engines.set(\\\"internal:describe\\\", this._createDescribeEngine());\\n    this._engines.set(\\\"aria-ref\\\", this._createAriaRefEngine());\\n    for (const { name, source } of options.customEngines)\\n      this._engines.set(name, this.eval(source));\\n    this._stableRafCount = options.stableRafCount;\\n    this._browserName = options.browserName;\\n    this._isUtilityWorld = !!options.isUtilityWorld;\\n    setGlobalOptions({ browserNameForWorkarounds: options.browserName });\\n    this._setupGlobalListenersRemovalDetection();\\n    this._setupHitTargetInterceptors();\\n    if (this.isUnderTest)\\n      this.window.__injectedScript = this;\\n  }\\n  eval(expression) {\\n    return this.window.eval(expression);\\n  }\\n  testIdAttributeNameForStrictErrorAndConsoleCodegen() {\\n    return this._testIdAttributeNameForStrictErrorAndConsoleCodegen;\\n  }\\n  parseSelector(selector) {\\n    const result = parseSelector(selector);\\n    visitAllSelectorParts(result, (part) => {\\n      if (!this._engines.has(part.name))\\n        throw this.createStacklessError(`Unknown engine \\\"${part.name}\\\" while parsing selector ${selector}`);\\n    });\\n    return result;\\n  }\\n  generateSelector(targetElement, options) {\\n    return generateSelector(this, targetElement, options);\\n  }\\n  generateSelectorSimple(targetElement, options) {\\n    return generateSelector(this, targetElement, { ...options, testIdAttributeName: this._testIdAttributeNameForStrictErrorAndConsoleCodegen }).selector;\\n  }\\n  querySelector(selector, root, strict) {\\n    const result = this.querySelectorAll(selector, root);\\n    if (strict && result.length > 1)\\n      throw this.strictModeViolationError(selector, result);\\n    this.checkDeprecatedSelectorUsage(selector, result);\\n    return result[0];\\n  }\\n  _queryNth(elements, part) {\\n    const list = [...elements];\\n    let nth = +part.body;\\n    if (nth === -1)\\n      nth = list.length - 1;\\n    return new Set(list.slice(nth, nth + 1));\\n  }\\n  _queryLayoutSelector(elements, part, originalRoot) {\\n    const name = part.name;\\n    const body = part.body;\\n    const result = [];\\n    const inner = this.querySelectorAll(body.parsed, originalRoot);\\n    for (const element of elements) {\\n      const score = layoutSelectorScore(name, element, inner, body.distance);\\n      if (score !== void 0)\\n        result.push({ element, score });\\n    }\\n    result.sort((a, b) => a.score - b.score);\\n    return new Set(result.map((r) => r.element));\\n  }\\n  ariaSnapshot(node, options) {\\n    return this.incrementalAriaSnapshot(node, options).full;\\n  }\\n  incrementalAriaSnapshot(node, options) {\\n    if (node.nodeType !== Node.ELEMENT_NODE)\\n      throw this.createStacklessError(\\\"Can only capture aria snapshot of Element nodes.\\\");\\n    const ariaSnapshot = generateAriaTree(node, options);\\n    const full = renderAriaTree(ariaSnapshot, options);\\n    let incremental;\\n    if (options.track) {\\n      const previousSnapshot = this._lastAriaSnapshotForTrack.get(options.track);\\n      if (previousSnapshot)\\n        incremental = renderAriaTree(ariaSnapshot, options, previousSnapshot);\\n      this._lastAriaSnapshotForTrack.set(options.track, ariaSnapshot);\\n    }\\n    this._lastAriaSnapshotForQuery = ariaSnapshot;\\n    return { full, incremental, iframeRefs: ariaSnapshot.iframeRefs };\\n  }\\n  ariaSnapshotForRecorder() {\\n    const tree = generateAriaTree(this.document.body, { mode: \\\"ai\\\" });\\n    const ariaSnapshot = renderAriaTree(tree, { mode: \\\"ai\\\" });\\n    return { ariaSnapshot, refs: tree.refs };\\n  }\\n  getAllElementsMatchingExpectAriaTemplate(document, template) {\\n    return getAllElementsMatchingExpectAriaTemplate(document.documentElement, template);\\n  }\\n  querySelectorAll(selector, root) {\\n    if (selector.capture !== void 0) {\\n      if (selector.parts.some((part) => part.name === \\\"nth\\\"))\\n        throw this.createStacklessError(`Can't query n-th element in a request with the capture.`);\\n      const withHas = { parts: selector.parts.slice(0, selector.capture + 1) };\\n      if (selector.capture < selector.parts.length - 1) {\\n        const parsed = { parts: selector.parts.slice(selector.capture + 1) };\\n        const has = { name: \\\"internal:has\\\", body: { parsed }, source: stringifySelector(parsed) };\\n        withHas.parts.push(has);\\n      }\\n      return this.querySelectorAll(withHas, root);\\n    }\\n    if (!root[\\\"querySelectorAll\\\"])\\n      throw this.createStacklessError(\\\"Node is not queryable.\\\");\\n    if (selector.capture !== void 0) {\\n      throw this.createStacklessError(\\\"Internal error: there should not be a capture in the selector.\\\");\\n    }\\n    if (root.nodeType === 11 && selector.parts.length === 1 && selector.parts[0].name === \\\"css\\\" && selector.parts[0].source === \\\":scope\\\")\\n      return [root];\\n    this._evaluator.begin();\\n    try {\\n      let roots = /* @__PURE__ */ new Set([root]);\\n      for (const part of selector.parts) {\\n        if (part.name === \\\"nth\\\") {\\n          roots = this._queryNth(roots, part);\\n        } else if (part.name === \\\"internal:and\\\") {\\n          const andElements = this.querySelectorAll(part.body.parsed, root);\\n          roots = new Set(andElements.filter((e) => roots.has(e)));\\n        } else if (part.name === \\\"internal:or\\\") {\\n          const orElements = this.querySelectorAll(part.body.parsed, root);\\n          roots = new Set(sortInDOMOrder(/* @__PURE__ */ new Set([...roots, ...orElements])));\\n        } else if (kLayoutSelectorNames.includes(part.name)) {\\n          roots = this._queryLayoutSelector(roots, part, root);\\n        } else {\\n          const next = /* @__PURE__ */ new Set();\\n          for (const root2 of roots) {\\n            const all = this._queryEngineAll(part, root2);\\n            for (const one of all)\\n              next.add(one);\\n          }\\n          roots = next;\\n        }\\n      }\\n      return [...roots];\\n    } finally {\\n      this._evaluator.end();\\n    }\\n  }\\n  _queryEngineAll(part, root) {\\n    const result = this._engines.get(part.name).queryAll(root, part.body);\\n    for (const element of result) {\\n      if (!(\\\"nodeName\\\" in element))\\n        throw this.createStacklessError(`Expected a Node but got ${Object.prototype.toString.call(element)}`);\\n    }\\n    return result;\\n  }\\n  _createAttributeEngine(attribute, shadow) {\\n    const toCSS = (selector) => {\\n      const css = `[${attribute}=${JSON.stringify(selector)}]`;\\n      return [{ simples: [{ selector: { css, functions: [] }, combinator: \\\"\\\" }] }];\\n    };\\n    return {\\n      queryAll: (root, selector) => {\\n        return this._evaluator.query({ scope: root, pierceShadow: shadow }, toCSS(selector));\\n      }\\n    };\\n  }\\n  _createCSSEngine() {\\n    return {\\n      queryAll: (root, body) => {\\n        return this._evaluator.query({ scope: root, pierceShadow: true }, body);\\n      }\\n    };\\n  }\\n  _createTextEngine(shadow, internal) {\\n    const queryAll = (root, selector) => {\\n      const { matcher, kind } = createTextMatcher(selector, internal);\\n      const result = [];\\n      let lastDidNotMatchSelf = null;\\n      const appendElement = (element) => {\\n        if (kind === \\\"lax\\\" && lastDidNotMatchSelf && lastDidNotMatchSelf.contains(element))\\n          return false;\\n        const matches = elementMatchesText(this._evaluator._cacheText, element, matcher);\\n        if (matches === \\\"none\\\")\\n          lastDidNotMatchSelf = element;\\n        if (matches === \\\"self\\\" || matches === \\\"selfAndChildren\\\" && kind === \\\"strict\\\" && !internal)\\n          result.push(element);\\n      };\\n      if (root.nodeType === Node.ELEMENT_NODE)\\n        appendElement(root);\\n      const elements = this._evaluator._queryCSS({ scope: root, pierceShadow: shadow }, \\\"*\\\");\\n      for (const element of elements)\\n        appendElement(element);\\n      return result;\\n    };\\n    return { queryAll };\\n  }\\n  _createInternalHasTextEngine() {\\n    return {\\n      queryAll: (root, selector) => {\\n        if (root.nodeType !== 1)\\n          return [];\\n        const element = root;\\n        const text = elementText(this._evaluator._cacheText, element);\\n        const { matcher } = createTextMatcher(selector, true);\\n        return matcher(text) ? [element] : [];\\n      }\\n    };\\n  }\\n  _createInternalHasNotTextEngine() {\\n    return {\\n      queryAll: (root, selector) => {\\n        if (root.nodeType !== 1)\\n          return [];\\n        const element = root;\\n        const text = elementText(this._evaluator._cacheText, element);\\n        const { matcher } = createTextMatcher(selector, true);\\n        return matcher(text) ? [] : [element];\\n      }\\n    };\\n  }\\n  _createInternalLabelEngine() {\\n    return {\\n      queryAll: (root, selector) => {\\n        const { matcher } = createTextMatcher(selector, true);\\n        const allElements = this._evaluator._queryCSS({ scope: root, pierceShadow: true }, \\\"*\\\");\\n        return allElements.filter((element) => {\\n          return getElementLabels(this._evaluator._cacheText, element).some((label) => matcher(label));\\n        });\\n      }\\n    };\\n  }\\n  _createNamedAttributeEngine() {\\n    const queryAll = (root, selector) => {\\n      const parsed = parseAttributeSelector(selector, true);\\n      if (parsed.name || parsed.attributes.length !== 1)\\n        throw new Error(\\\"Malformed attribute selector: \\\" + selector);\\n      const { name, value, caseSensitive } = parsed.attributes[0];\\n      const lowerCaseValue = caseSensitive ? null : value.toLowerCase();\\n      let matcher;\\n      if (value instanceof RegExp)\\n        matcher = (s) => !!s.match(value);\\n      else if (caseSensitive)\\n        matcher = (s) => s === value;\\n      else\\n        matcher = (s) => s.toLowerCase().includes(lowerCaseValue);\\n      const elements = this._evaluator._queryCSS({ scope: root, pierceShadow: true }, `[${name}]`);\\n      return elements.filter((e) => matcher(e.getAttribute(name)));\\n    };\\n    return { queryAll };\\n  }\\n  _createDescribeEngine() {\\n    const queryAll = (root) => {\\n      if (root.nodeType !== 1)\\n        return [];\\n      return [root];\\n    };\\n    return { queryAll };\\n  }\\n  _createControlEngine() {\\n    return {\\n      queryAll(root, body) {\\n        if (body === \\\"enter-frame\\\")\\n          return [];\\n        if (body === \\\"return-empty\\\")\\n          return [];\\n        if (body === \\\"component\\\") {\\n          if (root.nodeType !== 1)\\n            return [];\\n          return [root.childElementCount === 1 ? root.firstElementChild : root];\\n        }\\n        throw new Error(`Internal error, unknown internal:control selector ${body}`);\\n      }\\n    };\\n  }\\n  _createHasEngine() {\\n    const queryAll = (root, body) => {\\n      if (root.nodeType !== 1)\\n        return [];\\n      const has = !!this.querySelector(body.parsed, root, false);\\n      return has ? [root] : [];\\n    };\\n    return { queryAll };\\n  }\\n  _createHasNotEngine() {\\n    const queryAll = (root, body) => {\\n      if (root.nodeType !== 1)\\n        return [];\\n      const has = !!this.querySelector(body.parsed, root, false);\\n      return has ? [] : [root];\\n    };\\n    return { queryAll };\\n  }\\n  _createVisibleEngine() {\\n    const queryAll = (root, body) => {\\n      if (root.nodeType !== 1)\\n        return [];\\n      const visible = body === \\\"true\\\";\\n      return isElementVisible(root) === visible ? [root] : [];\\n    };\\n    return { queryAll };\\n  }\\n  _createInternalChainEngine() {\\n    const queryAll = (root, body) => {\\n      return this.querySelectorAll(body.parsed, root);\\n    };\\n    return { queryAll };\\n  }\\n  extend(source, params) {\\n    const constrFunction = this.window.eval(`\\n    (() => {\\n      const module = {};\\n      ${source}\\n      return module.exports.default();\\n    })()`);\\n    return new constrFunction(this, params);\\n  }\\n  async viewportRatio(element) {\\n    return await new Promise((resolve) => {\\n      const observer = new IntersectionObserver((entries) => {\\n        resolve(entries[0].intersectionRatio);\\n        observer.disconnect();\\n      });\\n      observer.observe(element);\\n      this.utils.builtins.requestAnimationFrame(() => {\\n      });\\n    });\\n  }\\n  getElementBorderWidth(node) {\\n    if (node.nodeType !== Node.ELEMENT_NODE || !node.ownerDocument || !node.ownerDocument.defaultView)\\n      return { left: 0, top: 0 };\\n    const style = node.ownerDocument.defaultView.getComputedStyle(node);\\n    return { left: parseInt(style.borderLeftWidth || \\\"\\\", 10), top: parseInt(style.borderTopWidth || \\\"\\\", 10) };\\n  }\\n  describeIFrameStyle(iframe) {\\n    if (!iframe.ownerDocument || !iframe.ownerDocument.defaultView)\\n      return \\\"error:notconnected\\\";\\n    const defaultView = iframe.ownerDocument.defaultView;\\n    for (let e = iframe; e; e = parentElementOrShadowHost(e)) {\\n      if (defaultView.getComputedStyle(e).transform !== \\\"none\\\")\\n        return \\\"transformed\\\";\\n    }\\n    const iframeStyle = defaultView.getComputedStyle(iframe);\\n    return {\\n      left: parseInt(iframeStyle.borderLeftWidth || \\\"\\\", 10) + parseInt(iframeStyle.paddingLeft || \\\"\\\", 10),\\n      top: parseInt(iframeStyle.borderTopWidth || \\\"\\\", 10) + parseInt(iframeStyle.paddingTop || \\\"\\\", 10)\\n    };\\n  }\\n  retarget(node, behavior) {\\n    let element = node.nodeType === Node.ELEMENT_NODE ? node : node.parentElement;\\n    if (!element)\\n      return null;\\n    if (behavior === \\\"none\\\")\\n      return element;\\n    if (!element.matches(\\\"input, textarea, select\\\") && !element.isContentEditable) {\\n      if (behavior === \\\"button-link\\\")\\n        element = element.closest(\\\"button, [role=button], a, [role=link]\\\") || element;\\n      else\\n        element = element.closest(\\\"button, [role=button], [role=checkbox], [role=radio]\\\") || element;\\n    }\\n    if (behavior === \\\"follow-label\\\") {\\n      if (!element.matches(\\\"a, input, textarea, button, select, [role=link], [role=button], [role=checkbox], [role=radio]\\\") && !element.isContentEditable) {\\n        const enclosingLabel = element.closest(\\\"label\\\");\\n        if (enclosingLabel && enclosingLabel.control)\\n          element = enclosingLabel.control;\\n      }\\n    }\\n    return element;\\n  }\\n  async checkElementStates(node, states) {\\n    if (states.includes(\\\"stable\\\")) {\\n      const stableResult = await this._checkElementIsStable(node);\\n      if (stableResult === false)\\n        return { missingState: \\\"stable\\\" };\\n      if (stableResult === \\\"error:notconnected\\\")\\n        return \\\"error:notconnected\\\";\\n    }\\n    for (const state of states) {\\n      if (state !== \\\"stable\\\") {\\n        const result = this.elementState(node, state);\\n        if (result.received === \\\"error:notconnected\\\")\\n          return \\\"error:notconnected\\\";\\n        if (!result.matches)\\n          return { missingState: state };\\n      }\\n    }\\n  }\\n  async _checkElementIsStable(node) {\\n    const continuePolling = /* @__PURE__ */ Symbol(\\\"continuePolling\\\");\\n    let lastRect;\\n    let stableRafCounter = 0;\\n    let lastTime = 0;\\n    const check = () => {\\n      const element = this.retarget(node, \\\"no-follow-label\\\");\\n      if (!element)\\n        return \\\"error:notconnected\\\";\\n      const time = this.utils.builtins.performance.now();\\n      if (this._stableRafCount > 1 && time - lastTime < 15)\\n        return continuePolling;\\n      lastTime = time;\\n      const clientRect = element.getBoundingClientRect();\\n      const rect = { x: clientRect.top, y: clientRect.left, width: clientRect.width, height: clientRect.height };\\n      if (lastRect) {\\n        const samePosition = rect.x === lastRect.x && rect.y === lastRect.y && rect.width === lastRect.width && rect.height === lastRect.height;\\n        if (!samePosition)\\n          return false;\\n        if (++stableRafCounter >= this._stableRafCount)\\n          return true;\\n      }\\n      lastRect = rect;\\n      return continuePolling;\\n    };\\n    let fulfill;\\n    let reject;\\n    const result = new Promise((f, r) => {\\n      fulfill = f;\\n      reject = r;\\n    });\\n    const raf = () => {\\n      try {\\n        const success = check();\\n        if (success !== continuePolling)\\n          fulfill(success);\\n        else\\n          this.utils.builtins.requestAnimationFrame(raf);\\n      } catch (e) {\\n        reject(e);\\n      }\\n    };\\n    this.utils.builtins.requestAnimationFrame(raf);\\n    return result;\\n  }\\n  _createAriaRefEngine() {\\n    const queryAll = (root, selector) => {\\n      var _a, _b;\\n      const result = (_b = (_a = this._lastAriaSnapshotForQuery) == null ? void 0 : _a.elements) == null ? void 0 : _b.get(selector);\\n      return result && result.isConnected ? [result] : [];\\n    };\\n    return { queryAll };\\n  }\\n  elementState(node, state) {\\n    const element = this.retarget(node, [\\\"visible\\\", \\\"hidden\\\"].includes(state) ? \\\"none\\\" : \\\"follow-label\\\");\\n    if (!element || !element.isConnected) {\\n      if (state === \\\"hidden\\\")\\n        return { matches: true, received: \\\"hidden\\\" };\\n      return { matches: false, received: \\\"error:notconnected\\\" };\\n    }\\n    if (state === \\\"visible\\\" || state === \\\"hidden\\\") {\\n      const visible = isElementVisible(element);\\n      return {\\n        matches: state === \\\"visible\\\" ? visible : !visible,\\n        received: visible ? \\\"visible\\\" : \\\"hidden\\\"\\n      };\\n    }\\n    if (state === \\\"disabled\\\" || state === \\\"enabled\\\") {\\n      const disabled = getAriaDisabled(element);\\n      return {\\n        matches: state === \\\"disabled\\\" ? disabled : !disabled,\\n        received: disabled ? \\\"disabled\\\" : \\\"enabled\\\"\\n      };\\n    }\\n    if (state === \\\"editable\\\") {\\n      const disabled = getAriaDisabled(element);\\n      const readonly = getReadonly(element);\\n      if (readonly === \\\"error\\\")\\n        throw this.createStacklessError(\\\"Element is not an <input>, <textarea>, <select> or [contenteditable] and does not have a role allowing [aria-readonly]\\\");\\n      return {\\n        matches: !disabled && !readonly,\\n        received: disabled ? \\\"disabled\\\" : readonly ? \\\"readOnly\\\" : \\\"editable\\\"\\n      };\\n    }\\n    if (state === \\\"checked\\\" || state === \\\"unchecked\\\") {\\n      const need = state === \\\"checked\\\";\\n      const checked = getCheckedWithoutMixed(element);\\n      if (checked === \\\"error\\\")\\n        throw this.createStacklessError(\\\"Not a checkbox or radio button\\\");\\n      const isRadio = element.nodeName === \\\"INPUT\\\" && element.type === \\\"radio\\\";\\n      return {\\n        matches: need === checked,\\n        received: checked ? \\\"checked\\\" : \\\"unchecked\\\",\\n        isRadio\\n      };\\n    }\\n    if (state === \\\"indeterminate\\\") {\\n      const checked = getCheckedAllowMixed(element);\\n      if (checked === \\\"error\\\")\\n        throw this.createStacklessError(\\\"Not a checkbox or radio button\\\");\\n      return {\\n        matches: checked === \\\"mixed\\\",\\n        received: checked === true ? \\\"checked\\\" : checked === false ? \\\"unchecked\\\" : \\\"mixed\\\"\\n      };\\n    }\\n    throw this.createStacklessError(`Unexpected element state \\\"${state}\\\"`);\\n  }\\n  selectOptions(node, optionsToSelect) {\\n    const element = this.retarget(node, \\\"follow-label\\\");\\n    if (!element)\\n      return \\\"error:notconnected\\\";\\n    if (element.nodeName.toLowerCase() !== \\\"select\\\")\\n      throw this.createStacklessError(\\\"Element is not a <select> element\\\");\\n    const select = element;\\n    const options = [...select.options];\\n    const selectedOptions = [];\\n    let remainingOptionsToSelect = optionsToSelect.slice();\\n    for (let index = 0; index < options.length; index++) {\\n      const option = options[index];\\n      const filter = (optionToSelect) => {\\n        if (optionToSelect instanceof Node)\\n          return option === optionToSelect;\\n        let matches = true;\\n        if (optionToSelect.valueOrLabel !== void 0)\\n          matches = matches && (optionToSelect.valueOrLabel === option.value || optionToSelect.valueOrLabel === option.label);\\n        if (optionToSelect.value !== void 0)\\n          matches = matches && optionToSelect.value === option.value;\\n        if (optionToSelect.label !== void 0)\\n          matches = matches && optionToSelect.label === option.label;\\n        if (optionToSelect.index !== void 0)\\n          matches = matches && optionToSelect.index === index;\\n        return matches;\\n      };\\n      if (!remainingOptionsToSelect.some(filter))\\n        continue;\\n      if (!this.elementState(option, \\\"enabled\\\").matches)\\n        return \\\"error:optionnotenabled\\\";\\n      selectedOptions.push(option);\\n      if (select.multiple) {\\n        remainingOptionsToSelect = remainingOptionsToSelect.filter((o) => !filter(o));\\n      } else {\\n        remainingOptionsToSelect = [];\\n        break;\\n      }\\n    }\\n    if (remainingOptionsToSelect.length)\\n      return \\\"error:optionsnotfound\\\";\\n    select.value = void 0;\\n    selectedOptions.forEach((option) => option.selected = true);\\n    select.dispatchEvent(new Event(\\\"input\\\", { bubbles: true, composed: true }));\\n    select.dispatchEvent(new Event(\\\"change\\\", { bubbles: true }));\\n    return selectedOptions.map((option) => option.value);\\n  }\\n  fill(node, value) {\\n    const element = this.retarget(node, \\\"follow-label\\\");\\n    if (!element)\\n      return \\\"error:notconnected\\\";\\n    if (element.nodeName.toLowerCase() === \\\"input\\\") {\\n      const input = element;\\n      const type = input.type.toLowerCase();\\n      const kInputTypesToSetValue = /* @__PURE__ */ new Set([\\\"color\\\", \\\"date\\\", \\\"time\\\", \\\"datetime-local\\\", \\\"month\\\", \\\"range\\\", \\\"week\\\"]);\\n      const kInputTypesToTypeInto = /* @__PURE__ */ new Set([\\\"\\\", \\\"email\\\", \\\"number\\\", \\\"password\\\", \\\"search\\\", \\\"tel\\\", \\\"text\\\", \\\"url\\\"]);\\n      if (!kInputTypesToTypeInto.has(type) && !kInputTypesToSetValue.has(type))\\n        throw this.createStacklessError(`Input of type \\\"${type}\\\" cannot be filled`);\\n      if (type === \\\"number\\\") {\\n        value = value.trim();\\n        if (isNaN(Number(value)))\\n          throw this.createStacklessError(\\\"Cannot type text into input[type=number]\\\");\\n      }\\n      if (kInputTypesToSetValue.has(type)) {\\n        value = value.trim();\\n        input.focus();\\n        input.value = value;\\n        if (input.value !== value)\\n          throw this.createStacklessError(\\\"Malformed value\\\");\\n        element.dispatchEvent(new Event(\\\"input\\\", { bubbles: true, composed: true }));\\n        element.dispatchEvent(new Event(\\\"change\\\", { bubbles: true }));\\n        return \\\"done\\\";\\n      }\\n    } else if (element.nodeName.toLowerCase() === \\\"textarea\\\") {\\n    } else if (!element.isContentEditable) {\\n      throw this.createStacklessError(\\\"Element is not an <input>, <textarea> or [contenteditable] element\\\");\\n    }\\n    this.selectText(element);\\n    return \\\"needsinput\\\";\\n  }\\n  selectText(node) {\\n    const element = this.retarget(node, \\\"follow-label\\\");\\n    if (!element)\\n      return \\\"error:notconnected\\\";\\n    if (element.nodeName.toLowerCase() === \\\"input\\\") {\\n      const input = element;\\n      input.select();\\n      input.focus();\\n      return \\\"done\\\";\\n    }\\n    if (element.nodeName.toLowerCase() === \\\"textarea\\\") {\\n      const textarea = element;\\n      textarea.selectionStart = 0;\\n      textarea.selectionEnd = textarea.value.length;\\n      textarea.focus();\\n      return \\\"done\\\";\\n    }\\n    const range = element.ownerDocument.createRange();\\n    range.selectNodeContents(element);\\n    const selection = element.ownerDocument.defaultView.getSelection();\\n    if (selection) {\\n      selection.removeAllRanges();\\n      selection.addRange(range);\\n    }\\n    element.focus();\\n    return \\\"done\\\";\\n  }\\n  _activelyFocused(node) {\\n    const activeElement = node.getRootNode().activeElement;\\n    const isFocused = activeElement === node && !!node.ownerDocument && node.ownerDocument.hasFocus();\\n    return { activeElement, isFocused };\\n  }\\n  focusNode(node, resetSelectionIfNotFocused) {\\n    if (!node.isConnected)\\n      return \\\"error:notconnected\\\";\\n    if (node.nodeType !== Node.ELEMENT_NODE)\\n      throw this.createStacklessError(\\\"Node is not an element\\\");\\n    const { activeElement, isFocused: wasFocused } = this._activelyFocused(node);\\n    if (node.isContentEditable && !wasFocused && activeElement && activeElement.blur) {\\n      activeElement.blur();\\n    }\\n    node.focus();\\n    node.focus();\\n    if (resetSelectionIfNotFocused && !wasFocused && node.nodeName.toLowerCase() === \\\"input\\\") {\\n      try {\\n        const input = node;\\n        input.setSelectionRange(0, 0);\\n      } catch (e) {\\n      }\\n    }\\n    return \\\"done\\\";\\n  }\\n  blurNode(node) {\\n    if (!node.isConnected)\\n      return \\\"error:notconnected\\\";\\n    if (node.nodeType !== Node.ELEMENT_NODE)\\n      throw this.createStacklessError(\\\"Node is not an element\\\");\\n    node.blur();\\n    return \\\"done\\\";\\n  }\\n  setInputFiles(node, payloads) {\\n    if (node.nodeType !== Node.ELEMENT_NODE)\\n      return \\\"Node is not of type HTMLElement\\\";\\n    const element = node;\\n    if (element.nodeName !== \\\"INPUT\\\")\\n      return \\\"Not an <input> element\\\";\\n    const input = element;\\n    const type = (input.getAttribute(\\\"type\\\") || \\\"\\\").toLowerCase();\\n    if (type !== \\\"file\\\")\\n      return \\\"Not an input[type=file] element\\\";\\n    const files = payloads.map((file) => {\\n      const bytes = Uint8Array.from(atob(file.buffer), (c) => c.charCodeAt(0));\\n      return new File([bytes], file.name, { type: file.mimeType, lastModified: file.lastModifiedMs });\\n    });\\n    const dt = new DataTransfer();\\n    for (const file of files)\\n      dt.items.add(file);\\n    input.files = dt.files;\\n    input.dispatchEvent(new Event(\\\"input\\\", { bubbles: true, composed: true }));\\n    input.dispatchEvent(new Event(\\\"change\\\", { bubbles: true }));\\n  }\\n  expectHitTarget(hitPoint, targetElement) {\\n    var _a;\\n    const roots = [];\\n    let parentElement = targetElement;\\n    while (parentElement) {\\n      const root = enclosingShadowRootOrDocument(parentElement);\\n      if (!root)\\n        break;\\n      roots.push(root);\\n      if (root.nodeType === 9)\\n        break;\\n      parentElement = root.host;\\n    }\\n    let hitElement;\\n    for (let index = roots.length - 1; index >= 0; index--) {\\n      const root = roots[index];\\n      const elements = root.elementsFromPoint(hitPoint.x, hitPoint.y);\\n      const singleElement = root.elementFromPoint(hitPoint.x, hitPoint.y);\\n      if (singleElement && elements[0] && parentElementOrShadowHost(singleElement) === elements[0]) {\\n        const style = this.window.getComputedStyle(singleElement);\\n        if ((style == null ? void 0 : style.display) === \\\"contents\\\") {\\n          elements.unshift(singleElement);\\n        }\\n      }\\n      if (elements[0] && elements[0].shadowRoot === root && elements[1] === singleElement) {\\n        elements.shift();\\n      }\\n      const innerElement = elements[0];\\n      if (!innerElement)\\n        break;\\n      hitElement = innerElement;\\n      if (index && innerElement !== roots[index - 1].host)\\n        break;\\n    }\\n    const hitParents = [];\\n    while (hitElement && hitElement !== targetElement) {\\n      hitParents.push(hitElement);\\n      hitElement = (_a = hitElement.assignedSlot) != null ? _a : parentElementOrShadowHost(hitElement);\\n    }\\n    if (hitElement === targetElement)\\n      return \\\"done\\\";\\n    const hitTargetDescription = this.previewNode(hitParents[0] || this.document.documentElement);\\n    let rootHitTargetDescription;\\n    let element = targetElement;\\n    while (element) {\\n      const index = hitParents.indexOf(element);\\n      if (index !== -1) {\\n        if (index > 1)\\n          rootHitTargetDescription = this.previewNode(hitParents[index - 1]);\\n        break;\\n      }\\n      element = parentElementOrShadowHost(element);\\n    }\\n    if (rootHitTargetDescription)\\n      return { hitTargetDescription: `${hitTargetDescription} from ${rootHitTargetDescription} subtree` };\\n    return { hitTargetDescription };\\n  }\\n  // Life of a pointer action, for example click.\\n  //\\n  // 0. Retry items 1 and 2 while action fails due to navigation or element being detached.\\n  //   1. Resolve selector to an element.\\n  //   2. Retry the following steps until the element is detached or frame navigates away.\\n  //     2a. Wait for the element to be stable (not moving), visible and enabled.\\n  //     2b. Scroll element into view. Scrolling alternates between:\\n  //         - Built-in protocol scrolling.\\n  //         - Anchoring to the top/left, bottom/right and center/center.\\n  //         This is to scroll elements from under sticky headers/footers.\\n  //     2c. Click point is calculated, either based on explicitly specified position,\\n  //         or some visible point of the element based on protocol content quads.\\n  //     2d. Click point relative to page viewport is converted relative to the target iframe\\n  //         for the next hit-point check.\\n  //     2e. (injected) Hit target at the click point must be a descendant of the target element.\\n  //         This prevents mis-clicking in edge cases like <iframe> overlaying the target.\\n  //     2f. (injected) Events specific for click (or some other action type) are intercepted on\\n  //         the Window with capture:true. See 2i for details.\\n  //         Note: this step is skipped for drag&drop (see inline comments for the reason).\\n  //     2g. Necessary keyboard modifiers are pressed.\\n  //     2h. Click event is issued (mousemove + mousedown + mouseup).\\n  //     2i. (injected) For each event, we check that hit target at the event point\\n  //         is a descendant of the target element.\\n  //         This guarantees no race between issuing the event and handling it in the page,\\n  //         for example due to layout shift.\\n  //         When hit target check fails, we block all future events in the page.\\n  //     2j. Keyboard modifiers are restored.\\n  //     2k. (injected) Event interceptor is removed.\\n  //     2l. All navigations triggered between 2g-2k are awaited to be either committed or canceled.\\n  //     2m. If failed, wait for increasing amount of time before the next retry.\\n  setupHitTargetInterceptor(node, action, hitPoint, blockAllEvents) {\\n    const element = this.retarget(node, \\\"button-link\\\");\\n    if (!element || !element.isConnected)\\n      return \\\"error:notconnected\\\";\\n    if (hitPoint) {\\n      const preliminaryResult = this.expectHitTarget(hitPoint, element);\\n      if (preliminaryResult !== \\\"done\\\")\\n        return preliminaryResult.hitTargetDescription;\\n    }\\n    if (action === \\\"drag\\\")\\n      return { stop: () => \\\"done\\\" };\\n    const events = {\\n      \\\"hover\\\": this._hoverHitTargetInterceptorEvents,\\n      \\\"tap\\\": this._tapHitTargetInterceptorEvents,\\n      \\\"mouse\\\": this._mouseHitTargetInterceptorEvents\\n    }[action];\\n    let result;\\n    const listener = (event) => {\\n      if (!events.has(event.type))\\n        return;\\n      if (!event.isTrusted)\\n        return;\\n      const point = !!this.window.TouchEvent && event instanceof this.window.TouchEvent ? event.touches[0] : event;\\n      if (result === void 0 && point)\\n        result = this.expectHitTarget({ x: point.clientX, y: point.clientY }, element);\\n      if (blockAllEvents || result !== \\\"done\\\" && result !== void 0) {\\n        event.preventDefault();\\n        event.stopPropagation();\\n        event.stopImmediatePropagation();\\n      }\\n    };\\n    const stop = () => {\\n      if (this._hitTargetInterceptor === listener)\\n        this._hitTargetInterceptor = void 0;\\n      return result || \\\"done\\\";\\n    };\\n    this._hitTargetInterceptor = listener;\\n    return { stop };\\n  }\\n  dispatchEvent(node, type, eventInitObj) {\\n    var _a, _b, _c, _d, _e;\\n    let event;\\n    const eventInit = { bubbles: true, cancelable: true, composed: true, ...eventInitObj };\\n    switch (this._eventTypes.get(type)) {\\n      case \\\"mouse\\\":\\n        event = new MouseEvent(type, eventInit);\\n        break;\\n      case \\\"keyboard\\\":\\n        event = new KeyboardEvent(type, eventInit);\\n        break;\\n      case \\\"touch\\\": {\\n        if (this._browserName === \\\"webkit\\\") {\\n          const createTouch = (t) => {\\n            var _a2, _b2, _c2;\\n            if (t instanceof Touch)\\n              return t;\\n            let pageX = t.pageX;\\n            if (pageX === void 0 && t.clientX !== void 0)\\n              pageX = t.clientX + (((_a2 = this.document.scrollingElement) == null ? void 0 : _a2.scrollLeft) || 0);\\n            let pageY = t.pageY;\\n            if (pageY === void 0 && t.clientY !== void 0)\\n              pageY = t.clientY + (((_b2 = this.document.scrollingElement) == null ? void 0 : _b2.scrollTop) || 0);\\n            return this.document.createTouch(this.window, (_c2 = t.target) != null ? _c2 : node, t.identifier, pageX, pageY, t.screenX, t.screenY, t.radiusX, t.radiusY, t.rotationAngle, t.force);\\n          };\\n          const createTouchList = (touches) => {\\n            if (touches instanceof TouchList || !touches)\\n              return touches;\\n            return this.document.createTouchList(...touches.map(createTouch));\\n          };\\n          (_a = eventInit.target) != null ? _a : eventInit.target = node;\\n          eventInit.touches = createTouchList(eventInit.touches);\\n          eventInit.targetTouches = createTouchList(eventInit.targetTouches);\\n          eventInit.changedTouches = createTouchList(eventInit.changedTouches);\\n          event = new TouchEvent(type, eventInit);\\n        } else {\\n          (_b = eventInit.target) != null ? _b : eventInit.target = node;\\n          eventInit.touches = (_c = eventInit.touches) == null ? void 0 : _c.map((t) => {\\n            var _a2;\\n            return t instanceof Touch ? t : new Touch({ ...t, target: (_a2 = t.target) != null ? _a2 : node });\\n          });\\n          eventInit.targetTouches = (_d = eventInit.targetTouches) == null ? void 0 : _d.map((t) => {\\n            var _a2;\\n            return t instanceof Touch ? t : new Touch({ ...t, target: (_a2 = t.target) != null ? _a2 : node });\\n          });\\n          eventInit.changedTouches = (_e = eventInit.changedTouches) == null ? void 0 : _e.map((t) => {\\n            var _a2;\\n            return t instanceof Touch ? t : new Touch({ ...t, target: (_a2 = t.target) != null ? _a2 : node });\\n          });\\n          event = new TouchEvent(type, eventInit);\\n        }\\n        break;\\n      }\\n      case \\\"pointer\\\":\\n        event = new PointerEvent(type, eventInit);\\n        break;\\n      case \\\"focus\\\":\\n        event = new FocusEvent(type, eventInit);\\n        break;\\n      case \\\"drag\\\":\\n        event = new DragEvent(type, eventInit);\\n        break;\\n      case \\\"wheel\\\":\\n        event = new WheelEvent(type, eventInit);\\n        break;\\n      case \\\"deviceorientation\\\":\\n        try {\\n          event = new DeviceOrientationEvent(type, eventInit);\\n        } catch {\\n          const { bubbles, cancelable, alpha, beta, gamma, absolute } = eventInit;\\n          event = this.document.createEvent(\\\"DeviceOrientationEvent\\\");\\n          event.initDeviceOrientationEvent(type, bubbles, cancelable, alpha, beta, gamma, absolute);\\n        }\\n        break;\\n      case \\\"devicemotion\\\":\\n        try {\\n          event = new DeviceMotionEvent(type, eventInit);\\n        } catch {\\n          const { bubbles, cancelable, acceleration, accelerationIncludingGravity, rotationRate, interval } = eventInit;\\n          event = this.document.createEvent(\\\"DeviceMotionEvent\\\");\\n          event.initDeviceMotionEvent(type, bubbles, cancelable, acceleration, accelerationIncludingGravity, rotationRate, interval);\\n        }\\n        break;\\n      default:\\n        event = new Event(type, eventInit);\\n        break;\\n    }\\n    node.dispatchEvent(event);\\n  }\\n  previewNode(node) {\\n    if (node.nodeType === Node.TEXT_NODE)\\n      return oneLine(`#text=${node.nodeValue || \\\"\\\"}`);\\n    if (node.nodeType !== Node.ELEMENT_NODE)\\n      return oneLine(`<${node.nodeName.toLowerCase()} />`);\\n    const element = node;\\n    const attrs = [];\\n    for (let i = 0; i < element.attributes.length; i++) {\\n      const { name, value } = element.attributes[i];\\n      if (name === \\\"style\\\")\\n        continue;\\n      if (!value && this._booleanAttributes.has(name))\\n        attrs.push(` ${name}`);\\n      else\\n        attrs.push(` ${name}=\\\"${value}\\\"`);\\n    }\\n    attrs.sort((a, b) => a.length - b.length);\\n    const attrText = trimStringWithEllipsis(attrs.join(\\\"\\\"), 500);\\n    if (this._autoClosingTags.has(element.nodeName))\\n      return oneLine(`<${element.nodeName.toLowerCase()}${attrText}/>`);\\n    const children = element.childNodes;\\n    let onlyText = false;\\n    if (children.length <= 5) {\\n      onlyText = true;\\n      for (let i = 0; i < children.length; i++)\\n        onlyText = onlyText && children[i].nodeType === Node.TEXT_NODE;\\n    }\\n    const text = onlyText ? element.textContent || \\\"\\\" : children.length ? \\\"\\\\u2026\\\" : \\\"\\\";\\n    return oneLine(`<${element.nodeName.toLowerCase()}${attrText}>${trimStringWithEllipsis(text, 50)}</${element.nodeName.toLowerCase()}>`);\\n  }\\n  _generateSelectors(elements) {\\n    this._evaluator.begin();\\n    beginAriaCaches();\\n    beginDOMCaches();\\n    try {\\n      const maxElements = this._isUtilityWorld && this._browserName === \\\"firefox\\\" ? 2 : 10;\\n      const infos = elements.slice(0, maxElements).map((m) => ({\\n        preview: this.previewNode(m),\\n        selector: this.generateSelectorSimple(m)\\n      }));\\n      return infos.map((info, i) => `${i + 1}) ${info.preview} aka ${asLocator(this._sdkLanguage, info.selector)}`);\\n    } finally {\\n      endDOMCaches();\\n      endAriaCaches();\\n      this._evaluator.end();\\n    }\\n  }\\n  strictModeViolationError(selector, matches) {\\n    const lines = this._generateSelectors(matches).map((line) => `\\n    ` + line);\\n    if (lines.length < matches.length)\\n      lines.push(\\\"\\\\n    ...\\\");\\n    return this.createStacklessError(`strict mode violation: ${asLocator(this._sdkLanguage, stringifySelector(selector))} resolved to ${matches.length} elements:${lines.join(\\\"\\\")}\\n`);\\n  }\\n  checkDeprecatedSelectorUsage(selector, matches) {\\n    const kDeprecatedSelectors = /* @__PURE__ */ new Set([\\n      \\\"_react\\\",\\n      \\\"_vue\\\",\\n      \\\"xpath:light\\\",\\n      \\\"text:light\\\",\\n      \\\"id:light\\\",\\n      \\\"data-testid:light\\\",\\n      \\\"data-test-id:light\\\",\\n      \\\"data-test:light\\\"\\n    ]);\\n    if (!matches.length)\\n      return;\\n    const deperecated = selector.parts.find((part) => kDeprecatedSelectors.has(part.name));\\n    if (!deperecated)\\n      return;\\n    const lines = this._generateSelectors(matches).map((line) => `\\n    ` + line);\\n    if (lines.length < matches.length)\\n      lines.push(\\\"\\\\n    ...\\\");\\n    throw this.createStacklessError(`\\\"${deperecated.name}\\\" selector is not supported: ${asLocator(this._sdkLanguage, stringifySelector(selector))} resolved to ${matches.length} element${matches.length === 1 ? \\\"\\\" : \\\"s\\\"}:${lines.join(\\\"\\\")}\\n`);\\n  }\\n  createStacklessError(message) {\\n    if (this._browserName === \\\"firefox\\\") {\\n      const error2 = new Error(\\\"Error: \\\" + message);\\n      error2.stack = \\\"\\\";\\n      return error2;\\n    }\\n    const error = new Error(message);\\n    delete error.stack;\\n    return error;\\n  }\\n  createHighlight() {\\n    return new Highlight(this);\\n  }\\n  maskSelectors(selectors, color) {\\n    if (this._highlight)\\n      this.hideHighlight();\\n    this._highlight = new Highlight(this);\\n    this._highlight.install();\\n    const elements = [];\\n    for (const selector of selectors)\\n      elements.push(this.querySelectorAll(selector, this.document.documentElement));\\n    this._highlight.maskElements(elements.flat(), color);\\n  }\\n  highlight(selector) {\\n    if (!this._highlight) {\\n      this._highlight = new Highlight(this);\\n      this._highlight.install();\\n    }\\n    this._highlight.runHighlightOnRaf(selector);\\n  }\\n  hideHighlight() {\\n    if (this._highlight) {\\n      this._highlight.uninstall();\\n      delete this._highlight;\\n    }\\n  }\\n  markTargetElements(markedElements, callId) {\\n    var _a, _b;\\n    if (((_a = this._markedElements) == null ? void 0 : _a.callId) !== callId)\\n      this._markedElements = void 0;\\n    const previous = ((_b = this._markedElements) == null ? void 0 : _b.elements) || /* @__PURE__ */ new Set();\\n    const unmarkEvent = new CustomEvent(\\\"__playwright_unmark_target__\\\", {\\n      bubbles: true,\\n      cancelable: true,\\n      detail: callId,\\n      composed: true\\n    });\\n    for (const element of previous) {\\n      if (!markedElements.has(element))\\n        element.dispatchEvent(unmarkEvent);\\n    }\\n    const markEvent = new CustomEvent(\\\"__playwright_mark_target__\\\", {\\n      bubbles: true,\\n      cancelable: true,\\n      detail: callId,\\n      composed: true\\n    });\\n    for (const element of markedElements) {\\n      if (!previous.has(element))\\n        element.dispatchEvent(markEvent);\\n    }\\n    this._markedElements = { callId, elements: markedElements };\\n  }\\n  _setupGlobalListenersRemovalDetection() {\\n    const customEventName = \\\"__playwright_global_listeners_check__\\\";\\n    let seenEvent = false;\\n    const handleCustomEvent = () => seenEvent = true;\\n    this.window.addEventListener(customEventName, handleCustomEvent);\\n    new MutationObserver((entries) => {\\n      const newDocumentElement = entries.some((entry) => Array.from(entry.addedNodes).includes(this.document.documentElement));\\n      if (!newDocumentElement)\\n        return;\\n      seenEvent = false;\\n      this.window.dispatchEvent(new CustomEvent(customEventName));\\n      if (seenEvent)\\n        return;\\n      this.window.addEventListener(customEventName, handleCustomEvent);\\n      for (const callback of this.onGlobalListenersRemoved)\\n        callback();\\n    }).observe(this.document, { childList: true });\\n  }\\n  _setupHitTargetInterceptors() {\\n    const listener = (event) => {\\n      var _a;\\n      return (_a = this._hitTargetInterceptor) == null ? void 0 : _a.call(this, event);\\n    };\\n    const addHitTargetInterceptorListeners = () => {\\n      for (const event of this._allHitTargetInterceptorEvents)\\n        this.window.addEventListener(event, listener, { capture: true, passive: false });\\n    };\\n    addHitTargetInterceptorListeners();\\n    this.onGlobalListenersRemoved.add(addHitTargetInterceptorListeners);\\n  }\\n  async expect(element, options, elements) {\\n    var _a, _b;\\n    const isArray = options.expression === \\\"to.have.count\\\" || options.expression.endsWith(\\\".array\\\");\\n    if (isArray)\\n      return this.expectArray(elements, options);\\n    if (!element) {\\n      if (!options.isNot && options.expression === \\\"to.be.hidden\\\")\\n        return { matches: true };\\n      if (options.isNot && options.expression === \\\"to.be.visible\\\")\\n        return { matches: false };\\n      if (!options.isNot && options.expression === \\\"to.be.detached\\\")\\n        return { matches: true };\\n      if (options.isNot && options.expression === \\\"to.be.attached\\\")\\n        return { matches: false };\\n      if (options.isNot && options.expression === \\\"to.be.in.viewport\\\")\\n        return { matches: false };\\n      if (options.expression === \\\"to.have.title\\\" && ((_a = options == null ? void 0 : options.expectedText) == null ? void 0 : _a[0])) {\\n        const matcher = new ExpectedTextMatcher(options.expectedText[0]);\\n        const received = this.document.title;\\n        return { received, matches: matcher.matches(received) };\\n      }\\n      if (options.expression === \\\"to.have.url\\\" && ((_b = options == null ? void 0 : options.expectedText) == null ? void 0 : _b[0])) {\\n        const matcher = new ExpectedTextMatcher(options.expectedText[0]);\\n        const received = this.document.location.href;\\n        return { received, matches: matcher.matches(received) };\\n      }\\n      return { matches: options.isNot, missingReceived: true };\\n    }\\n    return await this.expectSingleElement(element, options);\\n  }\\n  async expectSingleElement(element, options) {\\n    var _a, _b;\\n    const expression = options.expression;\\n    {\\n      let result;\\n      if (expression === \\\"to.have.attribute\\\") {\\n        const hasAttribute = element.hasAttribute(options.expressionArg);\\n        result = {\\n          matches: hasAttribute,\\n          received: hasAttribute ? \\\"attribute present\\\" : \\\"attribute not present\\\"\\n        };\\n      } else if (expression === \\\"to.be.checked\\\") {\\n        const { checked, indeterminate } = options.expectedValue;\\n        if (indeterminate) {\\n          if (checked !== void 0)\\n            throw this.createStacklessError(\\\"Can't assert indeterminate and checked at the same time\\\");\\n          result = this.elementState(element, \\\"indeterminate\\\");\\n        } else {\\n          result = this.elementState(element, checked === false ? \\\"unchecked\\\" : \\\"checked\\\");\\n        }\\n      } else if (expression === \\\"to.be.disabled\\\") {\\n        result = this.elementState(element, \\\"disabled\\\");\\n      } else if (expression === \\\"to.be.editable\\\") {\\n        result = this.elementState(element, \\\"editable\\\");\\n      } else if (expression === \\\"to.be.readonly\\\") {\\n        result = this.elementState(element, \\\"editable\\\");\\n        result.matches = !result.matches;\\n      } else if (expression === \\\"to.be.empty\\\") {\\n        if (element.nodeName === \\\"INPUT\\\" || element.nodeName === \\\"TEXTAREA\\\") {\\n          const value = element.value;\\n          result = { matches: !value, received: value ? \\\"notEmpty\\\" : \\\"empty\\\" };\\n        } else {\\n          const text = (_a = element.textContent) == null ? void 0 : _a.trim();\\n          result = { matches: !text, received: text ? \\\"notEmpty\\\" : \\\"empty\\\" };\\n        }\\n      } else if (expression === \\\"to.be.enabled\\\") {\\n        result = this.elementState(element, \\\"enabled\\\");\\n      } else if (expression === \\\"to.be.focused\\\") {\\n        const focused = this._activelyFocused(element).isFocused;\\n        result = {\\n          matches: focused,\\n          received: focused ? \\\"focused\\\" : \\\"inactive\\\"\\n        };\\n      } else if (expression === \\\"to.be.hidden\\\") {\\n        result = this.elementState(element, \\\"hidden\\\");\\n      } else if (expression === \\\"to.be.visible\\\") {\\n        result = this.elementState(element, \\\"visible\\\");\\n      } else if (expression === \\\"to.be.attached\\\") {\\n        result = {\\n          matches: true,\\n          received: \\\"attached\\\"\\n        };\\n      } else if (expression === \\\"to.be.detached\\\") {\\n        result = {\\n          matches: false,\\n          received: \\\"attached\\\"\\n        };\\n      }\\n      if (result) {\\n        if (result.received === \\\"error:notconnected\\\")\\n          throw this.createStacklessError(\\\"Element is not connected\\\");\\n        return result;\\n      }\\n    }\\n    {\\n      if (expression === \\\"to.have.property\\\") {\\n        let target = element;\\n        const properties = options.expressionArg.split(\\\".\\\");\\n        for (let i = 0; i < properties.length - 1; i++) {\\n          if (typeof target !== \\\"object\\\" || !(properties[i] in target))\\n            return { received: void 0, matches: false };\\n          target = target[properties[i]];\\n        }\\n        const received = target[properties[properties.length - 1]];\\n        const matches = deepEquals(received, options.expectedValue);\\n        return { received, matches };\\n      }\\n    }\\n    {\\n      if (expression === \\\"to.be.in.viewport\\\") {\\n        const ratio = await this.viewportRatio(element);\\n        return { received: `viewport ratio ${ratio}`, matches: ratio > 0 && ratio > ((_b = options.expectedNumber) != null ? _b : 0) - 1e-9 };\\n      }\\n    }\\n    {\\n      if (expression === \\\"to.have.values\\\") {\\n        element = this.retarget(element, \\\"follow-label\\\");\\n        if (element.nodeName !== \\\"SELECT\\\" || !element.multiple)\\n          throw this.createStacklessError(\\\"Not a select element with a multiple attribute\\\");\\n        const received = [...element.selectedOptions].map((o) => o.value);\\n        if (received.length !== options.expectedText.length)\\n          return { received, matches: false };\\n        return { received, matches: received.map((r, i) => new ExpectedTextMatcher(options.expectedText[i]).matches(r)).every(Boolean) };\\n      }\\n    }\\n    {\\n      if (expression === \\\"to.match.aria\\\") {\\n        const result = matchesExpectAriaTemplate(element, options.expectedValue);\\n        return {\\n          received: result.received,\\n          matches: !!result.matches.length\\n        };\\n      }\\n    }\\n    {\\n      let received;\\n      if (expression === \\\"to.have.attribute.value\\\") {\\n        const value = element.getAttribute(options.expressionArg);\\n        if (value === null)\\n          return { received: null, matches: false };\\n        received = value;\\n      } else if ([\\\"to.have.class\\\", \\\"to.contain.class\\\"].includes(expression)) {\\n        if (!options.expectedText)\\n          throw this.createStacklessError(\\\"Expected text is not provided for \\\" + expression);\\n        return {\\n          received: element.classList.toString(),\\n          matches: new ExpectedTextMatcher(options.expectedText[0]).matchesClassList(\\n            this,\\n            element.classList,\\n            /* partial */\\n            expression === \\\"to.contain.class\\\"\\n          )\\n        };\\n      } else if (expression === \\\"to.have.css\\\") {\\n        received = this.window.getComputedStyle(element).getPropertyValue(options.expressionArg);\\n      } else if (expression === \\\"to.have.id\\\") {\\n        received = element.id;\\n      } else if (expression === \\\"to.have.text\\\") {\\n        received = options.useInnerText ? element.innerText : elementText(/* @__PURE__ */ new Map(), element).full;\\n      } else if (expression === \\\"to.have.accessible.name\\\") {\\n        received = getElementAccessibleName(\\n          element,\\n          false\\n          /* includeHidden */\\n        );\\n      } else if (expression === \\\"to.have.accessible.description\\\") {\\n        received = getElementAccessibleDescription(\\n          element,\\n          false\\n          /* includeHidden */\\n        );\\n      } else if (expression === \\\"to.have.accessible.error.message\\\") {\\n        received = getElementAccessibleErrorMessage(element);\\n      } else if (expression === \\\"to.have.role\\\") {\\n        received = getAriaRole(element) || \\\"\\\";\\n      } else if (expression === \\\"to.have.value\\\") {\\n        element = this.retarget(element, \\\"follow-label\\\");\\n        if (element.nodeName !== \\\"INPUT\\\" && element.nodeName !== \\\"TEXTAREA\\\" && element.nodeName !== \\\"SELECT\\\")\\n          throw this.createStacklessError(\\\"Not an input element\\\");\\n        received = element.value;\\n      }\\n      if (received !== void 0 && options.expectedText) {\\n        const matcher = new ExpectedTextMatcher(options.expectedText[0]);\\n        return { received, matches: matcher.matches(received) };\\n      }\\n    }\\n    throw this.createStacklessError(\\\"Unknown expect matcher: \\\" + expression);\\n  }\\n  expectArray(elements, options) {\\n    const expression = options.expression;\\n    if (expression === \\\"to.have.count\\\") {\\n      const received2 = elements.length;\\n      const matches2 = received2 === options.expectedNumber;\\n      return { received: received2, matches: matches2 };\\n    }\\n    if (!options.expectedText)\\n      throw this.createStacklessError(\\\"Expected text is not provided for \\\" + expression);\\n    if ([\\\"to.have.class.array\\\", \\\"to.contain.class.array\\\"].includes(expression)) {\\n      const receivedClassLists = elements.map((e) => e.classList);\\n      const received2 = receivedClassLists.map(String);\\n      if (receivedClassLists.length !== options.expectedText.length)\\n        return { received: received2, matches: false };\\n      const matches2 = this._matchSequentially(\\n        options.expectedText,\\n        receivedClassLists,\\n        (matcher, r) => matcher.matchesClassList(\\n          this,\\n          r,\\n          /* partial */\\n          expression === \\\"to.contain.class.array\\\"\\n        )\\n      );\\n      return {\\n        received: received2,\\n        matches: matches2\\n      };\\n    }\\n    if (![\\\"to.contain.text.array\\\", \\\"to.have.text.array\\\"].includes(expression))\\n      throw this.createStacklessError(\\\"Unknown expect matcher: \\\" + expression);\\n    const received = elements.map((e) => options.useInnerText ? e.innerText : elementText(/* @__PURE__ */ new Map(), e).full);\\n    const lengthShouldMatch = expression !== \\\"to.contain.text.array\\\";\\n    const matchesLength = received.length === options.expectedText.length || !lengthShouldMatch;\\n    if (!matchesLength)\\n      return { received, matches: false };\\n    const matches = this._matchSequentially(options.expectedText, received, (matcher, r) => matcher.matches(r));\\n    return { received, matches };\\n  }\\n  _matchSequentially(expectedText, received, matchFn) {\\n    const matchers = expectedText.map((e) => new ExpectedTextMatcher(e));\\n    let mIndex = 0;\\n    let rIndex = 0;\\n    while (mIndex < matchers.length && rIndex < received.length) {\\n      if (matchFn(matchers[mIndex], received[rIndex]))\\n        ++mIndex;\\n      ++rIndex;\\n    }\\n    return mIndex === matchers.length;\\n  }\\n};\\nfunction oneLine(s) {\\n  return s.replace(/\\\\n/g, \\\"\\\\u21B5\\\").replace(/\\\\t/g, \\\"\\\\u21C6\\\");\\n}\\nfunction cssUnquote(s) {\\n  s = s.substring(1, s.length - 1);\\n  if (!s.includes(\\\"\\\\\\\\\\\"))\\n    return s;\\n  const r = [];\\n  let i = 0;\\n  while (i < s.length) {\\n    if (s[i] === \\\"\\\\\\\\\\\" && i + 1 < s.length)\\n      i++;\\n    r.push(s[i++]);\\n  }\\n  return r.join(\\\"\\\");\\n}\\nfunction createTextMatcher(selector, internal) {\\n  if (selector[0] === \\\"/\\\" && selector.lastIndexOf(\\\"/\\\") > 0) {\\n    const lastSlash = selector.lastIndexOf(\\\"/\\\");\\n    const re = new RegExp(selector.substring(1, lastSlash), selector.substring(lastSlash + 1));\\n    return { matcher: (elementText2) => re.test(elementText2.full), kind: \\\"regex\\\" };\\n  }\\n  const unquote = internal ? JSON.parse.bind(JSON) : cssUnquote;\\n  let strict = false;\\n  if (selector.length > 1 && selector[0] === '\\\"' && selector[selector.length - 1] === '\\\"') {\\n    selector = unquote(selector);\\n    strict = true;\\n  } else if (internal && selector.length > 1 && selector[0] === '\\\"' && selector[selector.length - 2] === '\\\"' && selector[selector.length - 1] === \\\"i\\\") {\\n    selector = unquote(selector.substring(0, selector.length - 1));\\n    strict = false;\\n  } else if (internal && selector.length > 1 && selector[0] === '\\\"' && selector[selector.length - 2] === '\\\"' && selector[selector.length - 1] === \\\"s\\\") {\\n    selector = unquote(selector.substring(0, selector.length - 1));\\n    strict = true;\\n  } else if (selector.length > 1 && selector[0] === \\\"'\\\" && selector[selector.length - 1] === \\\"'\\\") {\\n    selector = unquote(selector);\\n    strict = true;\\n  }\\n  selector = normalizeWhiteSpace(selector);\\n  if (strict) {\\n    if (internal)\\n      return { kind: \\\"strict\\\", matcher: (elementText2) => elementText2.normalized === selector };\\n    const strictTextNodeMatcher = (elementText2) => {\\n      if (!selector && !elementText2.immediate.length)\\n        return true;\\n      return elementText2.immediate.some((s) => normalizeWhiteSpace(s) === selector);\\n    };\\n    return { matcher: strictTextNodeMatcher, kind: \\\"strict\\\" };\\n  }\\n  selector = selector.toLowerCase();\\n  return { kind: \\\"lax\\\", matcher: (elementText2) => elementText2.normalized.toLowerCase().includes(selector) };\\n}\\nvar ExpectedTextMatcher = class {\\n  constructor(expected) {\\n    this._normalizeWhiteSpace = expected.normalizeWhiteSpace;\\n    this._ignoreCase = expected.ignoreCase;\\n    this._string = expected.matchSubstring ? void 0 : this.normalize(expected.string);\\n    this._substring = expected.matchSubstring ? this.normalize(expected.string) : void 0;\\n    if (expected.regexSource) {\\n      const flags = new Set((expected.regexFlags || \\\"\\\").split(\\\"\\\"));\\n      if (expected.ignoreCase === false)\\n        flags.delete(\\\"i\\\");\\n      if (expected.ignoreCase === true)\\n        flags.add(\\\"i\\\");\\n      this._regex = new RegExp(expected.regexSource, [...flags].join(\\\"\\\"));\\n    }\\n  }\\n  matches(text) {\\n    if (!this._regex)\\n      text = this.normalize(text);\\n    if (this._string !== void 0)\\n      return text === this._string;\\n    if (this._substring !== void 0)\\n      return text.includes(this._substring);\\n    if (this._regex)\\n      return !!this._regex.test(text);\\n    return false;\\n  }\\n  matchesClassList(injectedScript, classList, partial) {\\n    if (partial) {\\n      if (this._regex)\\n        throw injectedScript.createStacklessError(\\\"Partial matching does not support regular expressions. Please provide a string value.\\\");\\n      return this._string.split(/\\\\s+/g).filter(Boolean).every((className) => classList.contains(className));\\n    }\\n    return this.matches(classList.toString());\\n  }\\n  normalize(s) {\\n    if (!s)\\n      return s;\\n    if (this._normalizeWhiteSpace)\\n      s = normalizeWhiteSpace(s);\\n    if (this._ignoreCase)\\n      s = s.toLocaleLowerCase();\\n    return s;\\n  }\\n};\\nfunction deepEquals(a, b) {\\n  if (a === b)\\n    return true;\\n  if (a && b && typeof a === \\\"object\\\" && typeof b === \\\"object\\\") {\\n    if (a.constructor !== b.constructor)\\n      return false;\\n    if (Array.isArray(a)) {\\n      if (a.length !== b.length)\\n        return false;\\n      for (let i = 0; i < a.length; ++i) {\\n        if (!deepEquals(a[i], b[i]))\\n          return false;\\n      }\\n      return true;\\n    }\\n    if (a instanceof RegExp)\\n      return a.source === b.source && a.flags === b.flags;\\n    if (a.valueOf !== Object.prototype.valueOf)\\n      return a.valueOf() === b.valueOf();\\n    if (a.toString !== Object.prototype.toString)\\n      return a.toString() === b.toString();\\n    const keys = Object.keys(a);\\n    if (keys.length !== Object.keys(b).length)\\n      return false;\\n    for (let i = 0; i < keys.length; ++i) {\\n      if (!b.hasOwnProperty(keys[i]))\\n        return false;\\n    }\\n    for (const key of keys) {\\n      if (!deepEquals(a[key], b[key]))\\n        return false;\\n    }\\n    return true;\\n  }\\n  if (typeof a === \\\"number\\\" && typeof b === \\\"number\\\")\\n    return isNaN(a) && isNaN(b);\\n  return false;\\n}\\n\";\n//# sourceMappingURL=injectedScriptSource.d.ts.map",
      "generated/storageScriptSource.d.ts": "export declare const source = \"\\nvar __commonJS = obj => {\\n  let required = false;\\n  let result;\\n  return function __require() {\\n    if (!required) {\\n      required = true;\\n      let fn;\\n      for (const name in obj) { fn = obj[name]; break; }\\n      const module = { exports: {} };\\n      fn(module.exports, module);\\n      result = module.exports;\\n    }\\n    return result;\\n  }\\n};\\nvar __export = (target, all) => {for (var name in all) target[name] = all[name];};\\nvar __toESM = mod => ({ ...mod, 'default': mod });\\nvar __toCommonJS = mod => ({ ...mod, __esModule: true });\\n\\n\\n// packages/playwright-injected/src/storageScript.ts\\nvar storageScript_exports = {};\\n__export(storageScript_exports, {\\n  StorageScript: () => StorageScript\\n});\\nmodule.exports = __toCommonJS(storageScript_exports);\\n\\n// packages/playwright-core/src/utils/isomorphic/utilityScriptSerializers.ts\\nfunction isRegExp(obj) {\\n  try {\\n    return obj instanceof RegExp || Object.prototype.toString.call(obj) === \\\"[object RegExp]\\\";\\n  } catch (error) {\\n    return false;\\n  }\\n}\\nfunction isDate(obj) {\\n  try {\\n    return obj instanceof Date || Object.prototype.toString.call(obj) === \\\"[object Date]\\\";\\n  } catch (error) {\\n    return false;\\n  }\\n}\\nfunction isURL(obj) {\\n  try {\\n    return obj instanceof URL || Object.prototype.toString.call(obj) === \\\"[object URL]\\\";\\n  } catch (error) {\\n    return false;\\n  }\\n}\\nfunction isError(obj) {\\n  var _a;\\n  try {\\n    return obj instanceof Error || obj && ((_a = Object.getPrototypeOf(obj)) == null ? void 0 : _a.name) === \\\"Error\\\";\\n  } catch (error) {\\n    return false;\\n  }\\n}\\nfunction isTypedArray(obj, constructor) {\\n  try {\\n    return obj instanceof constructor || Object.prototype.toString.call(obj) === `[object ${constructor.name}]`;\\n  } catch (error) {\\n    return false;\\n  }\\n}\\nvar typedArrayConstructors = {\\n  i8: Int8Array,\\n  ui8: Uint8Array,\\n  ui8c: Uint8ClampedArray,\\n  i16: Int16Array,\\n  ui16: Uint16Array,\\n  i32: Int32Array,\\n  ui32: Uint32Array,\\n  // TODO: add Float16Array once it's in baseline\\n  f32: Float32Array,\\n  f64: Float64Array,\\n  bi64: BigInt64Array,\\n  bui64: BigUint64Array\\n};\\nfunction typedArrayToBase64(array) {\\n  if (\\\"toBase64\\\" in array)\\n    return array.toBase64();\\n  const binary = Array.from(new Uint8Array(array.buffer, array.byteOffset, array.byteLength)).map((b) => String.fromCharCode(b)).join(\\\"\\\");\\n  return btoa(binary);\\n}\\nfunction base64ToTypedArray(base64, TypedArrayConstructor) {\\n  const binary = atob(base64);\\n  const bytes = new Uint8Array(binary.length);\\n  for (let i = 0; i < binary.length; i++)\\n    bytes[i] = binary.charCodeAt(i);\\n  return new TypedArrayConstructor(bytes.buffer);\\n}\\nfunction parseEvaluationResultValue(value, handles = [], refs = /* @__PURE__ */ new Map()) {\\n  if (Object.is(value, void 0))\\n    return void 0;\\n  if (typeof value === \\\"object\\\" && value) {\\n    if (\\\"ref\\\" in value)\\n      return refs.get(value.ref);\\n    if (\\\"v\\\" in value) {\\n      if (value.v === \\\"undefined\\\")\\n        return void 0;\\n      if (value.v === \\\"null\\\")\\n        return null;\\n      if (value.v === \\\"NaN\\\")\\n        return NaN;\\n      if (value.v === \\\"Infinity\\\")\\n        return Infinity;\\n      if (value.v === \\\"-Infinity\\\")\\n        return -Infinity;\\n      if (value.v === \\\"-0\\\")\\n        return -0;\\n      return void 0;\\n    }\\n    if (\\\"d\\\" in value) {\\n      return new Date(value.d);\\n    }\\n    if (\\\"u\\\" in value)\\n      return new URL(value.u);\\n    if (\\\"bi\\\" in value)\\n      return BigInt(value.bi);\\n    if (\\\"e\\\" in value) {\\n      const error = new Error(value.e.m);\\n      error.name = value.e.n;\\n      error.stack = value.e.s;\\n      return error;\\n    }\\n    if (\\\"r\\\" in value)\\n      return new RegExp(value.r.p, value.r.f);\\n    if (\\\"a\\\" in value) {\\n      const result = [];\\n      refs.set(value.id, result);\\n      for (const a of value.a)\\n        result.push(parseEvaluationResultValue(a, handles, refs));\\n      return result;\\n    }\\n    if (\\\"o\\\" in value) {\\n      const result = {};\\n      refs.set(value.id, result);\\n      for (const { k, v } of value.o) {\\n        if (k === \\\"__proto__\\\")\\n          continue;\\n        result[k] = parseEvaluationResultValue(v, handles, refs);\\n      }\\n      return result;\\n    }\\n    if (\\\"h\\\" in value)\\n      return handles[value.h];\\n    if (\\\"ta\\\" in value)\\n      return base64ToTypedArray(value.ta.b, typedArrayConstructors[value.ta.k]);\\n  }\\n  return value;\\n}\\nfunction serializeAsCallArgument(value, handleSerializer) {\\n  return serialize(value, handleSerializer, { visited: /* @__PURE__ */ new Map(), lastId: 0 });\\n}\\nfunction serialize(value, handleSerializer, visitorInfo) {\\n  if (value && typeof value === \\\"object\\\") {\\n    if (typeof globalThis.Window === \\\"function\\\" && value instanceof globalThis.Window)\\n      return \\\"ref: <Window>\\\";\\n    if (typeof globalThis.Document === \\\"function\\\" && value instanceof globalThis.Document)\\n      return \\\"ref: <Document>\\\";\\n    if (typeof globalThis.Node === \\\"function\\\" && value instanceof globalThis.Node)\\n      return \\\"ref: <Node>\\\";\\n  }\\n  return innerSerialize(value, handleSerializer, visitorInfo);\\n}\\nfunction innerSerialize(value, handleSerializer, visitorInfo) {\\n  var _a;\\n  const result = handleSerializer(value);\\n  if (\\\"fallThrough\\\" in result)\\n    value = result.fallThrough;\\n  else\\n    return result;\\n  if (typeof value === \\\"symbol\\\")\\n    return { v: \\\"undefined\\\" };\\n  if (Object.is(value, void 0))\\n    return { v: \\\"undefined\\\" };\\n  if (Object.is(value, null))\\n    return { v: \\\"null\\\" };\\n  if (Object.is(value, NaN))\\n    return { v: \\\"NaN\\\" };\\n  if (Object.is(value, Infinity))\\n    return { v: \\\"Infinity\\\" };\\n  if (Object.is(value, -Infinity))\\n    return { v: \\\"-Infinity\\\" };\\n  if (Object.is(value, -0))\\n    return { v: \\\"-0\\\" };\\n  if (typeof value === \\\"boolean\\\")\\n    return value;\\n  if (typeof value === \\\"number\\\")\\n    return value;\\n  if (typeof value === \\\"string\\\")\\n    return value;\\n  if (typeof value === \\\"bigint\\\")\\n    return { bi: value.toString() };\\n  if (isError(value)) {\\n    let stack;\\n    if ((_a = value.stack) == null ? void 0 : _a.startsWith(value.name + \\\": \\\" + value.message)) {\\n      stack = value.stack;\\n    } else {\\n      stack = `${value.name}: ${value.message}\\n${value.stack}`;\\n    }\\n    return { e: { n: value.name, m: value.message, s: stack } };\\n  }\\n  if (isDate(value))\\n    return { d: value.toJSON() };\\n  if (isURL(value))\\n    return { u: value.toJSON() };\\n  if (isRegExp(value))\\n    return { r: { p: value.source, f: value.flags } };\\n  for (const [k, ctor] of Object.entries(typedArrayConstructors)) {\\n    if (isTypedArray(value, ctor))\\n      return { ta: { b: typedArrayToBase64(value), k } };\\n  }\\n  const id = visitorInfo.visited.get(value);\\n  if (id)\\n    return { ref: id };\\n  if (Array.isArray(value)) {\\n    const a = [];\\n    const id2 = ++visitorInfo.lastId;\\n    visitorInfo.visited.set(value, id2);\\n    for (let i = 0; i < value.length; ++i)\\n      a.push(serialize(value[i], handleSerializer, visitorInfo));\\n    return { a, id: id2 };\\n  }\\n  if (typeof value === \\\"object\\\") {\\n    const o = [];\\n    const id2 = ++visitorInfo.lastId;\\n    visitorInfo.visited.set(value, id2);\\n    for (const name of Object.keys(value)) {\\n      let item;\\n      try {\\n        item = value[name];\\n      } catch (e) {\\n        continue;\\n      }\\n      if (name === \\\"toJSON\\\" && typeof item === \\\"function\\\")\\n        o.push({ k: name, v: { o: [], id: 0 } });\\n      else\\n        o.push({ k: name, v: serialize(item, handleSerializer, visitorInfo) });\\n    }\\n    let jsonWrapper;\\n    try {\\n      if (o.length === 0 && value.toJSON && typeof value.toJSON === \\\"function\\\")\\n        jsonWrapper = { value: value.toJSON() };\\n    } catch (e) {\\n    }\\n    if (jsonWrapper)\\n      return innerSerialize(jsonWrapper.value, handleSerializer, visitorInfo);\\n    return { o, id: id2 };\\n  }\\n}\\n\\n// packages/playwright-injected/src/storageScript.ts\\nvar StorageScript = class {\\n  constructor(isFirefox) {\\n    this._isFirefox = isFirefox;\\n    this._global = globalThis;\\n  }\\n  _idbRequestToPromise(request) {\\n    return new Promise((resolve, reject) => {\\n      request.addEventListener(\\\"success\\\", () => resolve(request.result));\\n      request.addEventListener(\\\"error\\\", () => reject(request.error));\\n    });\\n  }\\n  _isPlainObject(v) {\\n    const ctor = v == null ? void 0 : v.constructor;\\n    if (this._isFirefox) {\\n      const constructorImpl = ctor == null ? void 0 : ctor.toString();\\n      if ((constructorImpl == null ? void 0 : constructorImpl.startsWith(\\\"function Object() {\\\")) && (constructorImpl == null ? void 0 : constructorImpl.includes(\\\"[native code]\\\")))\\n        return true;\\n    }\\n    return ctor === Object;\\n  }\\n  _trySerialize(value) {\\n    let trivial = true;\\n    const encoded = serializeAsCallArgument(value, (v) => {\\n      const isTrivial = this._isPlainObject(v) || Array.isArray(v) || typeof v === \\\"string\\\" || typeof v === \\\"number\\\" || typeof v === \\\"boolean\\\" || Object.is(v, null);\\n      if (!isTrivial)\\n        trivial = false;\\n      return { fallThrough: v };\\n    });\\n    if (trivial)\\n      return { trivial: value };\\n    return { encoded };\\n  }\\n  async _collectDB(dbInfo) {\\n    if (!dbInfo.name)\\n      throw new Error(\\\"Database name is empty\\\");\\n    if (!dbInfo.version)\\n      throw new Error(\\\"Database version is unset\\\");\\n    const db = await this._idbRequestToPromise(indexedDB.open(dbInfo.name));\\n    if (db.objectStoreNames.length === 0)\\n      return { name: dbInfo.name, version: dbInfo.version, stores: [] };\\n    const transaction = db.transaction(db.objectStoreNames, \\\"readonly\\\");\\n    const stores = await Promise.all([...db.objectStoreNames].map(async (storeName) => {\\n      const objectStore = transaction.objectStore(storeName);\\n      const keys = await this._idbRequestToPromise(objectStore.getAllKeys());\\n      const records = await Promise.all(keys.map(async (key) => {\\n        const record = {};\\n        if (objectStore.keyPath === null) {\\n          const { encoded: encoded2, trivial: trivial2 } = this._trySerialize(key);\\n          if (trivial2)\\n            record.key = trivial2;\\n          else\\n            record.keyEncoded = encoded2;\\n        }\\n        const value = await this._idbRequestToPromise(objectStore.get(key));\\n        const { encoded, trivial } = this._trySerialize(value);\\n        if (trivial)\\n          record.value = trivial;\\n        else\\n          record.valueEncoded = encoded;\\n        return record;\\n      }));\\n      const indexes = [...objectStore.indexNames].map((indexName) => {\\n        const index = objectStore.index(indexName);\\n        return {\\n          name: index.name,\\n          keyPath: typeof index.keyPath === \\\"string\\\" ? index.keyPath : void 0,\\n          keyPathArray: Array.isArray(index.keyPath) ? index.keyPath : void 0,\\n          multiEntry: index.multiEntry,\\n          unique: index.unique\\n        };\\n      });\\n      return {\\n        name: storeName,\\n        records,\\n        indexes,\\n        autoIncrement: objectStore.autoIncrement,\\n        keyPath: typeof objectStore.keyPath === \\\"string\\\" ? objectStore.keyPath : void 0,\\n        keyPathArray: Array.isArray(objectStore.keyPath) ? objectStore.keyPath : void 0\\n      };\\n    }));\\n    return {\\n      name: dbInfo.name,\\n      version: dbInfo.version,\\n      stores\\n    };\\n  }\\n  async collect(recordIndexedDB) {\\n    const localStorage = Object.keys(this._global.localStorage).map((name) => ({ name, value: this._global.localStorage.getItem(name) }));\\n    if (!recordIndexedDB)\\n      return { localStorage };\\n    try {\\n      const databases = await this._global.indexedDB.databases();\\n      const indexedDB2 = await Promise.all(databases.map((db) => this._collectDB(db)));\\n      return { localStorage, indexedDB: indexedDB2 };\\n    } catch (e) {\\n      throw new Error(\\\"Unable to serialize IndexedDB: \\\" + e.message);\\n    }\\n  }\\n  async _restoreDB(dbInfo) {\\n    const openRequest = this._global.indexedDB.open(dbInfo.name, dbInfo.version);\\n    openRequest.addEventListener(\\\"upgradeneeded\\\", () => {\\n      var _a, _b;\\n      const db2 = openRequest.result;\\n      for (const store of dbInfo.stores) {\\n        const objectStore = db2.createObjectStore(store.name, { autoIncrement: store.autoIncrement, keyPath: (_a = store.keyPathArray) != null ? _a : store.keyPath });\\n        for (const index of store.indexes)\\n          objectStore.createIndex(index.name, (_b = index.keyPathArray) != null ? _b : index.keyPath, { unique: index.unique, multiEntry: index.multiEntry });\\n      }\\n    });\\n    const db = await this._idbRequestToPromise(openRequest);\\n    if (db.objectStoreNames.length === 0)\\n      return;\\n    const transaction = db.transaction(db.objectStoreNames, \\\"readwrite\\\");\\n    await Promise.all(dbInfo.stores.map(async (store) => {\\n      const objectStore = transaction.objectStore(store.name);\\n      await Promise.all(store.records.map(async (record) => {\\n        var _a, _b;\\n        await this._idbRequestToPromise(\\n          objectStore.add(\\n            (_a = record.value) != null ? _a : parseEvaluationResultValue(record.valueEncoded),\\n            (_b = record.key) != null ? _b : parseEvaluationResultValue(record.keyEncoded)\\n          )\\n        );\\n      }));\\n    }));\\n  }\\n  async restore(originState) {\\n    var _a, _b, _c;\\n    const registrations = this._global.navigator.serviceWorker ? await this._global.navigator.serviceWorker.getRegistrations() : [];\\n    await Promise.all(registrations.map(async (r) => {\\n      if (!r.installing && !r.waiting && !r.active)\\n        r.unregister().catch(() => {\\n        });\\n      else\\n        await r.unregister().catch(() => {\\n        });\\n    }));\\n    try {\\n      for (const db of await ((_b = (_a = this._global.indexedDB).databases) == null ? void 0 : _b.call(_a)) || []) {\\n        if (db.name)\\n          this._global.indexedDB.deleteDatabase(db.name);\\n      }\\n      await Promise.all(((_c = originState == null ? void 0 : originState.indexedDB) != null ? _c : []).map((dbInfo) => this._restoreDB(dbInfo)));\\n    } catch (e) {\\n      throw new Error(\\\"Unable to restore IndexedDB: \\\" + e.message);\\n    }\\n    this._global.sessionStorage.clear();\\n    this._global.localStorage.clear();\\n    for (const { name, value } of (originState == null ? void 0 : originState.localStorage) || [])\\n      this._global.localStorage.setItem(name, value);\\n  }\\n};\\n\";\n//# sourceMappingURL=storageScriptSource.d.ts.map",
      "generated/utilityScriptSource.d.ts": "export declare const source = \"\\nvar __commonJS = obj => {\\n  let required = false;\\n  let result;\\n  return function __require() {\\n    if (!required) {\\n      required = true;\\n      let fn;\\n      for (const name in obj) { fn = obj[name]; break; }\\n      const module = { exports: {} };\\n      fn(module.exports, module);\\n      result = module.exports;\\n    }\\n    return result;\\n  }\\n};\\nvar __export = (target, all) => {for (var name in all) target[name] = all[name];};\\nvar __toESM = mod => ({ ...mod, 'default': mod });\\nvar __toCommonJS = mod => ({ ...mod, __esModule: true });\\n\\n\\n// packages/playwright-injected/src/utilityScript.ts\\nvar utilityScript_exports = {};\\n__export(utilityScript_exports, {\\n  UtilityScript: () => UtilityScript\\n});\\nmodule.exports = __toCommonJS(utilityScript_exports);\\n\\n// packages/playwright-core/src/utils/isomorphic/utilityScriptSerializers.ts\\nfunction isRegExp(obj) {\\n  try {\\n    return obj instanceof RegExp || Object.prototype.toString.call(obj) === \\\"[object RegExp]\\\";\\n  } catch (error) {\\n    return false;\\n  }\\n}\\nfunction isDate(obj) {\\n  try {\\n    return obj instanceof Date || Object.prototype.toString.call(obj) === \\\"[object Date]\\\";\\n  } catch (error) {\\n    return false;\\n  }\\n}\\nfunction isURL(obj) {\\n  try {\\n    return obj instanceof URL || Object.prototype.toString.call(obj) === \\\"[object URL]\\\";\\n  } catch (error) {\\n    return false;\\n  }\\n}\\nfunction isError(obj) {\\n  var _a;\\n  try {\\n    return obj instanceof Error || obj && ((_a = Object.getPrototypeOf(obj)) == null ? void 0 : _a.name) === \\\"Error\\\";\\n  } catch (error) {\\n    return false;\\n  }\\n}\\nfunction isTypedArray(obj, constructor) {\\n  try {\\n    return obj instanceof constructor || Object.prototype.toString.call(obj) === `[object ${constructor.name}]`;\\n  } catch (error) {\\n    return false;\\n  }\\n}\\nvar typedArrayConstructors = {\\n  i8: Int8Array,\\n  ui8: Uint8Array,\\n  ui8c: Uint8ClampedArray,\\n  i16: Int16Array,\\n  ui16: Uint16Array,\\n  i32: Int32Array,\\n  ui32: Uint32Array,\\n  // TODO: add Float16Array once it's in baseline\\n  f32: Float32Array,\\n  f64: Float64Array,\\n  bi64: BigInt64Array,\\n  bui64: BigUint64Array\\n};\\nfunction typedArrayToBase64(array) {\\n  if (\\\"toBase64\\\" in array)\\n    return array.toBase64();\\n  const binary = Array.from(new Uint8Array(array.buffer, array.byteOffset, array.byteLength)).map((b) => String.fromCharCode(b)).join(\\\"\\\");\\n  return btoa(binary);\\n}\\nfunction base64ToTypedArray(base64, TypedArrayConstructor) {\\n  const binary = atob(base64);\\n  const bytes = new Uint8Array(binary.length);\\n  for (let i = 0; i < binary.length; i++)\\n    bytes[i] = binary.charCodeAt(i);\\n  return new TypedArrayConstructor(bytes.buffer);\\n}\\nfunction parseEvaluationResultValue(value, handles = [], refs = /* @__PURE__ */ new Map()) {\\n  if (Object.is(value, void 0))\\n    return void 0;\\n  if (typeof value === \\\"object\\\" && value) {\\n    if (\\\"ref\\\" in value)\\n      return refs.get(value.ref);\\n    if (\\\"v\\\" in value) {\\n      if (value.v === \\\"undefined\\\")\\n        return void 0;\\n      if (value.v === \\\"null\\\")\\n        return null;\\n      if (value.v === \\\"NaN\\\")\\n        return NaN;\\n      if (value.v === \\\"Infinity\\\")\\n        return Infinity;\\n      if (value.v === \\\"-Infinity\\\")\\n        return -Infinity;\\n      if (value.v === \\\"-0\\\")\\n        return -0;\\n      return void 0;\\n    }\\n    if (\\\"d\\\" in value) {\\n      return new Date(value.d);\\n    }\\n    if (\\\"u\\\" in value)\\n      return new URL(value.u);\\n    if (\\\"bi\\\" in value)\\n      return BigInt(value.bi);\\n    if (\\\"e\\\" in value) {\\n      const error = new Error(value.e.m);\\n      error.name = value.e.n;\\n      error.stack = value.e.s;\\n      return error;\\n    }\\n    if (\\\"r\\\" in value)\\n      return new RegExp(value.r.p, value.r.f);\\n    if (\\\"a\\\" in value) {\\n      const result = [];\\n      refs.set(value.id, result);\\n      for (const a of value.a)\\n        result.push(parseEvaluationResultValue(a, handles, refs));\\n      return result;\\n    }\\n    if (\\\"o\\\" in value) {\\n      const result = {};\\n      refs.set(value.id, result);\\n      for (const { k, v } of value.o) {\\n        if (k === \\\"__proto__\\\")\\n          continue;\\n        result[k] = parseEvaluationResultValue(v, handles, refs);\\n      }\\n      return result;\\n    }\\n    if (\\\"h\\\" in value)\\n      return handles[value.h];\\n    if (\\\"ta\\\" in value)\\n      return base64ToTypedArray(value.ta.b, typedArrayConstructors[value.ta.k]);\\n  }\\n  return value;\\n}\\nfunction serializeAsCallArgument(value, handleSerializer) {\\n  return serialize(value, handleSerializer, { visited: /* @__PURE__ */ new Map(), lastId: 0 });\\n}\\nfunction serialize(value, handleSerializer, visitorInfo) {\\n  if (value && typeof value === \\\"object\\\") {\\n    if (typeof globalThis.Window === \\\"function\\\" && value instanceof globalThis.Window)\\n      return \\\"ref: <Window>\\\";\\n    if (typeof globalThis.Document === \\\"function\\\" && value instanceof globalThis.Document)\\n      return \\\"ref: <Document>\\\";\\n    if (typeof globalThis.Node === \\\"function\\\" && value instanceof globalThis.Node)\\n      return \\\"ref: <Node>\\\";\\n  }\\n  return innerSerialize(value, handleSerializer, visitorInfo);\\n}\\nfunction innerSerialize(value, handleSerializer, visitorInfo) {\\n  var _a;\\n  const result = handleSerializer(value);\\n  if (\\\"fallThrough\\\" in result)\\n    value = result.fallThrough;\\n  else\\n    return result;\\n  if (typeof value === \\\"symbol\\\")\\n    return { v: \\\"undefined\\\" };\\n  if (Object.is(value, void 0))\\n    return { v: \\\"undefined\\\" };\\n  if (Object.is(value, null))\\n    return { v: \\\"null\\\" };\\n  if (Object.is(value, NaN))\\n    return { v: \\\"NaN\\\" };\\n  if (Object.is(value, Infinity))\\n    return { v: \\\"Infinity\\\" };\\n  if (Object.is(value, -Infinity))\\n    return { v: \\\"-Infinity\\\" };\\n  if (Object.is(value, -0))\\n    return { v: \\\"-0\\\" };\\n  if (typeof value === \\\"boolean\\\")\\n    return value;\\n  if (typeof value === \\\"number\\\")\\n    return value;\\n  if (typeof value === \\\"string\\\")\\n    return value;\\n  if (typeof value === \\\"bigint\\\")\\n    return { bi: value.toString() };\\n  if (isError(value)) {\\n    let stack;\\n    if ((_a = value.stack) == null ? void 0 : _a.startsWith(value.name + \\\": \\\" + value.message)) {\\n      stack = value.stack;\\n    } else {\\n      stack = `${value.name}: ${value.message}\\n${value.stack}`;\\n    }\\n    return { e: { n: value.name, m: value.message, s: stack } };\\n  }\\n  if (isDate(value))\\n    return { d: value.toJSON() };\\n  if (isURL(value))\\n    return { u: value.toJSON() };\\n  if (isRegExp(value))\\n    return { r: { p: value.source, f: value.flags } };\\n  for (const [k, ctor] of Object.entries(typedArrayConstructors)) {\\n    if (isTypedArray(value, ctor))\\n      return { ta: { b: typedArrayToBase64(value), k } };\\n  }\\n  const id = visitorInfo.visited.get(value);\\n  if (id)\\n    return { ref: id };\\n  if (Array.isArray(value)) {\\n    const a = [];\\n    const id2 = ++visitorInfo.lastId;\\n    visitorInfo.visited.set(value, id2);\\n    for (let i = 0; i < value.length; ++i)\\n      a.push(serialize(value[i], handleSerializer, visitorInfo));\\n    return { a, id: id2 };\\n  }\\n  if (typeof value === \\\"object\\\") {\\n    const o = [];\\n    const id2 = ++visitorInfo.lastId;\\n    visitorInfo.visited.set(value, id2);\\n    for (const name of Object.keys(value)) {\\n      let item;\\n      try {\\n        item = value[name];\\n      } catch (e) {\\n        continue;\\n      }\\n      if (name === \\\"toJSON\\\" && typeof item === \\\"function\\\")\\n        o.push({ k: name, v: { o: [], id: 0 } });\\n      else\\n        o.push({ k: name, v: serialize(item, handleSerializer, visitorInfo) });\\n    }\\n    let jsonWrapper;\\n    try {\\n      if (o.length === 0 && value.toJSON && typeof value.toJSON === \\\"function\\\")\\n        jsonWrapper = { value: value.toJSON() };\\n    } catch (e) {\\n    }\\n    if (jsonWrapper)\\n      return innerSerialize(jsonWrapper.value, handleSerializer, visitorInfo);\\n    return { o, id: id2 };\\n  }\\n}\\n\\n// packages/playwright-injected/src/utilityScript.ts\\nvar UtilityScript = class {\\n  constructor(global, isUnderTest) {\\n    var _a, _b, _c, _d, _e, _f, _g, _h;\\n    this.global = global;\\n    this.isUnderTest = isUnderTest;\\n    if (global.__pwClock) {\\n      this.builtins = global.__pwClock.builtins;\\n    } else {\\n      this.builtins = {\\n        setTimeout: (_a = global.setTimeout) == null ? void 0 : _a.bind(global),\\n        clearTimeout: (_b = global.clearTimeout) == null ? void 0 : _b.bind(global),\\n        setInterval: (_c = global.setInterval) == null ? void 0 : _c.bind(global),\\n        clearInterval: (_d = global.clearInterval) == null ? void 0 : _d.bind(global),\\n        requestAnimationFrame: (_e = global.requestAnimationFrame) == null ? void 0 : _e.bind(global),\\n        cancelAnimationFrame: (_f = global.cancelAnimationFrame) == null ? void 0 : _f.bind(global),\\n        requestIdleCallback: (_g = global.requestIdleCallback) == null ? void 0 : _g.bind(global),\\n        cancelIdleCallback: (_h = global.cancelIdleCallback) == null ? void 0 : _h.bind(global),\\n        performance: global.performance,\\n        Intl: global.Intl,\\n        Date: global.Date\\n      };\\n    }\\n    if (this.isUnderTest)\\n      global.builtins = this.builtins;\\n  }\\n  evaluate(isFunction, returnByValue, expression, argCount, ...argsAndHandles) {\\n    const args = argsAndHandles.slice(0, argCount);\\n    const handles = argsAndHandles.slice(argCount);\\n    const parameters = [];\\n    for (let i = 0; i < args.length; i++)\\n      parameters[i] = parseEvaluationResultValue(args[i], handles);\\n    let result = this.global.eval(expression);\\n    if (isFunction === true) {\\n      result = result(...parameters);\\n    } else if (isFunction === false) {\\n      result = result;\\n    } else {\\n      if (typeof result === \\\"function\\\")\\n        result = result(...parameters);\\n    }\\n    return returnByValue ? this._promiseAwareJsonValueNoThrow(result) : result;\\n  }\\n  jsonValue(returnByValue, value) {\\n    if (value === void 0)\\n      return void 0;\\n    return serializeAsCallArgument(value, (value2) => ({ fallThrough: value2 }));\\n  }\\n  _promiseAwareJsonValueNoThrow(value) {\\n    const safeJson = (value2) => {\\n      try {\\n        return this.jsonValue(true, value2);\\n      } catch (e) {\\n        return void 0;\\n      }\\n    };\\n    if (value && typeof value === \\\"object\\\" && typeof value.then === \\\"function\\\") {\\n      return (async () => {\\n        const promiseValue = await value;\\n        return safeJson(promiseValue);\\n      })();\\n    }\\n    return safeJson(value);\\n  }\\n};\\n\";\n//# sourceMappingURL=utilityScriptSource.d.ts.map",
      "generated/webSocketMockSource.d.ts": "export declare const source = \"\\nvar __commonJS = obj => {\\n  let required = false;\\n  let result;\\n  return function __require() {\\n    if (!required) {\\n      required = true;\\n      let fn;\\n      for (const name in obj) { fn = obj[name]; break; }\\n      const module = { exports: {} };\\n      fn(module.exports, module);\\n      result = module.exports;\\n    }\\n    return result;\\n  }\\n};\\nvar __export = (target, all) => {for (var name in all) target[name] = all[name];};\\nvar __toESM = mod => ({ ...mod, 'default': mod });\\nvar __toCommonJS = mod => ({ ...mod, __esModule: true });\\n\\n\\n// packages/playwright-injected/src/webSocketMock.ts\\nvar webSocketMock_exports = {};\\n__export(webSocketMock_exports, {\\n  inject: () => inject\\n});\\nmodule.exports = __toCommonJS(webSocketMock_exports);\\nfunction inject(globalThis) {\\n  if (globalThis.__pwWebSocketDispatch)\\n    return;\\n  function generateId() {\\n    const bytes = new Uint8Array(32);\\n    globalThis.crypto.getRandomValues(bytes);\\n    const hex = \\\"0123456789abcdef\\\";\\n    return [...bytes].map((value) => {\\n      const high = Math.floor(value / 16);\\n      const low = value % 16;\\n      return hex[high] + hex[low];\\n    }).join(\\\"\\\");\\n  }\\n  function bufferToData(b) {\\n    let s = \\\"\\\";\\n    for (let i = 0; i < b.length; i++)\\n      s += String.fromCharCode(b[i]);\\n    return { data: globalThis.btoa(s), isBase64: true };\\n  }\\n  function stringToBuffer(s) {\\n    s = globalThis.atob(s);\\n    const b = new Uint8Array(s.length);\\n    for (let i = 0; i < s.length; i++)\\n      b[i] = s.charCodeAt(i);\\n    return b.buffer;\\n  }\\n  function messageToData(message, cb) {\\n    if (message instanceof globalThis.Blob)\\n      return message.arrayBuffer().then((buffer) => cb(bufferToData(new Uint8Array(buffer))));\\n    if (typeof message === \\\"string\\\")\\n      return cb({ data: message, isBase64: false });\\n    if (ArrayBuffer.isView(message))\\n      return cb(bufferToData(new Uint8Array(message.buffer, message.byteOffset, message.byteLength)));\\n    return cb(bufferToData(new Uint8Array(message)));\\n  }\\n  function dataToMessage(data, binaryType) {\\n    if (!data.isBase64)\\n      return data.data;\\n    const buffer = stringToBuffer(data.data);\\n    return binaryType === \\\"arraybuffer\\\" ? buffer : new Blob([buffer]);\\n  }\\n  const binding = globalThis.__pwWebSocketBinding;\\n  const NativeWebSocket = globalThis.WebSocket;\\n  const idToWebSocket = /* @__PURE__ */ new Map();\\n  globalThis.__pwWebSocketDispatch = (request) => {\\n    const ws = idToWebSocket.get(request.id);\\n    if (!ws)\\n      return;\\n    if (request.type === \\\"connect\\\")\\n      ws._apiConnect();\\n    if (request.type === \\\"passthrough\\\")\\n      ws._apiPassThrough();\\n    if (request.type === \\\"ensureOpened\\\")\\n      ws._apiEnsureOpened();\\n    if (request.type === \\\"sendToPage\\\")\\n      ws._apiSendToPage(dataToMessage(request.data, ws.binaryType));\\n    if (request.type === \\\"closePage\\\")\\n      ws._apiClosePage(request.code, request.reason, request.wasClean);\\n    if (request.type === \\\"sendToServer\\\")\\n      ws._apiSendToServer(dataToMessage(request.data, ws.binaryType));\\n    if (request.type === \\\"closeServer\\\")\\n      ws._apiCloseServer(request.code, request.reason, request.wasClean);\\n  };\\n  const _WebSocketMock = class _WebSocketMock extends EventTarget {\\n    constructor(url, protocols) {\\n      var _a, _b;\\n      super();\\n      // WebSocket.CLOSED\\n      this.CONNECTING = 0;\\n      // WebSocket.CONNECTING\\n      this.OPEN = 1;\\n      // WebSocket.OPEN\\n      this.CLOSING = 2;\\n      // WebSocket.CLOSING\\n      this.CLOSED = 3;\\n      // WebSocket.CLOSED\\n      this._oncloseListener = null;\\n      this._onerrorListener = null;\\n      this._onmessageListener = null;\\n      this._onopenListener = null;\\n      this.bufferedAmount = 0;\\n      this.extensions = \\\"\\\";\\n      this.protocol = \\\"\\\";\\n      this.readyState = 0;\\n      this._origin = \\\"\\\";\\n      this._passthrough = false;\\n      this._wsBufferedMessages = [];\\n      this._binaryType = \\\"blob\\\";\\n      this.url = new URL(url, globalThis.window.document.baseURI).href.replace(/^http/, \\\"ws\\\");\\n      this._origin = (_b = (_a = URL.parse(this.url)) == null ? void 0 : _a.origin) != null ? _b : \\\"\\\";\\n      this._protocols = protocols;\\n      this._id = generateId();\\n      idToWebSocket.set(this._id, this);\\n      binding({ type: \\\"onCreate\\\", id: this._id, url: this.url });\\n    }\\n    // --- native WebSocket implementation ---\\n    get binaryType() {\\n      return this._binaryType;\\n    }\\n    set binaryType(type) {\\n      this._binaryType = type;\\n      if (this._ws)\\n        this._ws.binaryType = type;\\n    }\\n    get onclose() {\\n      return this._oncloseListener;\\n    }\\n    set onclose(listener) {\\n      if (this._oncloseListener)\\n        this.removeEventListener(\\\"close\\\", this._oncloseListener);\\n      this._oncloseListener = listener;\\n      if (this._oncloseListener)\\n        this.addEventListener(\\\"close\\\", this._oncloseListener);\\n    }\\n    get onerror() {\\n      return this._onerrorListener;\\n    }\\n    set onerror(listener) {\\n      if (this._onerrorListener)\\n        this.removeEventListener(\\\"error\\\", this._onerrorListener);\\n      this._onerrorListener = listener;\\n      if (this._onerrorListener)\\n        this.addEventListener(\\\"error\\\", this._onerrorListener);\\n    }\\n    get onopen() {\\n      return this._onopenListener;\\n    }\\n    set onopen(listener) {\\n      if (this._onopenListener)\\n        this.removeEventListener(\\\"open\\\", this._onopenListener);\\n      this._onopenListener = listener;\\n      if (this._onopenListener)\\n        this.addEventListener(\\\"open\\\", this._onopenListener);\\n    }\\n    get onmessage() {\\n      return this._onmessageListener;\\n    }\\n    set onmessage(listener) {\\n      if (this._onmessageListener)\\n        this.removeEventListener(\\\"message\\\", this._onmessageListener);\\n      this._onmessageListener = listener;\\n      if (this._onmessageListener)\\n        this.addEventListener(\\\"message\\\", this._onmessageListener);\\n    }\\n    send(message) {\\n      if (this.readyState === _WebSocketMock.CONNECTING)\\n        throw new DOMException(`Failed to execute 'send' on 'WebSocket': Still in CONNECTING state.`);\\n      if (this.readyState !== _WebSocketMock.OPEN)\\n        throw new DOMException(`WebSocket is already in CLOSING or CLOSED state.`);\\n      if (this._passthrough) {\\n        if (this._ws)\\n          this._apiSendToServer(message);\\n      } else {\\n        messageToData(message, (data) => binding({ type: \\\"onMessageFromPage\\\", id: this._id, data }));\\n      }\\n    }\\n    close(code, reason) {\\n      if (code !== void 0 && code !== 1e3 && (code < 3e3 || code > 4999))\\n        throw new DOMException(`Failed to execute 'close' on 'WebSocket': The close code must be either 1000, or between 3000 and 4999. ${code} is neither.`);\\n      if (this.readyState === _WebSocketMock.OPEN || this.readyState === _WebSocketMock.CONNECTING)\\n        this.readyState = _WebSocketMock.CLOSING;\\n      if (this._passthrough)\\n        this._apiCloseServer(code, reason, true);\\n      else\\n        binding({ type: \\\"onClosePage\\\", id: this._id, code, reason, wasClean: true });\\n    }\\n    // --- methods called from the routing API ---\\n    _apiEnsureOpened() {\\n      if (!this._ws)\\n        this._ensureOpened();\\n    }\\n    _apiSendToPage(message) {\\n      this._ensureOpened();\\n      if (this.readyState !== _WebSocketMock.OPEN)\\n        throw new DOMException(`WebSocket is already in CLOSING or CLOSED state.`);\\n      this.dispatchEvent(new MessageEvent(\\\"message\\\", { data: message, origin: this._origin, cancelable: true }));\\n    }\\n    _apiSendToServer(message) {\\n      if (!this._ws)\\n        throw new Error(\\\"Cannot send a message before connecting to the server\\\");\\n      if (this._ws.readyState === _WebSocketMock.CONNECTING)\\n        this._wsBufferedMessages.push(message);\\n      else\\n        this._ws.send(message);\\n    }\\n    _apiConnect() {\\n      if (this._ws)\\n        throw new Error(\\\"Can only connect to the server once\\\");\\n      this._ws = new NativeWebSocket(this.url, this._protocols);\\n      this._ws.binaryType = this._binaryType;\\n      this._ws.onopen = () => {\\n        for (const message of this._wsBufferedMessages)\\n          this._ws.send(message);\\n        this._wsBufferedMessages = [];\\n        this._ensureOpened();\\n      };\\n      this._ws.onclose = (event) => {\\n        this._onWSClose(event.code, event.reason, event.wasClean);\\n      };\\n      this._ws.onmessage = (event) => {\\n        if (this._passthrough)\\n          this._apiSendToPage(event.data);\\n        else\\n          messageToData(event.data, (data) => binding({ type: \\\"onMessageFromServer\\\", id: this._id, data }));\\n      };\\n      this._ws.onerror = () => {\\n        const event = new Event(\\\"error\\\", { cancelable: true });\\n        this.dispatchEvent(event);\\n      };\\n    }\\n    // This method connects to the server, and passes all messages through,\\n    // as if WebSocketMock was not engaged.\\n    _apiPassThrough() {\\n      this._passthrough = true;\\n      this._apiConnect();\\n    }\\n    _apiCloseServer(code, reason, wasClean) {\\n      if (!this._ws) {\\n        this._onWSClose(code, reason, wasClean);\\n        return;\\n      }\\n      if (this._ws.readyState === _WebSocketMock.CONNECTING || this._ws.readyState === _WebSocketMock.OPEN)\\n        this._ws.close(code, reason);\\n    }\\n    _apiClosePage(code, reason, wasClean) {\\n      if (this.readyState === _WebSocketMock.CLOSED)\\n        return;\\n      this.readyState = _WebSocketMock.CLOSED;\\n      this.dispatchEvent(new CloseEvent(\\\"close\\\", { code, reason, wasClean, cancelable: true }));\\n      this._maybeCleanup();\\n      if (this._passthrough)\\n        this._apiCloseServer(code, reason, wasClean);\\n      else\\n        binding({ type: \\\"onClosePage\\\", id: this._id, code, reason, wasClean });\\n    }\\n    // --- internals ---\\n    _ensureOpened() {\\n      var _a;\\n      if (this.readyState !== _WebSocketMock.CONNECTING)\\n        return;\\n      this.extensions = ((_a = this._ws) == null ? void 0 : _a.extensions) || \\\"\\\";\\n      if (this._ws)\\n        this.protocol = this._ws.protocol;\\n      else if (Array.isArray(this._protocols))\\n        this.protocol = this._protocols[0] || \\\"\\\";\\n      else\\n        this.protocol = this._protocols || \\\"\\\";\\n      this.readyState = _WebSocketMock.OPEN;\\n      this.dispatchEvent(new Event(\\\"open\\\", { cancelable: true }));\\n    }\\n    _onWSClose(code, reason, wasClean) {\\n      if (this._passthrough)\\n        this._apiClosePage(code, reason, wasClean);\\n      else\\n        binding({ type: \\\"onCloseServer\\\", id: this._id, code, reason, wasClean });\\n      if (this._ws) {\\n        this._ws.onopen = null;\\n        this._ws.onclose = null;\\n        this._ws.onmessage = null;\\n        this._ws.onerror = null;\\n        this._ws = void 0;\\n        this._wsBufferedMessages = [];\\n      }\\n      this._maybeCleanup();\\n    }\\n    _maybeCleanup() {\\n      if (this.readyState === _WebSocketMock.CLOSED && !this._ws)\\n        idToWebSocket.delete(this._id);\\n    }\\n  };\\n  _WebSocketMock.CONNECTING = 0;\\n  // WebSocket.CONNECTING\\n  _WebSocketMock.OPEN = 1;\\n  // WebSocket.OPEN\\n  _WebSocketMock.CLOSING = 2;\\n  // WebSocket.CLOSING\\n  _WebSocketMock.CLOSED = 3;\\n  let WebSocketMock = _WebSocketMock;\\n  globalThis.WebSocket = class WebSocket extends WebSocketMock {\\n  };\\n}\\n\";\n//# sourceMappingURL=webSocketMockSource.d.ts.map",
      "inProcessFactory.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { Playwright as PlaywrightAPI } from './client/playwright';\nexport declare function createInProcessPlaywright(): PlaywrightAPI;\n//# sourceMappingURL=inProcessFactory.d.ts.map",
      "index.d.ts": "/**\n * Browser-friendly Playwright Core surface.\n * Exposes client-side primitives and a minimal CDP transport that work in sandboxed panels.\n */\nexport { Playwright } from './client/playwright';\nexport { Browser } from './client/browser';\nexport { BrowserContext } from './client/browserContext';\nexport { Page } from './client/page';\nexport { Frame } from './client/frame';\nexport { Locator } from './client/locator';\nexport { Selectors } from './client/selectors';\nexport { Request, Response, Route, WebSocket } from './client/network';\nexport { JSHandle } from './client/jsHandle';\nexport { ElementHandle } from './client/elementHandle';\nexport { TimeoutError, TargetClosedError } from './client/errors';\nexport { emptyPlatform, webPlatform } from './client/platform';\nexport type { Platform } from './client/platform';\nexport { Connection } from './client/connection';\nexport { ChannelOwner } from './client/channelOwner';\nexport { CRConnection, CRSession, ConnectionEvents, kBrowserCloseMessageId } from './server/chromium/crConnection';\nexport { BrowserWebSocketTransport } from './server/browserTransport';\nexport type { BrowserWebSocketTransportOptions } from './server/browserTransport';\nexport type { ConnectionTransport, ProtocolRequest, ProtocolResponse } from './server/transport';\nexport { helper } from './server/helper';\nexport { RecentLogsCollector } from './server/utils/debugLogger';\nexport { validateBrowserEnvironment } from './client/validateBrowserEnvironment';\nexport { CDPAdapter } from './client/cdpAdapter';\nexport { FrameAdapter } from './client/frameAdapter';\nexport { InjectedScriptLoader } from './client/injectedScriptLoader';\nexport { BrowserImpl } from './client/browserImpl';\nexport { BrowserContextImpl } from './client/browserContextImpl';\nexport { PageImpl } from './client/pageImpl';\nexport { FrameImpl } from './client/frameImpl';\nexport type { BrowserConnectOptions } from './client/browserImpl';\nexport type { GotoOptions, ScreenshotOptions } from './client/pageImpl';\n//# sourceMappingURL=index.d.ts.map",
      "inprocess.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport {};\n//# sourceMappingURL=inprocess.d.ts.map",
      "outofprocess.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { Playwright } from './client/playwright';\nexport declare function start(env?: any): Promise<{\n    playwright: Playwright;\n    stop: () => Promise<void>;\n}>;\n//# sourceMappingURL=outofprocess.d.ts.map",
      "protocol/serializers.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { SerializedValue } from '@protocol/channels';\nexport declare function parseSerializedValue(value: SerializedValue, handles: any[] | undefined): any;\nexport type HandleOrValue = {\n    h: number;\n} | {\n    fallThrough: any;\n};\nexport declare function serializeValue(value: any, handleSerializer: (value: any) => HandleOrValue): SerializedValue;\n//# sourceMappingURL=serializers.d.ts.map",
      "protocol/validator.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport type { Validator, ValidatorContext } from './validatorPrimitives';\nexport { ValidationError, findValidator, maybeFindValidator, createMetadataValidator } from './validatorPrimitives';\n//# sourceMappingURL=validator.d.ts.map",
      "protocol/validatorPrimitives.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport declare class ValidationError extends Error {\n}\nexport type Validator = (arg: any, path: string, context: ValidatorContext) => any;\nexport type ValidatorContext = {\n    tChannelImpl: (names: '*' | string[], arg: any, path: string, context: ValidatorContext) => any;\n    binary: 'toBase64' | 'fromBase64' | 'buffer';\n    isUnderTest: () => boolean;\n};\nexport declare const scheme: {\n    [key: string]: Validator;\n};\nexport declare function findValidator(type: string, method: string, kind: 'Initializer' | 'Event' | 'Params' | 'Result'): Validator;\nexport declare function maybeFindValidator(type: string, method: string, kind: 'Initializer' | 'Event' | 'Params' | 'Result'): Validator | undefined;\nexport declare function createMetadataValidator(): Validator;\nexport declare const tFloat: Validator;\nexport declare const tInt: Validator;\nexport declare const tBoolean: Validator;\nexport declare const tString: Validator;\nexport declare const tBinary: Validator;\nexport declare const tUndefined: Validator;\nexport declare const tAny: Validator;\nexport declare const tOptional: (v: Validator) => Validator;\nexport declare const tArray: (v: Validator) => Validator;\nexport declare const tObject: (s: {\n    [key: string]: Validator;\n}) => Validator;\nexport declare const tEnum: (e: string[]) => Validator;\nexport declare const tChannel: (names: \"*\" | string[]) => Validator;\nexport declare const tType: (name: string) => Validator;\n//# sourceMappingURL=validatorPrimitives.d.ts.map",
      "remote/playwrightConnection.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Semaphore } from '../utils';\nimport { PlaywrightDispatcherOptions } from '../server/dispatchers/playwrightDispatcher';\nimport type { Playwright } from '../server';\nimport type { WebSocket } from '../utilsBundle';\nexport interface PlaywrightInitializeResult extends PlaywrightDispatcherOptions {\n    dispose?(): Promise<void>;\n}\nexport declare class PlaywrightConnection {\n    private _ws;\n    private _semaphore;\n    private _dispatcherConnection;\n    private _cleanups;\n    private _id;\n    private _disconnected;\n    private _root;\n    private _profileName;\n    constructor(semaphore: Semaphore, ws: WebSocket, controller: boolean, playwright: Playwright, initialize: () => Promise<PlaywrightInitializeResult>, id: string);\n    private _onDisconnect;\n    private logServerMetadata;\n    close(reason?: {\n        code: number;\n        reason: string;\n    }): Promise<void>;\n}\n//# sourceMappingURL=playwrightConnection.d.ts.map",
      "remote/playwrightServer.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SocksProxy } from '../server/utils/socksProxy';\nimport { Browser } from '../server/browser';\nimport type { AndroidDevice } from '../server/android/android';\ntype ServerOptions = {\n    path: string;\n    maxConnections: number;\n    mode: 'default' | 'launchServer' | 'launchServerShared' | 'extension';\n    preLaunchedBrowser?: Browser;\n    preLaunchedAndroidDevice?: AndroidDevice;\n    preLaunchedSocksProxy?: SocksProxy;\n};\nexport declare class PlaywrightServer {\n    private _playwright;\n    private _options;\n    private _wsServer;\n    private _dontReuseBrowsers;\n    constructor(options: ServerOptions);\n    private _initReuseBrowsersMode;\n    private _initConnectMode;\n    private _initPreLaunchedBrowserMode;\n    private _initPreLaunchedAndroidMode;\n    private _initLaunchBrowserMode;\n    private _dontReuse;\n    listen(port?: number, hostname?: string): Promise<string>;\n    close(): Promise<void>;\n}\nexport {};\n//# sourceMappingURL=playwrightServer.d.ts.map",
      "server/android/android.d.ts": "/**\n * Copyright Microsoft Corporation. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { EventEmitter } from 'events';\nimport { SdkObject } from '../instrumentation';\nimport { Progress } from '../progress';\nimport type { BrowserContext } from '../browserContext';\nimport type * as channels from '@protocol/channels';\nexport interface Backend {\n    devices(options: channels.AndroidDevicesOptions): Promise<DeviceBackend[]>;\n}\nexport interface DeviceBackend {\n    serial: string;\n    status: string;\n    close(): Promise<void>;\n    init(): Promise<void>;\n    runCommand(command: string): Promise<Buffer>;\n    open(command: string): Promise<SocketBackend>;\n}\nexport interface SocketBackend extends EventEmitter {\n    write(data: Buffer): Promise<void>;\n    close(): void;\n}\nexport declare class Android extends SdkObject {\n    private _backend;\n    private _devices;\n    constructor(parent: SdkObject, backend: Backend);\n    devices(progress: Progress, options: channels.AndroidDevicesOptions): Promise<AndroidDevice[]>;\n    _deviceClosed(device: AndroidDevice): void;\n}\nexport declare class AndroidDevice extends SdkObject {\n    readonly _backend: DeviceBackend;\n    readonly model: string;\n    readonly serial: string;\n    private _options;\n    private _driverPromise;\n    private _lastId;\n    private _callbacks;\n    private _pollingWebViews;\n    private _webViews;\n    static Events: {\n        WebViewAdded: string;\n        WebViewRemoved: string;\n        Close: string;\n    };\n    private _browserConnections;\n    readonly _android: Android;\n    private _isClosed;\n    constructor(android: Android, backend: DeviceBackend, model: string, options: channels.AndroidDevicesOptions);\n    static create(android: Android, backend: DeviceBackend, options: channels.AndroidDevicesOptions): Promise<AndroidDevice>;\n    _init(): Promise<void>;\n    shell(command: string): Promise<Buffer>;\n    open(progress: Progress, command: string): Promise<SocketBackend>;\n    screenshot(): Promise<Buffer>;\n    private _driver;\n    private _installDriver;\n    private _waitForLocalAbstract;\n    send(method: string, params?: any): Promise<any>;\n    close(): Promise<void>;\n    launchBrowser(progress: Progress, pkg: string, options: channels.AndroidDeviceLaunchBrowserParams): Promise<BrowserContext>;\n    private _defaultArgs;\n    private _innerDefaultArgs;\n    connectToWebView(progress: Progress, socketName: string): Promise<BrowserContext>;\n    private _connectToBrowser;\n    private _open;\n    webViews(): channels.AndroidWebView[];\n    installApk(progress: Progress, content: Buffer, options?: {\n        args?: string[];\n    }): Promise<void>;\n    push(progress: Progress, content: Buffer, path: string, mode?: number): Promise<void>;\n    private _refreshWebViews;\n    private _extractPkg;\n}\n//# sourceMappingURL=android.d.ts.map",
      "server/android/backendAdb.d.ts": "/**\n * Copyright Microsoft Corporation. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { Backend, DeviceBackend } from './android';\nimport type * as channels from '@protocol/channels';\nexport declare class AdbBackend implements Backend {\n    devices(options?: channels.AndroidDevicesOptions): Promise<DeviceBackend[]>;\n}\n//# sourceMappingURL=backendAdb.d.ts.map",
      "server/artifact.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SdkObject } from './instrumentation';\nimport { ManualPromise } from '../utils/isomorphic/manualPromise';\ntype SaveCallback = (localPath: string, error?: Error) => Promise<void>;\ntype CancelCallback = () => Promise<void>;\nexport declare class Artifact extends SdkObject {\n    private _localPath;\n    private _unaccessibleErrorMessage;\n    private _cancelCallback;\n    private _finishedPromise;\n    private _saveCallbacks;\n    private _finished;\n    private _deleted;\n    private _failureError;\n    constructor(parent: SdkObject, localPath: string, unaccessibleErrorMessage?: string, cancelCallback?: CancelCallback);\n    finishedPromise(): ManualPromise<void>;\n    localPath(): string;\n    localPathAfterFinished(): Promise<string>;\n    saveAs(saveCallback: SaveCallback): void;\n    failureError(): Promise<string | null>;\n    cancel(): Promise<void>;\n    delete(): Promise<void>;\n    deleteOnContextClose(): Promise<void>;\n    reportFinished(error?: Error): Promise<void>;\n}\nexport {};\n//# sourceMappingURL=artifact.d.ts.map",
      "server/bidi/bidiBrowser.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Browser } from '../browser';\nimport { BrowserContext } from '../browserContext';\nimport { BidiPage } from './bidiPage';\nimport * as bidi from './third_party/bidiProtocol';\nimport type { BrowserOptions } from '../browser';\nimport type { SdkObject } from '../instrumentation';\nimport type { InitScript, Page } from '../page';\nimport type { ConnectionTransport } from '../transport';\nimport type * as types from '../types';\nimport type { BidiSession } from './bidiConnection';\nimport type * as channels from '@protocol/channels';\nexport declare class BidiBrowser extends Browser {\n    private readonly _connection;\n    readonly _browserSession: BidiSession;\n    private _bidiSessionInfo;\n    readonly _contexts: Map<string, BidiBrowserContext>;\n    readonly _bidiPages: Map<string, BidiPage>;\n    private readonly _eventListeners;\n    static connect(parent: SdkObject, transport: ConnectionTransport, options: BrowserOptions): Promise<BidiBrowser>;\n    constructor(parent: SdkObject, transport: ConnectionTransport, options: BrowserOptions);\n    _onDisconnect(): void;\n    doCreateNewContext(options: types.BrowserContextOptions): Promise<BrowserContext>;\n    contexts(): BrowserContext[];\n    version(): string;\n    userAgent(): string;\n    isConnected(): boolean;\n    private _onBrowsingContextCreated;\n    _onBrowsingContextDestroyed(event: bidi.BrowsingContext.Info): void;\n    private _onScriptRealmDestroyed;\n    private _findPageForFrame;\n}\nexport declare class BidiBrowserContext extends BrowserContext {\n    readonly _browser: BidiBrowser;\n    private _originToPermissions;\n    private _initScriptIds;\n    private _interceptId;\n    constructor(browser: BidiBrowser, browserContextId: string | undefined, options: types.BrowserContextOptions);\n    private _bidiPages;\n    _initialize(): Promise<void>;\n    possiblyUninitializedPages(): Page[];\n    doCreateNewPage(): Promise<Page>;\n    doGetCookies(urls: string[]): Promise<channels.NetworkCookie[]>;\n    addCookies(cookies: channels.SetNetworkCookie[]): Promise<void>;\n    doClearCookies(): Promise<void>;\n    doGrantPermissions(origin: string, permissions: string[]): Promise<void>;\n    doClearPermissions(): Promise<void>;\n    private _setPermission;\n    setGeolocation(geolocation?: types.Geolocation): Promise<void>;\n    doUpdateExtraHTTPHeaders(): Promise<void>;\n    setUserAgent(userAgent: string | undefined): Promise<void>;\n    doUpdateOffline(): Promise<void>;\n    doSetHTTPCredentials(httpCredentials?: types.Credentials): Promise<void>;\n    doAddInitScript(initScript: InitScript): Promise<void>;\n    doRemoveInitScripts(initScripts: InitScript[]): Promise<void>;\n    doUpdateRequestInterception(): Promise<void>;\n    doUpdateDefaultViewport(): Promise<void>;\n    doUpdateDefaultEmulatedMedia(): Promise<void>;\n    doExposePlaywrightBinding(): Promise<void>;\n    onClosePersistent(): void;\n    clearCache(): Promise<void>;\n    doClose(reason: string | undefined): Promise<void>;\n    cancelDownload(uuid: string): Promise<void>;\n    private _userContextId;\n}\nexport declare function getScreenOrientation(isMobile: boolean, viewportSize: types.Size): bidi.Emulation.ScreenOrientation;\nexport declare namespace Network {\n    const enum SameSite {\n        Strict = \"strict\",\n        Lax = \"lax\",\n        None = \"none\"\n    }\n}\n//# sourceMappingURL=bidiBrowser.d.ts.map",
      "server/bidi/bidiChromium.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { BrowserType } from '../browserType';\nimport { BidiBrowser } from './bidiBrowser';\nimport { RecentLogsCollector } from '../utils/debugLogger';\nimport type { BrowserOptions } from '../browser';\nimport type { SdkObject } from '../instrumentation';\nimport type { ProtocolError } from '../protocolError';\nimport type { ConnectionTransport } from '../transport';\nimport type * as types from '../types';\nexport declare class BidiChromium extends BrowserType {\n    constructor(parent: SdkObject);\n    connectToTransport(transport: ConnectionTransport, options: BrowserOptions, browserLogsCollector: RecentLogsCollector): Promise<BidiBrowser>;\n    doRewriteStartupLog(error: ProtocolError): ProtocolError;\n    amendEnvironment(env: NodeJS.ProcessEnv): NodeJS.ProcessEnv;\n    attemptToGracefullyCloseBrowser(transport: ConnectionTransport): void;\n    supportsPipeTransport(): boolean;\n    defaultArgs(options: types.LaunchOptions, isPersistent: boolean, userDataDir: string): Promise<string[]>;\n    waitForReadyState(options: types.LaunchOptions, browserLogsCollector: RecentLogsCollector): Promise<{\n        wsEndpoint?: string;\n    }>;\n    private _innerDefaultArgs;\n}\n//# sourceMappingURL=bidiChromium.d.ts.map",
      "server/bidi/bidiConnection.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { EventEmitter } from 'events';\nimport type { RecentLogsCollector } from '../utils/debugLogger';\nimport type { ConnectionTransport, ProtocolRequest } from '../transport';\nimport type { ProtocolLogger } from '../types';\nimport type * as bidiCommands from './third_party/bidiCommands';\nimport type * as bidi from './third_party/bidiProtocol';\nexport declare const kBrowserCloseMessageId: number;\nexport declare const kShutdownSessionNewMessageId: number;\nexport declare class BidiConnection {\n    private readonly _transport;\n    private readonly _onDisconnect;\n    private readonly _protocolLogger;\n    private readonly _browserLogsCollector;\n    _browserDisconnectedLogs: string | undefined;\n    private _lastId;\n    private _closed;\n    readonly browserSession: BidiSession;\n    readonly _browsingContextToSession: Map<string, BidiSession>;\n    readonly _realmToBrowsingContext: Map<string, string>;\n    readonly _realmToOwnerRealm: Map<string, string>;\n    constructor(transport: ConnectionTransport, onDisconnect: () => void, protocolLogger: ProtocolLogger, browserLogsCollector: RecentLogsCollector);\n    nextMessageId(): number;\n    rawSend(message: ProtocolRequest): void;\n    private _dispatchMessage;\n    _onClose(reason?: string): void;\n    isClosed(): boolean;\n    close(): void;\n    createMainFrameBrowsingContextSession(bowsingContextId: bidi.BrowsingContext.BrowsingContext): BidiSession;\n}\ntype BidiEvents = {\n    [K in bidi.Event['method']]: Extract<bidi.Event, {\n        method: K;\n    }>;\n};\nexport declare class BidiSession extends EventEmitter {\n    readonly connection: BidiConnection;\n    readonly sessionId: string;\n    private _disposed;\n    private readonly _rawSend;\n    private readonly _callbacks;\n    private _crashed;\n    private readonly _browsingContexts;\n    on: <T extends keyof BidiEvents | symbol>(event: T, listener: (payload: T extends symbol ? any : BidiEvents[T extends keyof BidiEvents ? T : never]['params']) => void) => this;\n    addListener: <T extends keyof BidiEvents | symbol>(event: T, listener: (payload: T extends symbol ? any : BidiEvents[T extends keyof BidiEvents ? T : never]['params']) => void) => this;\n    off: <T extends keyof BidiEvents | symbol>(event: T, listener: (payload: T extends symbol ? any : BidiEvents[T extends keyof BidiEvents ? T : never]['params']) => void) => this;\n    removeListener: <T extends keyof BidiEvents | symbol>(event: T, listener: (payload: T extends symbol ? any : BidiEvents[T extends keyof BidiEvents ? T : never]['params']) => void) => this;\n    once: <T extends keyof BidiEvents | symbol>(event: T, listener: (payload: T extends symbol ? any : BidiEvents[T extends keyof BidiEvents ? T : never]['params']) => void) => this;\n    constructor(connection: BidiConnection, sessionId: string, rawSend: (message: any) => void);\n    addFrameBrowsingContext(context: string): void;\n    removeFrameBrowsingContext(context: string): void;\n    send<T extends keyof bidiCommands.Commands>(method: T, params?: bidiCommands.Commands[T]['params']): Promise<bidiCommands.Commands[T]['returnType']>;\n    sendMayFail<T extends keyof bidiCommands.Commands>(method: T, params?: bidiCommands.Commands[T]['params']): Promise<bidiCommands.Commands[T]['returnType'] | void>;\n    markAsCrashed(): void;\n    isDisposed(): boolean;\n    dispose(): void;\n    hasCallback(id: number): boolean;\n    dispatchMessage(message: any): void;\n}\nexport {};\n//# sourceMappingURL=bidiConnection.d.ts.map",
      "server/bidi/bidiExecutionContext.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as js from '../javascript';\nimport * as dom from '../dom';\nimport * as bidi from './third_party/bidiProtocol';\nimport type { BidiSession } from './bidiConnection';\nexport declare class BidiExecutionContext implements js.ExecutionContextDelegate {\n    private readonly _session;\n    readonly _target: bidi.Script.Target;\n    constructor(session: BidiSession, realmInfo: bidi.Script.RealmInfo);\n    rawEvaluateJSON(expression: string): Promise<any>;\n    rawEvaluateHandle(context: js.ExecutionContext, expression: string): Promise<js.JSHandle>;\n    evaluateWithArguments(functionDeclaration: string, returnByValue: boolean, utilityScript: js.JSHandle, values: any[], handles: js.JSHandle[]): Promise<any>;\n    getProperties(handle: js.JSHandle): Promise<Map<string, js.JSHandle>>;\n    releaseHandle(handle: js.JSHandle): Promise<void>;\n    nodeIdForElementHandle(handle: dom.ElementHandle): Promise<bidi.Script.SharedReference>;\n    remoteObjectForNodeId(context: dom.FrameExecutionContext, nodeId: bidi.Script.SharedReference): Promise<js.JSHandle>;\n    contentFrameIdForFrame(handle: dom.ElementHandle): Promise<string>;\n    frameIdForWindowHandle(handle: js.JSHandle): Promise<string | null>;\n    private _remoteValueForReference;\n    private _rawCallFunction;\n}\nexport declare function createHandle(context: js.ExecutionContext, remoteObject: bidi.Script.RemoteValue): js.JSHandle;\n//# sourceMappingURL=bidiExecutionContext.d.ts.map",
      "server/bidi/bidiFirefox.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { BrowserType } from '../browserType';\nimport { BidiBrowser } from './bidiBrowser';\nimport type { BrowserOptions } from '../browser';\nimport type { SdkObject } from '../instrumentation';\nimport type { ProtocolError } from '../protocolError';\nimport type { ConnectionTransport } from '../transport';\nimport type * as types from '../types';\nimport type { RecentLogsCollector } from '../utils/debugLogger';\nexport declare class BidiFirefox extends BrowserType {\n    constructor(parent: SdkObject);\n    executablePath(): string;\n    connectToTransport(transport: ConnectionTransport, options: BrowserOptions): Promise<BidiBrowser>;\n    doRewriteStartupLog(error: ProtocolError): ProtocolError;\n    amendEnvironment(env: NodeJS.ProcessEnv): NodeJS.ProcessEnv;\n    attemptToGracefullyCloseBrowser(transport: ConnectionTransport): void;\n    private _attemptToGracefullyCloseBrowser;\n    supportsPipeTransport(): boolean;\n    prepareUserDataDir(options: types.LaunchOptions, userDataDir: string): Promise<void>;\n    defaultArgs(options: types.LaunchOptions, isPersistent: boolean, userDataDir: string): Promise<string[]>;\n    waitForReadyState(options: types.LaunchOptions, browserLogsCollector: RecentLogsCollector): Promise<{\n        wsEndpoint?: string;\n    }>;\n}\n//# sourceMappingURL=bidiFirefox.d.ts.map",
      "server/bidi/bidiInput.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type * as input from '../input';\nimport type * as types from '../types';\nimport type { BidiSession } from './bidiConnection';\nimport type { Progress } from '../progress';\nexport declare class RawKeyboardImpl implements input.RawKeyboard {\n    private _session;\n    constructor(session: BidiSession);\n    setSession(session: BidiSession): void;\n    keydown(progress: Progress, modifiers: Set<types.KeyboardModifier>, keyName: string, description: input.KeyDescription, autoRepeat: boolean): Promise<void>;\n    keyup(progress: Progress, modifiers: Set<types.KeyboardModifier>, keyName: string, description: input.KeyDescription): Promise<void>;\n    sendText(progress: Progress, text: string): Promise<void>;\n    private _performActions;\n}\nexport declare class RawMouseImpl implements input.RawMouse {\n    private readonly _session;\n    constructor(session: BidiSession);\n    move(progress: Progress, x: number, y: number, button: types.MouseButton | 'none', buttons: Set<types.MouseButton>, modifiers: Set<types.KeyboardModifier>, forClick: boolean): Promise<void>;\n    down(progress: Progress, x: number, y: number, button: types.MouseButton, buttons: Set<types.MouseButton>, modifiers: Set<types.KeyboardModifier>, clickCount: number): Promise<void>;\n    up(progress: Progress, x: number, y: number, button: types.MouseButton, buttons: Set<types.MouseButton>, modifiers: Set<types.KeyboardModifier>, clickCount: number): Promise<void>;\n    wheel(progress: Progress, x: number, y: number, buttons: Set<types.MouseButton>, modifiers: Set<types.KeyboardModifier>, deltaX: number, deltaY: number): Promise<void>;\n    private _performActions;\n}\nexport declare class RawTouchscreenImpl implements input.RawTouchscreen {\n    private readonly _session;\n    constructor(session: BidiSession);\n    tap(progress: Progress, x: number, y: number, modifiers: Set<types.KeyboardModifier>): Promise<void>;\n}\n//# sourceMappingURL=bidiInput.d.ts.map",
      "server/bidi/bidiNetworkManager.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as bidi from './third_party/bidiProtocol';\nimport type { Page } from '../page';\nimport type * as types from '../types';\nimport type { BidiSession } from './bidiConnection';\nexport declare class BidiNetworkManager {\n    private readonly _session;\n    private readonly _requests;\n    private readonly _page;\n    private readonly _eventListeners;\n    private _userRequestInterceptionEnabled;\n    private _protocolRequestInterceptionEnabled;\n    private _credentials;\n    private _attemptedAuthentications;\n    private _intercepId;\n    constructor(bidiSession: BidiSession, page: Page);\n    dispose(): void;\n    private _onBeforeRequestSent;\n    private _onResponseStarted;\n    private _onResponseCompleted;\n    private _onFetchError;\n    private _onAuthRequired;\n    _deleteRequest(requestId: string): void;\n    setRequestInterception(value: boolean): Promise<void>;\n    setCredentials(credentials: types.Credentials | undefined): Promise<void>;\n    _updateProtocolRequestInterception(initial?: boolean): Promise<void>;\n}\nexport declare function bidiBytesValueToString(value: bidi.Network.BytesValue): string;\n//# sourceMappingURL=bidiNetworkManager.d.ts.map",
      "server/bidi/bidiOverCdp.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { ConnectionTransport } from '../transport';\nexport declare function connectBidiOverCdp(cdp: ConnectionTransport): Promise<ConnectionTransport>;\n//# sourceMappingURL=bidiOverCdp.d.ts.map",
      "server/bidi/bidiPage.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as dom from '../dom';\nimport { BidiBrowserContext } from './bidiBrowser';\nimport { Page } from '../page';\nimport { RawKeyboardImpl, RawMouseImpl, RawTouchscreenImpl } from './bidiInput';\nimport { BidiNetworkManager } from './bidiNetworkManager';\nimport * as bidi from './third_party/bidiProtocol';\nimport type * as frames from '../frames';\nimport type { InitScript, PageDelegate } from '../page';\nimport type { Progress } from '../progress';\nimport type * as types from '../types';\nimport type { BidiSession } from './bidiConnection';\nimport type * as channels from '@protocol/channels';\nexport declare const kPlaywrightBindingChannel = \"playwrightChannel\";\nexport declare class BidiPage implements PageDelegate {\n    readonly rawMouse: RawMouseImpl;\n    readonly rawKeyboard: RawKeyboardImpl;\n    readonly rawTouchscreen: RawTouchscreenImpl;\n    readonly _page: Page;\n    readonly _session: BidiSession;\n    readonly _opener: BidiPage | null;\n    readonly _realmToContext: Map<string, dom.FrameExecutionContext>;\n    private _realmToWorkerContext;\n    private _sessionListeners;\n    readonly _browserContext: BidiBrowserContext;\n    readonly _networkManager: BidiNetworkManager;\n    private readonly _pdf;\n    private _initScriptIds;\n    constructor(browserContext: BidiBrowserContext, bidiSession: BidiSession, opener: BidiPage | null);\n    private _initialize;\n    didClose(): void;\n    private _onFrameAttached;\n    private _removeContextsForFrame;\n    private _onRealmCreated;\n    private _touchUtilityWorld;\n    _onRealmDestroyed(params: bidi.Script.RealmDestroyedParameters): boolean;\n    private _onBrowsingContextDestroyed;\n    private _onNavigationStarted;\n    private _onNavigationCommitted;\n    private _onDomContentLoaded;\n    private _onLoad;\n    private _onNavigationAborted;\n    private _onNavigationFailed;\n    private _onFragmentNavigated;\n    private _onHistoryUpdated;\n    private _onUserPromptOpened;\n    private _onDownloadWillBegin;\n    private _onDownloadEnded;\n    private _onLogEntryAdded;\n    private _onFileDialogOpened;\n    navigateFrame(frame: frames.Frame, url: string, referrer: string | undefined): Promise<frames.GotoResult>;\n    updateExtraHTTPHeaders(): Promise<void>;\n    updateEmulateMedia(): Promise<void>;\n    updateUserAgent(): Promise<void>;\n    bringToFront(): Promise<void>;\n    updateEmulatedViewportSize(): Promise<void>;\n    updateRequestInterception(): Promise<void>;\n    updateOffline(): Promise<void>;\n    updateHttpCredentials(): Promise<void>;\n    updateFileChooserInterception(): Promise<void>;\n    reload(): Promise<void>;\n    goBack(): Promise<boolean>;\n    goForward(): Promise<boolean>;\n    requestGC(): Promise<void>;\n    private _onScriptMessage;\n    addInitScript(initScript: InitScript): Promise<void>;\n    removeInitScripts(initScripts: InitScript[]): Promise<void>;\n    closePage(runBeforeUnload: boolean): Promise<void>;\n    setBackgroundColor(color?: {\n        r: number;\n        g: number;\n        b: number;\n        a: number;\n    }): Promise<void>;\n    takeScreenshot(progress: Progress, format: string, documentRect: types.Rect | undefined, viewportRect: types.Rect | undefined, quality: number | undefined, fitsViewport: boolean, scale: 'css' | 'device'): Promise<Buffer>;\n    getContentFrame(handle: dom.ElementHandle): Promise<frames.Frame | null>;\n    getOwnerFrame(handle: dom.ElementHandle): Promise<string | null>;\n    getBoundingBox(handle: dom.ElementHandle): Promise<types.Rect | null>;\n    private _framePosition;\n    scrollRectIntoViewIfNeeded(handle: dom.ElementHandle<Element>, rect?: types.Rect): Promise<'error:notvisible' | 'error:notconnected' | 'done'>;\n    setScreencastOptions(options: {\n        width: number;\n        height: number;\n        quality: number;\n    } | null): Promise<void>;\n    rafCountForStablePosition(): number;\n    getContentQuads(handle: dom.ElementHandle<Element>): Promise<types.Quad[] | null | 'error:notconnected'>;\n    setInputFilePaths(handle: dom.ElementHandle<HTMLInputElement>, paths: string[]): Promise<void>;\n    adoptElementHandle<T extends Node>(handle: dom.ElementHandle<T>, to: dom.FrameExecutionContext): Promise<dom.ElementHandle<T>>;\n    inputActionEpilogue(): Promise<void>;\n    resetForReuse(progress: Progress): Promise<void>;\n    pdf(options: channels.PagePdfParams): Promise<Buffer>;\n    getFrameElement(frame: frames.Frame): Promise<dom.ElementHandle>;\n    shouldToggleStyleSheetToSyncAnimations(): boolean;\n}\n//# sourceMappingURL=bidiPage.d.ts.map",
      "server/bidi/bidiPdf.d.ts": "/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { BidiSession } from './bidiConnection';\nimport type * as channels from '@protocol/channels';\nexport declare class BidiPDF {\n    private _session;\n    constructor(session: BidiSession);\n    generate(options: channels.PagePdfParams): Promise<Buffer>;\n}\n//# sourceMappingURL=bidiPdf.d.ts.map",
      "server/bidi/third_party/bidiDeserializer.d.ts": "/**\n * @license\n * Copyright 2024 Google Inc.\n * Modifications copyright (c) Microsoft Corporation.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport type * as Bidi from './bidiProtocol';\n/**\n * @internal\n */\nexport declare class BidiDeserializer {\n    static deserialize(result: Bidi.Script.RemoteValue): any;\n    static _deserializeNumber(value: Bidi.Script.SpecialNumber | number): number;\n    static _deserializeTuple([serializedKey, serializedValue]: [\n        Bidi.Script.RemoteValue | string,\n        Bidi.Script.RemoteValue\n    ]): {\n        key: unknown;\n        value: unknown;\n    };\n}\n//# sourceMappingURL=bidiDeserializer.d.ts.map",
      "server/bidi/third_party/bidiKeyboard.d.ts": "/**\n * @license\n * Copyright 2024 Google Inc.\n * Modifications copyright (c) Microsoft Corporation.\n * SPDX-License-Identifier: Apache-2.0\n */\nexport declare const getBidiKeyValue: (keyName: string) => string;\n//# sourceMappingURL=bidiKeyboard.d.ts.map",
      "server/bidi/third_party/bidiProtocol.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport * from './bidiProtocolCore';\nexport * from './bidiProtocolPermissions';\n//# sourceMappingURL=bidiProtocol.d.ts.map",
      "server/bidi/third_party/bidiProtocolCore.d.ts": "/**\n * Copyright 2024 Google LLC.\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * THIS FILE IS AUTOGENERATED by cddlconv 0.1.7.\n * Run `node tools/generate-bidi-types.mjs` to regenerate.\n * @see https://github.com/w3c/webdriver-bidi/blob/master/index.bs\n */\nexport type Command = {\n    id: JsUint;\n} & CommandData & Extensible;\nexport type CommandData = BrowserCommand | BrowsingContextCommand | EmulationCommand | InputCommand | NetworkCommand | ScriptCommand | SessionCommand | StorageCommand | WebExtensionCommand;\nexport type EmptyParams = Extensible;\nexport type Message = CommandResponse | ErrorResponse | Event;\nexport type CommandResponse = {\n    type: 'success';\n    id: JsUint;\n    result: ResultData;\n} & Extensible;\nexport type ErrorResponse = {\n    type: 'error';\n    id: JsUint | null;\n    error: ErrorCode;\n    message: string;\n    stacktrace?: string;\n} & Extensible;\nexport type ResultData = BrowserResult | BrowsingContextResult | EmulationResult | InputResult | NetworkResult | ScriptResult | SessionResult | StorageResult | WebExtensionResult;\nexport type EmptyResult = Extensible;\nexport type Event = {\n    type: 'event';\n} & EventData & Extensible;\nexport type EventData = BrowsingContextEvent | InputEvent | LogEvent | NetworkEvent | ScriptEvent;\nexport type Extensible = {\n    [key: string]: any;\n};\n/**\n * Must be between `-9007199254740991` and `9007199254740991`, inclusive.\n */\nexport type JsInt = number;\n/**\n * Must be between `0` and `9007199254740991`, inclusive.\n */\nexport type JsUint = number;\nexport declare const enum ErrorCode {\n    InvalidArgument = \"invalid argument\",\n    InvalidSelector = \"invalid selector\",\n    InvalidSessionId = \"invalid session id\",\n    InvalidWebExtension = \"invalid web extension\",\n    MoveTargetOutOfBounds = \"move target out of bounds\",\n    NoSuchAlert = \"no such alert\",\n    NoSuchNetworkCollector = \"no such network collector\",\n    NoSuchElement = \"no such element\",\n    NoSuchFrame = \"no such frame\",\n    NoSuchHandle = \"no such handle\",\n    NoSuchHistoryEntry = \"no such history entry\",\n    NoSuchIntercept = \"no such intercept\",\n    NoSuchNetworkData = \"no such network data\",\n    NoSuchNode = \"no such node\",\n    NoSuchRequest = \"no such request\",\n    NoSuchScript = \"no such script\",\n    NoSuchStoragePartition = \"no such storage partition\",\n    NoSuchUserContext = \"no such user context\",\n    NoSuchWebExtension = \"no such web extension\",\n    SessionNotCreated = \"session not created\",\n    UnableToCaptureScreen = \"unable to capture screen\",\n    UnableToCloseBrowser = \"unable to close browser\",\n    UnableToSetCookie = \"unable to set cookie\",\n    UnableToSetFileInput = \"unable to set file input\",\n    UnavailableNetworkData = \"unavailable network data\",\n    UnderspecifiedStoragePartition = \"underspecified storage partition\",\n    UnknownCommand = \"unknown command\",\n    UnknownError = \"unknown error\",\n    UnsupportedOperation = \"unsupported operation\"\n}\nexport type SessionCommand = Session.End | Session.New | Session.Status | Session.Subscribe | Session.Unsubscribe;\nexport type SessionResult = Session.EndResult | Session.NewResult | Session.StatusResult | Session.SubscribeResult | Session.UnsubscribeResult;\nexport declare namespace Session {\n    type CapabilitiesRequest = {\n        alwaysMatch?: Session.CapabilityRequest;\n        firstMatch?: [...Session.CapabilityRequest[]];\n    };\n}\nexport declare namespace Session {\n    type CapabilityRequest = {\n        acceptInsecureCerts?: boolean;\n        browserName?: string;\n        browserVersion?: string;\n        platformName?: string;\n        proxy?: Session.ProxyConfiguration;\n        unhandledPromptBehavior?: Session.UserPromptHandler;\n    } & Extensible;\n}\nexport declare namespace Session {\n    type ProxyConfiguration = Session.AutodetectProxyConfiguration | Session.DirectProxyConfiguration | Session.ManualProxyConfiguration | Session.PacProxyConfiguration | Session.SystemProxyConfiguration;\n}\nexport declare namespace Session {\n    type AutodetectProxyConfiguration = {\n        proxyType: 'autodetect';\n    } & Extensible;\n}\nexport declare namespace Session {\n    type DirectProxyConfiguration = {\n        proxyType: 'direct';\n    } & Extensible;\n}\nexport declare namespace Session {\n    type ManualProxyConfiguration = {\n        proxyType: 'manual';\n        httpProxy?: string;\n        sslProxy?: string;\n    } & ({} | Session.SocksProxyConfiguration) & {\n        noProxy?: [...string[]];\n    } & Extensible;\n}\nexport declare namespace Session {\n    type SocksProxyConfiguration = {\n        socksProxy: string;\n        /**\n         * Must be between `0` and `255`, inclusive.\n         */\n        socksVersion: number;\n    };\n}\nexport declare namespace Session {\n    type PacProxyConfiguration = {\n        proxyType: 'pac';\n        proxyAutoconfigUrl: string;\n    } & Extensible;\n}\nexport declare namespace Session {\n    type SystemProxyConfiguration = {\n        proxyType: 'system';\n    } & Extensible;\n}\nexport declare namespace Session {\n    type UserPromptHandler = {\n        alert?: Session.UserPromptHandlerType;\n        beforeUnload?: Session.UserPromptHandlerType;\n        confirm?: Session.UserPromptHandlerType;\n        default?: Session.UserPromptHandlerType;\n        file?: Session.UserPromptHandlerType;\n        prompt?: Session.UserPromptHandlerType;\n    };\n}\nexport declare namespace Session {\n    const enum UserPromptHandlerType {\n        Accept = \"accept\",\n        Dismiss = \"dismiss\",\n        Ignore = \"ignore\"\n    }\n}\nexport declare namespace Session {\n    type Subscription = string;\n}\nexport declare namespace Session {\n    type SubscriptionRequest = {\n        events: [string, ...string[]];\n        contexts?: [\n            BrowsingContext.BrowsingContext,\n            ...BrowsingContext.BrowsingContext[]\n        ];\n        userContexts?: [Browser.UserContext, ...Browser.UserContext[]];\n    };\n}\nexport declare namespace Session {\n    type UnsubscribeByIdRequest = {\n        subscriptions: [Session.Subscription, ...Session.Subscription[]];\n    };\n}\nexport declare namespace Session {\n    type UnsubscribeByAttributesRequest = {\n        events: [string, ...string[]];\n    };\n}\nexport declare namespace Session {\n    type Status = {\n        method: 'session.status';\n        params: EmptyParams;\n    };\n}\nexport declare namespace Session {\n    type StatusResult = {\n        ready: boolean;\n        message: string;\n    };\n}\nexport declare namespace Session {\n    type New = {\n        method: 'session.new';\n        params: Session.NewParameters;\n    };\n}\nexport declare namespace Session {\n    type NewParameters = {\n        capabilities: Session.CapabilitiesRequest;\n    };\n}\nexport declare namespace Session {\n    type NewResult = {\n        sessionId: string;\n        capabilities: {\n            acceptInsecureCerts: boolean;\n            browserName: string;\n            browserVersion: string;\n            platformName: string;\n            setWindowRect: boolean;\n            userAgent: string;\n            proxy?: Session.ProxyConfiguration;\n            unhandledPromptBehavior?: Session.UserPromptHandler;\n            webSocketUrl?: string;\n        } & Extensible;\n    };\n}\nexport declare namespace Session {\n    type End = {\n        method: 'session.end';\n        params: EmptyParams;\n    };\n}\nexport declare namespace Session {\n    type EndResult = EmptyResult;\n}\nexport declare namespace Session {\n    type Subscribe = {\n        method: 'session.subscribe';\n        params: Session.SubscriptionRequest;\n    };\n}\nexport declare namespace Session {\n    type SubscribeResult = {\n        subscription: Session.Subscription;\n    };\n}\nexport declare namespace Session {\n    type Unsubscribe = {\n        method: 'session.unsubscribe';\n        params: Session.UnsubscribeParameters;\n    };\n}\nexport declare namespace Session {\n    type UnsubscribeParameters = Session.UnsubscribeByAttributesRequest | Session.UnsubscribeByIdRequest;\n}\nexport declare namespace Session {\n    type UnsubscribeResult = EmptyResult;\n}\nexport type BrowserCommand = Browser.Close | Browser.CreateUserContext | Browser.GetClientWindows | Browser.GetUserContexts | Browser.RemoveUserContext | Browser.SetClientWindowState | Browser.SetDownloadBehavior;\nexport type BrowserResult = Browser.CloseResult | Browser.CreateUserContextResult | Browser.GetClientWindowsResult | Browser.GetUserContextsResult | Browser.RemoveUserContextResult | Browser.SetClientWindowStateResult | Browser.SetDownloadBehaviorResult;\nexport declare namespace Browser {\n    type ClientWindow = string;\n}\nexport declare namespace Browser {\n    type ClientWindowInfo = {\n        active: boolean;\n        clientWindow: Browser.ClientWindow;\n        height: JsUint;\n        state: 'fullscreen' | 'maximized' | 'minimized' | 'normal';\n        width: JsUint;\n        x: JsInt;\n        y: JsInt;\n    };\n}\nexport declare namespace Browser {\n    type UserContext = string;\n}\nexport declare namespace Browser {\n    type UserContextInfo = {\n        userContext: Browser.UserContext;\n    };\n}\nexport declare namespace Browser {\n    type Close = {\n        method: 'browser.close';\n        params: EmptyParams;\n    };\n}\nexport declare namespace Browser {\n    type CloseResult = EmptyResult;\n}\nexport declare namespace Browser {\n    type CreateUserContext = {\n        method: 'browser.createUserContext';\n        params: Browser.CreateUserContextParameters;\n    };\n}\nexport declare namespace Browser {\n    type CreateUserContextParameters = {\n        acceptInsecureCerts?: boolean;\n        proxy?: Session.ProxyConfiguration;\n        unhandledPromptBehavior?: Session.UserPromptHandler;\n    };\n}\nexport declare namespace Browser {\n    type CreateUserContextResult = Browser.UserContextInfo;\n}\nexport declare namespace Browser {\n    type GetClientWindows = {\n        method: 'browser.getClientWindows';\n        params: EmptyParams;\n    };\n}\nexport declare namespace Browser {\n    type GetClientWindowsResult = {\n        clientWindows: [...Browser.ClientWindowInfo[]];\n    };\n}\nexport declare namespace Browser {\n    type GetUserContexts = {\n        method: 'browser.getUserContexts';\n        params: EmptyParams;\n    };\n}\nexport declare namespace Browser {\n    type GetUserContextsResult = {\n        userContexts: [Browser.UserContextInfo, ...Browser.UserContextInfo[]];\n    };\n}\nexport declare namespace Browser {\n    type RemoveUserContext = {\n        method: 'browser.removeUserContext';\n        params: Browser.RemoveUserContextParameters;\n    };\n}\nexport declare namespace Browser {\n    type RemoveUserContextParameters = {\n        userContext: Browser.UserContext;\n    };\n}\nexport declare namespace Browser {\n    type RemoveUserContextResult = EmptyResult;\n}\nexport declare namespace Browser {\n    type SetClientWindowState = {\n        method: 'browser.setClientWindowState';\n        params: Browser.SetClientWindowStateParameters;\n    };\n}\nexport declare namespace Browser {\n    type SetClientWindowStateParameters = {\n        clientWindow: Browser.ClientWindow;\n    } & (Browser.ClientWindowNamedState | Browser.ClientWindowRectState);\n}\nexport declare namespace Browser {\n    type ClientWindowNamedState = {\n        state: 'fullscreen' | 'maximized' | 'minimized';\n    };\n}\nexport declare namespace Browser {\n    type ClientWindowRectState = {\n        state: 'normal';\n        width?: JsUint;\n        height?: JsUint;\n        x?: JsInt;\n        y?: JsInt;\n    };\n}\nexport declare namespace Browser {\n    type SetClientWindowStateResult = Browser.ClientWindowInfo;\n}\nexport declare namespace Browser {\n    type SetDownloadBehavior = {\n        method: 'browser.setDownloadBehavior';\n        params: Browser.SetDownloadBehaviorParameters;\n    };\n}\nexport declare namespace Browser {\n    type SetDownloadBehaviorParameters = {\n        downloadBehavior: Browser.DownloadBehavior | null;\n        userContexts?: [Browser.UserContext, ...Browser.UserContext[]];\n    };\n}\nexport declare namespace Browser {\n    type DownloadBehavior = Browser.DownloadBehaviorAllowed | Browser.DownloadBehaviorDenied;\n}\nexport declare namespace Browser {\n    type DownloadBehaviorAllowed = {\n        type: 'allowed';\n        destinationFolder: string;\n    };\n}\nexport declare namespace Browser {\n    type DownloadBehaviorDenied = {\n        type: 'denied';\n    };\n}\nexport declare namespace Browser {\n    type SetDownloadBehaviorResult = EmptyResult;\n}\nexport type BrowsingContextCommand = BrowsingContext.Activate | BrowsingContext.CaptureScreenshot | BrowsingContext.Close | BrowsingContext.Create | BrowsingContext.GetTree | BrowsingContext.HandleUserPrompt | BrowsingContext.LocateNodes | BrowsingContext.Navigate | BrowsingContext.Print | BrowsingContext.Reload | BrowsingContext.SetViewport | BrowsingContext.TraverseHistory;\nexport type BrowsingContextResult = BrowsingContext.ActivateResult | BrowsingContext.CaptureScreenshotResult | BrowsingContext.CloseResult | BrowsingContext.CreateResult | BrowsingContext.GetTreeResult | BrowsingContext.HandleUserPromptResult | BrowsingContext.LocateNodesResult | BrowsingContext.NavigateResult | BrowsingContext.PrintResult | BrowsingContext.ReloadResult | BrowsingContext.SetViewportResult | BrowsingContext.TraverseHistoryResult;\nexport type BrowsingContextEvent = BrowsingContext.ContextCreated | BrowsingContext.ContextDestroyed | BrowsingContext.DomContentLoaded | BrowsingContext.DownloadEnd | BrowsingContext.DownloadWillBegin | BrowsingContext.FragmentNavigated | BrowsingContext.HistoryUpdated | BrowsingContext.Load | BrowsingContext.NavigationAborted | BrowsingContext.NavigationCommitted | BrowsingContext.NavigationFailed | BrowsingContext.NavigationStarted | BrowsingContext.UserPromptClosed | BrowsingContext.UserPromptOpened;\nexport declare namespace BrowsingContext {\n    type BrowsingContext = string;\n}\nexport declare namespace BrowsingContext {\n    type InfoList = [...BrowsingContext.Info[]];\n}\nexport declare namespace BrowsingContext {\n    type Info = {\n        children: BrowsingContext.InfoList | null;\n        clientWindow: Browser.ClientWindow;\n        context: BrowsingContext.BrowsingContext;\n        originalOpener: BrowsingContext.BrowsingContext | null;\n        url: string;\n        userContext: Browser.UserContext;\n        parent?: BrowsingContext.BrowsingContext | null;\n    };\n}\nexport declare namespace BrowsingContext {\n    type Locator = BrowsingContext.AccessibilityLocator | BrowsingContext.CssLocator | BrowsingContext.ContextLocator | BrowsingContext.InnerTextLocator | BrowsingContext.XPathLocator;\n}\nexport declare namespace BrowsingContext {\n    type AccessibilityLocator = {\n        type: 'accessibility';\n        value: {\n            name?: string;\n            role?: string;\n        };\n    };\n}\nexport declare namespace BrowsingContext {\n    type CssLocator = {\n        type: 'css';\n        value: string;\n    };\n}\nexport declare namespace BrowsingContext {\n    type ContextLocator = {\n        type: 'context';\n        value: {\n            context: BrowsingContext.BrowsingContext;\n        };\n    };\n}\nexport declare namespace BrowsingContext {\n    type InnerTextLocator = {\n        type: 'innerText';\n        value: string;\n        ignoreCase?: boolean;\n        matchType?: 'full' | 'partial';\n        maxDepth?: JsUint;\n    };\n}\nexport declare namespace BrowsingContext {\n    type XPathLocator = {\n        type: 'xpath';\n        value: string;\n    };\n}\nexport declare namespace BrowsingContext {\n    type Navigation = string;\n}\nexport declare namespace BrowsingContext {\n    type BaseNavigationInfo = {\n        context: BrowsingContext.BrowsingContext;\n        navigation: BrowsingContext.Navigation | null;\n        timestamp: JsUint;\n        url: string;\n    };\n}\nexport declare namespace BrowsingContext {\n    type NavigationInfo = BrowsingContext.BaseNavigationInfo;\n}\nexport declare namespace BrowsingContext {\n    const enum ReadinessState {\n        None = \"none\",\n        Interactive = \"interactive\",\n        Complete = \"complete\"\n    }\n}\nexport declare namespace BrowsingContext {\n    const enum UserPromptType {\n        Alert = \"alert\",\n        Beforeunload = \"beforeunload\",\n        Confirm = \"confirm\",\n        Prompt = \"prompt\"\n    }\n}\nexport declare namespace BrowsingContext {\n    type Activate = {\n        method: 'browsingContext.activate';\n        params: BrowsingContext.ActivateParameters;\n    };\n}\nexport declare namespace BrowsingContext {\n    type ActivateParameters = {\n        context: BrowsingContext.BrowsingContext;\n    };\n}\nexport declare namespace BrowsingContext {\n    type ActivateResult = EmptyResult;\n}\nexport declare namespace BrowsingContext {\n    type CaptureScreenshot = {\n        method: 'browsingContext.captureScreenshot';\n        params: BrowsingContext.CaptureScreenshotParameters;\n    };\n}\nexport declare namespace BrowsingContext {\n    type CaptureScreenshotParameters = {\n        context: BrowsingContext.BrowsingContext;\n        /**\n         * @defaultValue `\"viewport\"`\n         */\n        origin?: 'viewport' | 'document';\n        format?: BrowsingContext.ImageFormat;\n        clip?: BrowsingContext.ClipRectangle;\n    };\n}\nexport declare namespace BrowsingContext {\n    type ImageFormat = {\n        type: string;\n        /**\n         * Must be between `0` and `1`, inclusive.\n         */\n        quality?: number;\n    };\n}\nexport declare namespace BrowsingContext {\n    type ClipRectangle = BrowsingContext.BoxClipRectangle | BrowsingContext.ElementClipRectangle;\n}\nexport declare namespace BrowsingContext {\n    type ElementClipRectangle = {\n        type: 'element';\n        element: Script.SharedReference;\n    };\n}\nexport declare namespace BrowsingContext {\n    type BoxClipRectangle = {\n        type: 'box';\n        x: number;\n        y: number;\n        width: number;\n        height: number;\n    };\n}\nexport declare namespace BrowsingContext {\n    type CaptureScreenshotResult = {\n        data: string;\n    };\n}\nexport declare namespace BrowsingContext {\n    type Close = {\n        method: 'browsingContext.close';\n        params: BrowsingContext.CloseParameters;\n    };\n}\nexport declare namespace BrowsingContext {\n    type CloseParameters = {\n        context: BrowsingContext.BrowsingContext;\n        /**\n         * @defaultValue `false`\n         */\n        promptUnload?: boolean;\n    };\n}\nexport declare namespace BrowsingContext {\n    type CloseResult = EmptyResult;\n}\nexport declare namespace BrowsingContext {\n    type Create = {\n        method: 'browsingContext.create';\n        params: BrowsingContext.CreateParameters;\n    };\n}\nexport declare namespace BrowsingContext {\n    const enum CreateType {\n        Tab = \"tab\",\n        Window = \"window\"\n    }\n}\nexport declare namespace BrowsingContext {\n    type CreateParameters = {\n        type: BrowsingContext.CreateType;\n        referenceContext?: BrowsingContext.BrowsingContext;\n        /**\n         * @defaultValue `false`\n         */\n        background?: boolean;\n        userContext?: Browser.UserContext;\n    };\n}\nexport declare namespace BrowsingContext {\n    type CreateResult = {\n        context: BrowsingContext.BrowsingContext;\n    };\n}\nexport declare namespace BrowsingContext {\n    type GetTree = {\n        method: 'browsingContext.getTree';\n        params: BrowsingContext.GetTreeParameters;\n    };\n}\nexport declare namespace BrowsingContext {\n    type GetTreeParameters = {\n        maxDepth?: JsUint;\n        root?: BrowsingContext.BrowsingContext;\n    };\n}\nexport declare namespace BrowsingContext {\n    type GetTreeResult = {\n        contexts: BrowsingContext.InfoList;\n    };\n}\nexport declare namespace BrowsingContext {\n    type HandleUserPrompt = {\n        method: 'browsingContext.handleUserPrompt';\n        params: BrowsingContext.HandleUserPromptParameters;\n    };\n}\nexport declare namespace BrowsingContext {\n    type HandleUserPromptParameters = {\n        context: BrowsingContext.BrowsingContext;\n        accept?: boolean;\n        userText?: string;\n    };\n}\nexport declare namespace BrowsingContext {\n    type HandleUserPromptResult = EmptyResult;\n}\nexport declare namespace BrowsingContext {\n    type LocateNodes = {\n        method: 'browsingContext.locateNodes';\n        params: BrowsingContext.LocateNodesParameters;\n    };\n}\nexport declare namespace BrowsingContext {\n    type LocateNodesParameters = {\n        context: BrowsingContext.BrowsingContext;\n        locator: BrowsingContext.Locator;\n        /**\n         * Must be greater than or equal to `1`.\n         */\n        maxNodeCount?: JsUint;\n        serializationOptions?: Script.SerializationOptions;\n        startNodes?: [Script.SharedReference, ...Script.SharedReference[]];\n    };\n}\nexport declare namespace BrowsingContext {\n    type LocateNodesResult = {\n        nodes: [...Script.NodeRemoteValue[]];\n    };\n}\nexport declare namespace BrowsingContext {\n    type Navigate = {\n        method: 'browsingContext.navigate';\n        params: BrowsingContext.NavigateParameters;\n    };\n}\nexport declare namespace BrowsingContext {\n    type NavigateParameters = {\n        context: BrowsingContext.BrowsingContext;\n        url: string;\n        wait?: BrowsingContext.ReadinessState;\n    };\n}\nexport declare namespace BrowsingContext {\n    type NavigateResult = {\n        navigation: BrowsingContext.Navigation | null;\n        url: string;\n    };\n}\nexport declare namespace BrowsingContext {\n    type Print = {\n        method: 'browsingContext.print';\n        params: BrowsingContext.PrintParameters;\n    };\n}\nexport declare namespace BrowsingContext {\n    type PrintParameters = {\n        context: BrowsingContext.BrowsingContext;\n        /**\n         * @defaultValue `false`\n         */\n        background?: boolean;\n        margin?: BrowsingContext.PrintMarginParameters;\n        /**\n         * @defaultValue `\"portrait\"`\n         */\n        orientation?: 'portrait' | 'landscape';\n        page?: BrowsingContext.PrintPageParameters;\n        pageRanges?: [...(JsUint | string)[]];\n        /**\n         * Must be between `0.1` and `2`, inclusive.\n         *\n         * @defaultValue `1`\n         */\n        scale?: number;\n        /**\n         * @defaultValue `true`\n         */\n        shrinkToFit?: boolean;\n    };\n}\nexport declare namespace BrowsingContext {\n    type PrintMarginParameters = {\n        /**\n         * Must be greater than or equal to `0`.\n         *\n         * @defaultValue `1`\n         */\n        bottom?: number;\n        /**\n         * Must be greater than or equal to `0`.\n         *\n         * @defaultValue `1`\n         */\n        left?: number;\n        /**\n         * Must be greater than or equal to `0`.\n         *\n         * @defaultValue `1`\n         */\n        right?: number;\n        /**\n         * Must be greater than or equal to `0`.\n         *\n         * @defaultValue `1`\n         */\n        top?: number;\n    };\n}\nexport declare namespace BrowsingContext {\n    type PrintPageParameters = {\n        /**\n         * Must be greater than or equal to `0.0352`.\n         *\n         * @defaultValue `27.94`\n         */\n        height?: number;\n        /**\n         * Must be greater than or equal to `0.0352`.\n         *\n         * @defaultValue `21.59`\n         */\n        width?: number;\n    };\n}\nexport declare namespace BrowsingContext {\n    type PrintResult = {\n        data: string;\n    };\n}\nexport declare namespace BrowsingContext {\n    type Reload = {\n        method: 'browsingContext.reload';\n        params: BrowsingContext.ReloadParameters;\n    };\n}\nexport declare namespace BrowsingContext {\n    type ReloadParameters = {\n        context: BrowsingContext.BrowsingContext;\n        ignoreCache?: boolean;\n        wait?: BrowsingContext.ReadinessState;\n    };\n}\nexport declare namespace BrowsingContext {\n    type ReloadResult = BrowsingContext.NavigateResult;\n}\nexport declare namespace BrowsingContext {\n    type SetViewport = {\n        method: 'browsingContext.setViewport';\n        params: BrowsingContext.SetViewportParameters;\n    };\n}\nexport declare namespace BrowsingContext {\n    type SetViewportParameters = {\n        context?: BrowsingContext.BrowsingContext;\n        viewport?: BrowsingContext.Viewport | null;\n        /**\n         * Must be greater than `0`.\n         */\n        devicePixelRatio?: number | null;\n        userContexts?: [Browser.UserContext, ...Browser.UserContext[]];\n    };\n}\nexport declare namespace BrowsingContext {\n    type Viewport = {\n        width: JsUint;\n        height: JsUint;\n    };\n}\nexport declare namespace BrowsingContext {\n    type SetViewportResult = EmptyResult;\n}\nexport declare namespace BrowsingContext {\n    type TraverseHistory = {\n        method: 'browsingContext.traverseHistory';\n        params: BrowsingContext.TraverseHistoryParameters;\n    };\n}\nexport declare namespace BrowsingContext {\n    type TraverseHistoryParameters = {\n        context: BrowsingContext.BrowsingContext;\n        delta: JsInt;\n    };\n}\nexport declare namespace BrowsingContext {\n    type TraverseHistoryResult = EmptyResult;\n}\nexport declare namespace BrowsingContext {\n    type ContextCreated = {\n        method: 'browsingContext.contextCreated';\n        params: BrowsingContext.Info;\n    };\n}\nexport declare namespace BrowsingContext {\n    type ContextDestroyed = {\n        method: 'browsingContext.contextDestroyed';\n        params: BrowsingContext.Info;\n    };\n}\nexport declare namespace BrowsingContext {\n    type NavigationStarted = {\n        method: 'browsingContext.navigationStarted';\n        params: BrowsingContext.NavigationInfo;\n    };\n}\nexport declare namespace BrowsingContext {\n    type FragmentNavigated = {\n        method: 'browsingContext.fragmentNavigated';\n        params: BrowsingContext.NavigationInfo;\n    };\n}\nexport declare namespace BrowsingContext {\n    type HistoryUpdated = {\n        method: 'browsingContext.historyUpdated';\n        params: BrowsingContext.HistoryUpdatedParameters;\n    };\n}\nexport declare namespace BrowsingContext {\n    type HistoryUpdatedParameters = {\n        context: BrowsingContext.BrowsingContext;\n        timestamp: JsUint;\n        url: string;\n    };\n}\nexport declare namespace BrowsingContext {\n    type DomContentLoaded = {\n        method: 'browsingContext.domContentLoaded';\n        params: BrowsingContext.NavigationInfo;\n    };\n}\nexport declare namespace BrowsingContext {\n    type Load = {\n        method: 'browsingContext.load';\n        params: BrowsingContext.NavigationInfo;\n    };\n}\nexport declare namespace BrowsingContext {\n    type DownloadWillBegin = {\n        method: 'browsingContext.downloadWillBegin';\n        params: BrowsingContext.DownloadWillBeginParams;\n    };\n}\nexport declare namespace BrowsingContext {\n    type DownloadWillBeginParams = {\n        suggestedFilename: string;\n    } & BrowsingContext.BaseNavigationInfo;\n}\nexport declare namespace BrowsingContext {\n    type DownloadEnd = {\n        method: 'browsingContext.downloadEnd';\n        params: BrowsingContext.DownloadEndParams;\n    };\n}\nexport declare namespace BrowsingContext {\n    type DownloadEndParams = BrowsingContext.DownloadCanceledParams | BrowsingContext.DownloadCompleteParams;\n}\nexport declare namespace BrowsingContext {\n    type DownloadCanceledParams = {\n        status: 'canceled';\n    } & BrowsingContext.BaseNavigationInfo;\n}\nexport declare namespace BrowsingContext {\n    type DownloadCompleteParams = {\n        status: 'complete';\n        filepath: string | null;\n    } & BrowsingContext.BaseNavigationInfo;\n}\nexport declare namespace BrowsingContext {\n    type NavigationAborted = {\n        method: 'browsingContext.navigationAborted';\n        params: BrowsingContext.NavigationInfo;\n    };\n}\nexport declare namespace BrowsingContext {\n    type NavigationCommitted = {\n        method: 'browsingContext.navigationCommitted';\n        params: BrowsingContext.NavigationInfo;\n    };\n}\nexport declare namespace BrowsingContext {\n    type NavigationFailed = {\n        method: 'browsingContext.navigationFailed';\n        params: BrowsingContext.NavigationInfo;\n    };\n}\nexport declare namespace BrowsingContext {\n    type UserPromptClosed = {\n        method: 'browsingContext.userPromptClosed';\n        params: BrowsingContext.UserPromptClosedParameters;\n    };\n}\nexport declare namespace BrowsingContext {\n    type UserPromptClosedParameters = {\n        context: BrowsingContext.BrowsingContext;\n        accepted: boolean;\n        type: BrowsingContext.UserPromptType;\n        userText?: string;\n    };\n}\nexport declare namespace BrowsingContext {\n    type UserPromptOpened = {\n        method: 'browsingContext.userPromptOpened';\n        params: BrowsingContext.UserPromptOpenedParameters;\n    };\n}\nexport declare namespace BrowsingContext {\n    type UserPromptOpenedParameters = {\n        context: BrowsingContext.BrowsingContext;\n        handler: Session.UserPromptHandlerType;\n        message: string;\n        type: BrowsingContext.UserPromptType;\n        defaultValue?: string;\n    };\n}\nexport type EmulationCommand = Emulation.SetForcedColorsModeThemeOverride | Emulation.SetGeolocationOverride | Emulation.SetLocaleOverride | Emulation.SetScreenOrientationOverride | Emulation.SetScriptingEnabled | Emulation.SetTimezoneOverride | Emulation.SetUserAgentOverride;\nexport type EmulationResult = Emulation.SetForcedColorsModeThemeOverrideResult | Emulation.SetGeolocationOverrideResult | Emulation.SetLocaleOverrideResult | Emulation.SetScreenOrientationOverrideResult | Emulation.SetScriptingEnabledResult | Emulation.SetTimezoneOverrideResult | Emulation.SetUserAgentOverrideResult;\nexport declare namespace Emulation {\n    type SetForcedColorsModeThemeOverride = {\n        method: 'emulation.setForcedColorsModeThemeOverride';\n        params: Emulation.SetForcedColorsModeThemeOverrideParameters;\n    };\n}\nexport declare namespace Emulation {\n    type SetForcedColorsModeThemeOverrideParameters = {\n        theme: Emulation.ForcedColorsModeTheme | null;\n        contexts?: [\n            BrowsingContext.BrowsingContext,\n            ...BrowsingContext.BrowsingContext[]\n        ];\n        userContexts?: [Browser.UserContext, ...Browser.UserContext[]];\n    };\n}\nexport declare namespace Emulation {\n    const enum ForcedColorsModeTheme {\n        Light = \"light\",\n        Dark = \"dark\"\n    }\n}\nexport declare namespace Emulation {\n    type SetForcedColorsModeThemeOverrideResult = EmptyResult;\n}\nexport declare namespace Emulation {\n    type SetGeolocationOverride = {\n        method: 'emulation.setGeolocationOverride';\n        params: Emulation.SetGeolocationOverrideParameters;\n    };\n}\nexport declare namespace Emulation {\n    type SetGeolocationOverrideParameters = ({\n        coordinates: Emulation.GeolocationCoordinates | null;\n    } | {\n        error: Emulation.GeolocationPositionError;\n    }) & {\n        contexts?: [\n            BrowsingContext.BrowsingContext,\n            ...BrowsingContext.BrowsingContext[]\n        ];\n        userContexts?: [Browser.UserContext, ...Browser.UserContext[]];\n    };\n}\nexport declare namespace Emulation {\n    type GeolocationCoordinates = {\n        /**\n         * Must be between `-90` and `90`, inclusive.\n         */\n        latitude: number;\n        /**\n         * Must be between `-180` and `180`, inclusive.\n         */\n        longitude: number;\n        /**\n         * Must be greater than or equal to `0`.\n         *\n         * @defaultValue `1`\n         */\n        accuracy?: number;\n        /**\n         * @defaultValue `null`\n         */\n        altitude?: number | null;\n        /**\n         * Must be greater than or equal to `0`.\n         *\n         * @defaultValue `null`\n         */\n        altitudeAccuracy?: number | null;\n        /**\n         * Must be between `0` and `360`.\n         *\n         * @defaultValue `null`\n         */\n        heading?: number | null;\n        /**\n         * Must be greater than or equal to `0`.\n         *\n         * @defaultValue `null`\n         */\n        speed?: number | null;\n    };\n}\nexport declare namespace Emulation {\n    type GeolocationPositionError = {\n        type: 'positionUnavailable';\n    };\n}\nexport declare namespace Emulation {\n    type SetGeolocationOverrideResult = EmptyResult;\n}\nexport declare namespace Emulation {\n    type SetLocaleOverride = {\n        method: 'emulation.setLocaleOverride';\n        params: Emulation.SetLocaleOverrideParameters;\n    };\n}\nexport declare namespace Emulation {\n    type SetLocaleOverrideParameters = {\n        locale: string | null;\n        contexts?: [\n            BrowsingContext.BrowsingContext,\n            ...BrowsingContext.BrowsingContext[]\n        ];\n        userContexts?: [Browser.UserContext, ...Browser.UserContext[]];\n    };\n}\nexport declare namespace Emulation {\n    type SetLocaleOverrideResult = EmptyResult;\n}\nexport declare namespace Emulation {\n    type SetScreenOrientationOverride = {\n        method: 'emulation.setScreenOrientationOverride';\n        params: Emulation.SetScreenOrientationOverrideParameters;\n    };\n}\nexport declare namespace Emulation {\n    const enum ScreenOrientationNatural {\n        Portrait = \"portrait\",\n        Landscape = \"landscape\"\n    }\n}\nexport declare namespace Emulation {\n    type ScreenOrientationType = 'portrait-primary' | 'portrait-secondary' | 'landscape-primary' | 'landscape-secondary';\n}\nexport declare namespace Emulation {\n    type ScreenOrientation = {\n        natural: Emulation.ScreenOrientationNatural;\n        type: Emulation.ScreenOrientationType;\n    };\n}\nexport declare namespace Emulation {\n    type SetScreenOrientationOverrideParameters = {\n        screenOrientation: Emulation.ScreenOrientation | null;\n        contexts?: [\n            BrowsingContext.BrowsingContext,\n            ...BrowsingContext.BrowsingContext[]\n        ];\n        userContexts?: [Browser.UserContext, ...Browser.UserContext[]];\n    };\n}\nexport declare namespace Emulation {\n    type SetScreenOrientationOverrideResult = EmptyResult;\n}\nexport declare namespace Emulation {\n    type SetUserAgentOverride = {\n        method: 'emulation.setUserAgentOverride';\n        params: Emulation.SetUserAgentOverrideParameters;\n    };\n}\nexport declare namespace Emulation {\n    type SetUserAgentOverrideParameters = {\n        userAgent: string | null;\n        contexts?: [\n            BrowsingContext.BrowsingContext,\n            ...BrowsingContext.BrowsingContext[]\n        ];\n        userContexts?: [Browser.UserContext, ...Browser.UserContext[]];\n    };\n}\nexport declare namespace Emulation {\n    type SetUserAgentOverrideResult = EmptyResult;\n}\nexport declare namespace Emulation {\n    type SetScriptingEnabled = {\n        method: 'emulation.setScriptingEnabled';\n        params: Emulation.SetScriptingEnabledParameters;\n    };\n}\nexport declare namespace Emulation {\n    type SetScriptingEnabledParameters = {\n        enabled: false | null;\n        contexts?: [\n            BrowsingContext.BrowsingContext,\n            ...BrowsingContext.BrowsingContext[]\n        ];\n        userContexts?: [Browser.UserContext, ...Browser.UserContext[]];\n    };\n}\nexport declare namespace Emulation {\n    type SetScriptingEnabledResult = EmptyResult;\n}\nexport declare namespace Emulation {\n    type SetTimezoneOverride = {\n        method: 'emulation.setTimezoneOverride';\n        params: Emulation.SetTimezoneOverrideParameters;\n    };\n}\nexport declare namespace Emulation {\n    type SetTimezoneOverrideParameters = {\n        timezone: string | null;\n        contexts?: [\n            BrowsingContext.BrowsingContext,\n            ...BrowsingContext.BrowsingContext[]\n        ];\n        userContexts?: [Browser.UserContext, ...Browser.UserContext[]];\n    };\n}\nexport declare namespace Emulation {\n    type SetTimezoneOverrideResult = EmptyResult;\n}\nexport type NetworkCommand = Network.AddDataCollector | Network.AddIntercept | Network.ContinueRequest | Network.ContinueResponse | Network.ContinueWithAuth | Network.DisownData | Network.FailRequest | Network.GetData | Network.ProvideResponse | Network.RemoveDataCollector | Network.RemoveIntercept | Network.SetCacheBehavior | Network.SetExtraHeaders;\nexport type NetworkResult = Network.AddDataCollectorResult | Network.AddInterceptResult | Network.ContinueRequestResult | Network.ContinueResponseResult | Network.ContinueWithAuthResult | Network.DisownDataResult | Network.FailRequestResult | Network.GetDataResult | Network.ProvideResponseResult | Network.RemoveDataCollectorResult | Network.RemoveInterceptResult | Network.SetCacheBehaviorResult | Network.SetExtraHeadersResult;\nexport type NetworkEvent = Network.AuthRequired | Network.BeforeRequestSent | Network.FetchError | Network.ResponseCompleted | Network.ResponseStarted;\nexport declare namespace Network {\n    type AuthChallenge = {\n        scheme: string;\n        realm: string;\n    };\n}\nexport declare namespace Network {\n    type AuthCredentials = {\n        type: 'password';\n        username: string;\n        password: string;\n    };\n}\nexport declare namespace Network {\n    type BaseParameters = {\n        context: BrowsingContext.BrowsingContext | null;\n        isBlocked: boolean;\n        navigation: BrowsingContext.Navigation | null;\n        redirectCount: JsUint;\n        request: Network.RequestData;\n        timestamp: JsUint;\n        intercepts?: [Network.Intercept, ...Network.Intercept[]];\n    };\n}\nexport declare namespace Network {\n    type BytesValue = Network.StringValue | Network.Base64Value;\n}\nexport declare namespace Network {\n    type StringValue = {\n        type: 'string';\n        value: string;\n    };\n}\nexport declare namespace Network {\n    type Base64Value = {\n        type: 'base64';\n        value: string;\n    };\n}\nexport declare namespace Network {\n    type Collector = string;\n}\nexport declare namespace Network {\n    const enum CollectorType {\n        Blob = \"blob\"\n    }\n}\nexport declare namespace Network {\n    const enum SameSite {\n        Strict = \"strict\",\n        Lax = \"lax\",\n        None = \"none\",\n        Default = \"default\"\n    }\n}\nexport declare namespace Network {\n    type Cookie = {\n        name: string;\n        value: Network.BytesValue;\n        domain: string;\n        path: string;\n        size: JsUint;\n        httpOnly: boolean;\n        secure: boolean;\n        sameSite: Network.SameSite;\n        expiry?: JsUint;\n    } & Extensible;\n}\nexport declare namespace Network {\n    type CookieHeader = {\n        name: string;\n        value: Network.BytesValue;\n    };\n}\nexport declare namespace Network {\n    const enum DataType {\n        Response = \"response\"\n    }\n}\nexport declare namespace Network {\n    type FetchTimingInfo = {\n        timeOrigin: number;\n        requestTime: number;\n        redirectStart: number;\n        redirectEnd: number;\n        fetchStart: number;\n        dnsStart: number;\n        dnsEnd: number;\n        connectStart: number;\n        connectEnd: number;\n        tlsStart: number;\n        requestStart: number;\n        responseStart: number;\n        responseEnd: number;\n    };\n}\nexport declare namespace Network {\n    type Header = {\n        name: string;\n        value: Network.BytesValue;\n    };\n}\nexport declare namespace Network {\n    type Initiator = {\n        columnNumber?: JsUint;\n        lineNumber?: JsUint;\n        request?: Network.Request;\n        stackTrace?: Script.StackTrace;\n        type?: 'parser' | 'script' | 'preflight' | 'other';\n    };\n}\nexport declare namespace Network {\n    type Intercept = string;\n}\nexport declare namespace Network {\n    type Request = string;\n}\nexport declare namespace Network {\n    type RequestData = {\n        request: Network.Request;\n        url: string;\n        method: string;\n        headers: [...Network.Header[]];\n        cookies: [...Network.Cookie[]];\n        headersSize: JsUint;\n        bodySize: JsUint | null;\n        destination: string;\n        initiatorType: string | null;\n        timings: Network.FetchTimingInfo;\n    };\n}\nexport declare namespace Network {\n    type ResponseContent = {\n        size: JsUint;\n    };\n}\nexport declare namespace Network {\n    type ResponseData = {\n        url: string;\n        protocol: string;\n        status: JsUint;\n        statusText: string;\n        fromCache: boolean;\n        headers: [...Network.Header[]];\n        mimeType: string;\n        bytesReceived: JsUint;\n        headersSize: JsUint | null;\n        bodySize: JsUint | null;\n        content: Network.ResponseContent;\n        authChallenges?: [...Network.AuthChallenge[]];\n    };\n}\nexport declare namespace Network {\n    type SetCookieHeader = {\n        name: string;\n        value: Network.BytesValue;\n        domain?: string;\n        httpOnly?: boolean;\n        expiry?: string;\n        maxAge?: JsInt;\n        path?: string;\n        sameSite?: Network.SameSite;\n        secure?: boolean;\n    };\n}\nexport declare namespace Network {\n    type UrlPattern = Network.UrlPatternPattern | Network.UrlPatternString;\n}\nexport declare namespace Network {\n    type UrlPatternPattern = {\n        type: 'pattern';\n        protocol?: string;\n        hostname?: string;\n        port?: string;\n        pathname?: string;\n        search?: string;\n    };\n}\nexport declare namespace Network {\n    type UrlPatternString = {\n        type: 'string';\n        pattern: string;\n    };\n}\nexport declare namespace Network {\n    type AddDataCollector = {\n        method: 'network.addDataCollector';\n        params: Network.AddDataCollectorParameters;\n    };\n}\nexport declare namespace Network {\n    type AddDataCollectorParameters = {\n        dataTypes: [Network.DataType, ...Network.DataType[]];\n        maxEncodedDataSize: JsUint;\n        /**\n         * @defaultValue `\"blob\"`\n         */\n        collectorType?: Network.CollectorType;\n        contexts?: [\n            BrowsingContext.BrowsingContext,\n            ...BrowsingContext.BrowsingContext[]\n        ];\n        userContexts?: [Browser.UserContext, ...Browser.UserContext[]];\n    };\n}\nexport declare namespace Network {\n    type AddDataCollectorResult = {\n        collector: Network.Collector;\n    };\n}\nexport declare namespace Network {\n    type AddIntercept = {\n        method: 'network.addIntercept';\n        params: Network.AddInterceptParameters;\n    };\n}\nexport declare namespace Network {\n    type AddInterceptParameters = {\n        phases: [Network.InterceptPhase, ...Network.InterceptPhase[]];\n        contexts?: [\n            BrowsingContext.BrowsingContext,\n            ...BrowsingContext.BrowsingContext[]\n        ];\n        urlPatterns?: [...Network.UrlPattern[]];\n    };\n}\nexport declare namespace Network {\n    const enum InterceptPhase {\n        BeforeRequestSent = \"beforeRequestSent\",\n        ResponseStarted = \"responseStarted\",\n        AuthRequired = \"authRequired\"\n    }\n}\nexport declare namespace Network {\n    type AddInterceptResult = {\n        intercept: Network.Intercept;\n    };\n}\nexport declare namespace Network {\n    type ContinueRequest = {\n        method: 'network.continueRequest';\n        params: Network.ContinueRequestParameters;\n    };\n}\nexport declare namespace Network {\n    type ContinueRequestParameters = {\n        request: Network.Request;\n        body?: Network.BytesValue;\n        cookies?: [...Network.CookieHeader[]];\n        headers?: [...Network.Header[]];\n        method?: string;\n        url?: string;\n    };\n}\nexport declare namespace Network {\n    type ContinueRequestResult = EmptyResult;\n}\nexport declare namespace Network {\n    type ContinueResponse = {\n        method: 'network.continueResponse';\n        params: Network.ContinueResponseParameters;\n    };\n}\nexport declare namespace Network {\n    type ContinueResponseParameters = {\n        request: Network.Request;\n        cookies?: [...Network.SetCookieHeader[]];\n        credentials?: Network.AuthCredentials;\n        headers?: [...Network.Header[]];\n        reasonPhrase?: string;\n        statusCode?: JsUint;\n    };\n}\nexport declare namespace Network {\n    type ContinueResponseResult = EmptyResult;\n}\nexport declare namespace Network {\n    type ContinueWithAuth = {\n        method: 'network.continueWithAuth';\n        params: Network.ContinueWithAuthParameters;\n    };\n}\nexport declare namespace Network {\n    type ContinueWithAuthParameters = {\n        request: Network.Request;\n    } & (Network.ContinueWithAuthCredentials | Network.ContinueWithAuthNoCredentials);\n}\nexport declare namespace Network {\n    type ContinueWithAuthCredentials = {\n        action: 'provideCredentials';\n        credentials: Network.AuthCredentials;\n    };\n}\nexport declare namespace Network {\n    type ContinueWithAuthNoCredentials = {\n        action: 'default' | 'cancel';\n    };\n}\nexport declare namespace Network {\n    type ContinueWithAuthResult = EmptyResult;\n}\nexport declare namespace Network {\n    type DisownData = {\n        method: 'network.disownData';\n        params: Network.DisownDataParameters;\n    };\n}\nexport declare namespace Network {\n    type DisownDataParameters = {\n        dataType: Network.DataType;\n        collector: Network.Collector;\n        request: Network.Request;\n    };\n}\nexport declare namespace Network {\n    type DisownDataResult = EmptyResult;\n}\nexport declare namespace Network {\n    type FailRequest = {\n        method: 'network.failRequest';\n        params: Network.FailRequestParameters;\n    };\n}\nexport declare namespace Network {\n    type FailRequestParameters = {\n        request: Network.Request;\n    };\n}\nexport declare namespace Network {\n    type FailRequestResult = EmptyResult;\n}\nexport declare namespace Network {\n    type GetData = {\n        method: 'network.getData';\n        params: Network.GetDataParameters;\n    };\n}\nexport declare namespace Network {\n    type GetDataParameters = {\n        dataType: Network.DataType;\n        collector?: Network.Collector;\n        /**\n         * @defaultValue `false`\n         */\n        disown?: boolean;\n        request: Network.Request;\n    };\n}\nexport declare namespace Network {\n    type GetDataResult = {\n        bytes: Network.BytesValue;\n    };\n}\nexport declare namespace Network {\n    type ProvideResponse = {\n        method: 'network.provideResponse';\n        params: Network.ProvideResponseParameters;\n    };\n}\nexport declare namespace Network {\n    type ProvideResponseParameters = {\n        request: Network.Request;\n        body?: Network.BytesValue;\n        cookies?: [...Network.SetCookieHeader[]];\n        headers?: [...Network.Header[]];\n        reasonPhrase?: string;\n        statusCode?: JsUint;\n    };\n}\nexport declare namespace Network {\n    type ProvideResponseResult = EmptyResult;\n}\nexport declare namespace Network {\n    type RemoveDataCollector = {\n        method: 'network.removeDataCollector';\n        params: Network.RemoveDataCollectorParameters;\n    };\n}\nexport declare namespace Network {\n    type RemoveDataCollectorParameters = {\n        collector: Network.Collector;\n    };\n}\nexport declare namespace Network {\n    type RemoveDataCollectorResult = EmptyResult;\n}\nexport declare namespace Network {\n    type RemoveIntercept = {\n        method: 'network.removeIntercept';\n        params: Network.RemoveInterceptParameters;\n    };\n}\nexport declare namespace Network {\n    type RemoveInterceptParameters = {\n        intercept: Network.Intercept;\n    };\n}\nexport declare namespace Network {\n    type RemoveInterceptResult = EmptyResult;\n}\nexport declare namespace Network {\n    type SetCacheBehavior = {\n        method: 'network.setCacheBehavior';\n        params: Network.SetCacheBehaviorParameters;\n    };\n}\nexport declare namespace Network {\n    type SetCacheBehaviorParameters = {\n        cacheBehavior: 'default' | 'bypass';\n        contexts?: [\n            BrowsingContext.BrowsingContext,\n            ...BrowsingContext.BrowsingContext[]\n        ];\n    };\n}\nexport declare namespace Network {\n    type SetCacheBehaviorResult = EmptyResult;\n}\nexport declare namespace Network {\n    type SetExtraHeaders = {\n        method: 'network.setExtraHeaders';\n        params: Network.SetExtraHeadersParameters;\n    };\n}\nexport declare namespace Network {\n    type SetExtraHeadersParameters = {\n        headers: [...Network.Header[]];\n        contexts?: [\n            BrowsingContext.BrowsingContext,\n            ...BrowsingContext.BrowsingContext[]\n        ];\n        userContexts?: [Browser.UserContext, ...Browser.UserContext[]];\n    };\n}\nexport declare namespace Network {\n    type SetExtraHeadersResult = EmptyResult;\n}\nexport declare namespace Network {\n    type AuthRequired = {\n        method: 'network.authRequired';\n        params: Network.AuthRequiredParameters;\n    };\n}\nexport declare namespace Network {\n    type AuthRequiredParameters = Network.BaseParameters & {\n        response: Network.ResponseData;\n    };\n}\nexport declare namespace Network {\n    type BeforeRequestSent = {\n        method: 'network.beforeRequestSent';\n        params: Network.BeforeRequestSentParameters;\n    };\n}\nexport declare namespace Network {\n    type BeforeRequestSentParameters = Network.BaseParameters & {\n        initiator?: Network.Initiator;\n    };\n}\nexport declare namespace Network {\n    type FetchError = {\n        method: 'network.fetchError';\n        params: Network.FetchErrorParameters;\n    };\n}\nexport declare namespace Network {\n    type FetchErrorParameters = Network.BaseParameters & {\n        errorText: string;\n    };\n}\nexport declare namespace Network {\n    type ResponseCompleted = {\n        method: 'network.responseCompleted';\n        params: Network.ResponseCompletedParameters;\n    };\n}\nexport declare namespace Network {\n    type ResponseCompletedParameters = Network.BaseParameters & {\n        response: Network.ResponseData;\n    };\n}\nexport declare namespace Network {\n    type ResponseStarted = {\n        method: 'network.responseStarted';\n        params: Network.ResponseStartedParameters;\n    };\n}\nexport declare namespace Network {\n    type ResponseStartedParameters = Network.BaseParameters & {\n        response: Network.ResponseData;\n    };\n}\nexport type ScriptCommand = Script.AddPreloadScript | Script.CallFunction | Script.Disown | Script.Evaluate | Script.GetRealms | Script.RemovePreloadScript;\nexport type ScriptResult = Script.AddPreloadScriptResult | Script.CallFunctionResult | Script.DisownResult | Script.EvaluateResult | Script.GetRealmsResult | Script.RemovePreloadScriptResult;\nexport type ScriptEvent = Script.Message | Script.RealmCreated | Script.RealmDestroyed;\nexport declare namespace Script {\n    type Channel = string;\n}\nexport declare namespace Script {\n    type ChannelValue = {\n        type: 'channel';\n        value: Script.ChannelProperties;\n    };\n}\nexport declare namespace Script {\n    type ChannelProperties = {\n        channel: Script.Channel;\n        serializationOptions?: Script.SerializationOptions;\n        ownership?: Script.ResultOwnership;\n    };\n}\nexport declare namespace Script {\n    type EvaluateResult = Script.EvaluateResultSuccess | Script.EvaluateResultException;\n}\nexport declare namespace Script {\n    type EvaluateResultSuccess = {\n        type: 'success';\n        result: Script.RemoteValue;\n        realm: Script.Realm;\n    };\n}\nexport declare namespace Script {\n    type EvaluateResultException = {\n        type: 'exception';\n        exceptionDetails: Script.ExceptionDetails;\n        realm: Script.Realm;\n    };\n}\nexport declare namespace Script {\n    type ExceptionDetails = {\n        columnNumber: JsUint;\n        exception: Script.RemoteValue;\n        lineNumber: JsUint;\n        stackTrace: Script.StackTrace;\n        text: string;\n    };\n}\nexport declare namespace Script {\n    type Handle = string;\n}\nexport declare namespace Script {\n    type InternalId = string;\n}\nexport declare namespace Script {\n    type LocalValue = Script.RemoteReference | Script.PrimitiveProtocolValue | Script.ChannelValue | Script.ArrayLocalValue | Script.DateLocalValue | Script.MapLocalValue | Script.ObjectLocalValue | Script.RegExpLocalValue | Script.SetLocalValue;\n}\nexport declare namespace Script {\n    type ListLocalValue = [...Script.LocalValue[]];\n}\nexport declare namespace Script {\n    type ArrayLocalValue = {\n        type: 'array';\n        value: Script.ListLocalValue;\n    };\n}\nexport declare namespace Script {\n    type DateLocalValue = {\n        type: 'date';\n        value: string;\n    };\n}\nexport declare namespace Script {\n    type MappingLocalValue = [\n        ...[Script.LocalValue | string, Script.LocalValue][]\n    ];\n}\nexport declare namespace Script {\n    type MapLocalValue = {\n        type: 'map';\n        value: Script.MappingLocalValue;\n    };\n}\nexport declare namespace Script {\n    type ObjectLocalValue = {\n        type: 'object';\n        value: Script.MappingLocalValue;\n    };\n}\nexport declare namespace Script {\n    type RegExpValue = {\n        pattern: string;\n        flags?: string;\n    };\n}\nexport declare namespace Script {\n    type RegExpLocalValue = {\n        type: 'regexp';\n        value: Script.RegExpValue;\n    };\n}\nexport declare namespace Script {\n    type SetLocalValue = {\n        type: 'set';\n        value: Script.ListLocalValue;\n    };\n}\nexport declare namespace Script {\n    type PreloadScript = string;\n}\nexport declare namespace Script {\n    type Realm = string;\n}\nexport declare namespace Script {\n    type PrimitiveProtocolValue = Script.UndefinedValue | Script.NullValue | Script.StringValue | Script.NumberValue | Script.BooleanValue | Script.BigIntValue;\n}\nexport declare namespace Script {\n    type UndefinedValue = {\n        type: 'undefined';\n    };\n}\nexport declare namespace Script {\n    type NullValue = {\n        type: 'null';\n    };\n}\nexport declare namespace Script {\n    type StringValue = {\n        type: 'string';\n        value: string;\n    };\n}\nexport declare namespace Script {\n    type SpecialNumber = 'NaN' | '-0' | 'Infinity' | '-Infinity';\n}\nexport declare namespace Script {\n    type NumberValue = {\n        type: 'number';\n        value: number | Script.SpecialNumber;\n    };\n}\nexport declare namespace Script {\n    type BooleanValue = {\n        type: 'boolean';\n        value: boolean;\n    };\n}\nexport declare namespace Script {\n    type BigIntValue = {\n        type: 'bigint';\n        value: string;\n    };\n}\nexport declare namespace Script {\n    type RealmInfo = Script.WindowRealmInfo | Script.DedicatedWorkerRealmInfo | Script.SharedWorkerRealmInfo | Script.ServiceWorkerRealmInfo | Script.WorkerRealmInfo | Script.PaintWorkletRealmInfo | Script.AudioWorkletRealmInfo | Script.WorkletRealmInfo;\n}\nexport declare namespace Script {\n    type BaseRealmInfo = {\n        realm: Script.Realm;\n        origin: string;\n    };\n}\nexport declare namespace Script {\n    type WindowRealmInfo = Script.BaseRealmInfo & {\n        type: 'window';\n        context: BrowsingContext.BrowsingContext;\n        sandbox?: string;\n    };\n}\nexport declare namespace Script {\n    type DedicatedWorkerRealmInfo = Script.BaseRealmInfo & {\n        type: 'dedicated-worker';\n        owners: [Script.Realm];\n    };\n}\nexport declare namespace Script {\n    type SharedWorkerRealmInfo = Script.BaseRealmInfo & {\n        type: 'shared-worker';\n    };\n}\nexport declare namespace Script {\n    type ServiceWorkerRealmInfo = Script.BaseRealmInfo & {\n        type: 'service-worker';\n    };\n}\nexport declare namespace Script {\n    type WorkerRealmInfo = Script.BaseRealmInfo & {\n        type: 'worker';\n    };\n}\nexport declare namespace Script {\n    type PaintWorkletRealmInfo = Script.BaseRealmInfo & {\n        type: 'paint-worklet';\n    };\n}\nexport declare namespace Script {\n    type AudioWorkletRealmInfo = Script.BaseRealmInfo & {\n        type: 'audio-worklet';\n    };\n}\nexport declare namespace Script {\n    type WorkletRealmInfo = Script.BaseRealmInfo & {\n        type: 'worklet';\n    };\n}\nexport declare namespace Script {\n    type RealmType = 'window' | 'dedicated-worker' | 'shared-worker' | 'service-worker' | 'worker' | 'paint-worklet' | 'audio-worklet' | 'worklet';\n}\nexport declare namespace Script {\n    type RemoteReference = Script.SharedReference | Script.RemoteObjectReference;\n}\nexport declare namespace Script {\n    type SharedReference = {\n        sharedId: Script.SharedId;\n        handle?: Script.Handle;\n    } & Extensible;\n}\nexport declare namespace Script {\n    type RemoteObjectReference = {\n        handle: Script.Handle;\n        sharedId?: Script.SharedId;\n    } & Extensible;\n}\nexport declare namespace Script {\n    type RemoteValue = Script.PrimitiveProtocolValue | Script.SymbolRemoteValue | Script.ArrayRemoteValue | Script.ObjectRemoteValue | Script.FunctionRemoteValue | Script.RegExpRemoteValue | Script.DateRemoteValue | Script.MapRemoteValue | Script.SetRemoteValue | Script.WeakMapRemoteValue | Script.WeakSetRemoteValue | Script.GeneratorRemoteValue | Script.ErrorRemoteValue | Script.ProxyRemoteValue | Script.PromiseRemoteValue | Script.TypedArrayRemoteValue | Script.ArrayBufferRemoteValue | Script.NodeListRemoteValue | Script.HtmlCollectionRemoteValue | Script.NodeRemoteValue | Script.WindowProxyRemoteValue;\n}\nexport declare namespace Script {\n    type ListRemoteValue = [...Script.RemoteValue[]];\n}\nexport declare namespace Script {\n    type MappingRemoteValue = [\n        ...[Script.RemoteValue | string, Script.RemoteValue][]\n    ];\n}\nexport declare namespace Script {\n    type SymbolRemoteValue = {\n        type: 'symbol';\n        handle?: Script.Handle;\n        internalId?: Script.InternalId;\n    };\n}\nexport declare namespace Script {\n    type ArrayRemoteValue = {\n        type: 'array';\n        handle?: Script.Handle;\n        internalId?: Script.InternalId;\n        value?: Script.ListRemoteValue;\n    };\n}\nexport declare namespace Script {\n    type ObjectRemoteValue = {\n        type: 'object';\n        handle?: Script.Handle;\n        internalId?: Script.InternalId;\n        value?: Script.MappingRemoteValue;\n    };\n}\nexport declare namespace Script {\n    type FunctionRemoteValue = {\n        type: 'function';\n        handle?: Script.Handle;\n        internalId?: Script.InternalId;\n    };\n}\nexport declare namespace Script {\n    type RegExpRemoteValue = Script.RegExpLocalValue & {\n        handle?: Script.Handle;\n        internalId?: Script.InternalId;\n    };\n}\nexport declare namespace Script {\n    type DateRemoteValue = Script.DateLocalValue & {\n        handle?: Script.Handle;\n        internalId?: Script.InternalId;\n    };\n}\nexport declare namespace Script {\n    type MapRemoteValue = {\n        type: 'map';\n        handle?: Script.Handle;\n        internalId?: Script.InternalId;\n        value?: Script.MappingRemoteValue;\n    };\n}\nexport declare namespace Script {\n    type SetRemoteValue = {\n        type: 'set';\n        handle?: Script.Handle;\n        internalId?: Script.InternalId;\n        value?: Script.ListRemoteValue;\n    };\n}\nexport declare namespace Script {\n    type WeakMapRemoteValue = {\n        type: 'weakmap';\n        handle?: Script.Handle;\n        internalId?: Script.InternalId;\n    };\n}\nexport declare namespace Script {\n    type WeakSetRemoteValue = {\n        type: 'weakset';\n        handle?: Script.Handle;\n        internalId?: Script.InternalId;\n    };\n}\nexport declare namespace Script {\n    type GeneratorRemoteValue = {\n        type: 'generator';\n        handle?: Script.Handle;\n        internalId?: Script.InternalId;\n    };\n}\nexport declare namespace Script {\n    type ErrorRemoteValue = {\n        type: 'error';\n        handle?: Script.Handle;\n        internalId?: Script.InternalId;\n    };\n}\nexport declare namespace Script {\n    type ProxyRemoteValue = {\n        type: 'proxy';\n        handle?: Script.Handle;\n        internalId?: Script.InternalId;\n    };\n}\nexport declare namespace Script {\n    type PromiseRemoteValue = {\n        type: 'promise';\n        handle?: Script.Handle;\n        internalId?: Script.InternalId;\n    };\n}\nexport declare namespace Script {\n    type TypedArrayRemoteValue = {\n        type: 'typedarray';\n        handle?: Script.Handle;\n        internalId?: Script.InternalId;\n    };\n}\nexport declare namespace Script {\n    type ArrayBufferRemoteValue = {\n        type: 'arraybuffer';\n        handle?: Script.Handle;\n        internalId?: Script.InternalId;\n    };\n}\nexport declare namespace Script {\n    type NodeListRemoteValue = {\n        type: 'nodelist';\n        handle?: Script.Handle;\n        internalId?: Script.InternalId;\n        value?: Script.ListRemoteValue;\n    };\n}\nexport declare namespace Script {\n    type HtmlCollectionRemoteValue = {\n        type: 'htmlcollection';\n        handle?: Script.Handle;\n        internalId?: Script.InternalId;\n        value?: Script.ListRemoteValue;\n    };\n}\nexport declare namespace Script {\n    type NodeRemoteValue = {\n        type: 'node';\n        sharedId?: Script.SharedId;\n        handle?: Script.Handle;\n        internalId?: Script.InternalId;\n        value?: Script.NodeProperties;\n    };\n}\nexport declare namespace Script {\n    type NodeProperties = {\n        nodeType: JsUint;\n        childNodeCount: JsUint;\n        attributes?: {\n            [key: string]: string;\n        };\n        children?: [...Script.NodeRemoteValue[]];\n        localName?: string;\n        mode?: 'open' | 'closed';\n        namespaceURI?: string;\n        nodeValue?: string;\n        shadowRoot?: Script.NodeRemoteValue | null;\n    };\n}\nexport declare namespace Script {\n    type WindowProxyRemoteValue = {\n        type: 'window';\n        value: Script.WindowProxyProperties;\n        handle?: Script.Handle;\n        internalId?: Script.InternalId;\n    };\n}\nexport declare namespace Script {\n    type WindowProxyProperties = {\n        context: BrowsingContext.BrowsingContext;\n    };\n}\nexport declare namespace Script {\n    const enum ResultOwnership {\n        Root = \"root\",\n        None = \"none\"\n    }\n}\nexport declare namespace Script {\n    type SerializationOptions = {\n        /**\n         * @defaultValue `0`\n         */\n        maxDomDepth?: JsUint | null;\n        /**\n         * @defaultValue `null`\n         */\n        maxObjectDepth?: JsUint | null;\n        /**\n         * @defaultValue `\"none\"`\n         */\n        includeShadowTree?: 'none' | 'open' | 'all';\n    };\n}\nexport declare namespace Script {\n    type SharedId = string;\n}\nexport declare namespace Script {\n    type StackFrame = {\n        columnNumber: JsUint;\n        functionName: string;\n        lineNumber: JsUint;\n        url: string;\n    };\n}\nexport declare namespace Script {\n    type StackTrace = {\n        callFrames: [...Script.StackFrame[]];\n    };\n}\nexport declare namespace Script {\n    type Source = {\n        realm: Script.Realm;\n        context?: BrowsingContext.BrowsingContext;\n    };\n}\nexport declare namespace Script {\n    type RealmTarget = {\n        realm: Script.Realm;\n    };\n}\nexport declare namespace Script {\n    type ContextTarget = {\n        context: BrowsingContext.BrowsingContext;\n        sandbox?: string;\n    };\n}\nexport declare namespace Script {\n    type Target = Script.ContextTarget | Script.RealmTarget;\n}\nexport declare namespace Script {\n    type AddPreloadScript = {\n        method: 'script.addPreloadScript';\n        params: Script.AddPreloadScriptParameters;\n    };\n}\nexport declare namespace Script {\n    type AddPreloadScriptParameters = {\n        functionDeclaration: string;\n        arguments?: [...Script.ChannelValue[]];\n        contexts?: [\n            BrowsingContext.BrowsingContext,\n            ...BrowsingContext.BrowsingContext[]\n        ];\n        userContexts?: [Browser.UserContext, ...Browser.UserContext[]];\n        sandbox?: string;\n    };\n}\nexport declare namespace Script {\n    type AddPreloadScriptResult = {\n        script: Script.PreloadScript;\n    };\n}\nexport declare namespace Script {\n    type Disown = {\n        method: 'script.disown';\n        params: Script.DisownParameters;\n    };\n}\nexport declare namespace Script {\n    type DisownParameters = {\n        handles: [...Script.Handle[]];\n        target: Script.Target;\n    };\n}\nexport declare namespace Script {\n    type DisownResult = EmptyResult;\n}\nexport declare namespace Script {\n    type CallFunction = {\n        method: 'script.callFunction';\n        params: Script.CallFunctionParameters;\n    };\n}\nexport declare namespace Script {\n    type CallFunctionParameters = {\n        functionDeclaration: string;\n        awaitPromise: boolean;\n        target: Script.Target;\n        arguments?: [...Script.LocalValue[]];\n        resultOwnership?: Script.ResultOwnership;\n        serializationOptions?: Script.SerializationOptions;\n        this?: Script.LocalValue;\n        /**\n         * @defaultValue `false`\n         */\n        userActivation?: boolean;\n    };\n}\nexport declare namespace Script {\n    type CallFunctionResult = Script.EvaluateResult;\n}\nexport declare namespace Script {\n    type Evaluate = {\n        method: 'script.evaluate';\n        params: Script.EvaluateParameters;\n    };\n}\nexport declare namespace Script {\n    type EvaluateParameters = {\n        expression: string;\n        target: Script.Target;\n        awaitPromise: boolean;\n        resultOwnership?: Script.ResultOwnership;\n        serializationOptions?: Script.SerializationOptions;\n        /**\n         * @defaultValue `false`\n         */\n        userActivation?: boolean;\n    };\n}\nexport declare namespace Script {\n    type GetRealms = {\n        method: 'script.getRealms';\n        params: Script.GetRealmsParameters;\n    };\n}\nexport declare namespace Script {\n    type GetRealmsParameters = {\n        context?: BrowsingContext.BrowsingContext;\n        type?: Script.RealmType;\n    };\n}\nexport declare namespace Script {\n    type GetRealmsResult = {\n        realms: [...Script.RealmInfo[]];\n    };\n}\nexport declare namespace Script {\n    type RemovePreloadScript = {\n        method: 'script.removePreloadScript';\n        params: Script.RemovePreloadScriptParameters;\n    };\n}\nexport declare namespace Script {\n    type RemovePreloadScriptParameters = {\n        script: Script.PreloadScript;\n    };\n}\nexport declare namespace Script {\n    type RemovePreloadScriptResult = EmptyResult;\n}\nexport declare namespace Script {\n    type Message = {\n        method: 'script.message';\n        params: Script.MessageParameters;\n    };\n}\nexport declare namespace Script {\n    type MessageParameters = {\n        channel: Script.Channel;\n        data: Script.RemoteValue;\n        source: Script.Source;\n    };\n}\nexport declare namespace Script {\n    type RealmCreated = {\n        method: 'script.realmCreated';\n        params: Script.RealmInfo;\n    };\n}\nexport declare namespace Script {\n    type RealmDestroyed = {\n        method: 'script.realmDestroyed';\n        params: Script.RealmDestroyedParameters;\n    };\n}\nexport declare namespace Script {\n    type RealmDestroyedParameters = {\n        realm: Script.Realm;\n    };\n}\nexport type StorageCommand = Storage.DeleteCookies | Storage.GetCookies | Storage.SetCookie;\nexport type StorageResult = Storage.DeleteCookiesResult | Storage.GetCookiesResult | Storage.SetCookieResult;\nexport declare namespace Storage {\n    type PartitionKey = {\n        userContext?: string;\n        sourceOrigin?: string;\n    } & Extensible;\n}\nexport declare namespace Storage {\n    type GetCookies = {\n        method: 'storage.getCookies';\n        params: Storage.GetCookiesParameters;\n    };\n}\nexport declare namespace Storage {\n    type CookieFilter = {\n        name?: string;\n        value?: Network.BytesValue;\n        domain?: string;\n        path?: string;\n        size?: JsUint;\n        httpOnly?: boolean;\n        secure?: boolean;\n        sameSite?: Network.SameSite;\n        expiry?: JsUint;\n    } & Extensible;\n}\nexport declare namespace Storage {\n    type BrowsingContextPartitionDescriptor = {\n        type: 'context';\n        context: BrowsingContext.BrowsingContext;\n    };\n}\nexport declare namespace Storage {\n    type StorageKeyPartitionDescriptor = {\n        type: 'storageKey';\n        userContext?: string;\n        sourceOrigin?: string;\n    } & Extensible;\n}\nexport declare namespace Storage {\n    type PartitionDescriptor = Storage.BrowsingContextPartitionDescriptor | Storage.StorageKeyPartitionDescriptor;\n}\nexport declare namespace Storage {\n    type GetCookiesParameters = {\n        filter?: Storage.CookieFilter;\n        partition?: Storage.PartitionDescriptor;\n    };\n}\nexport declare namespace Storage {\n    type GetCookiesResult = {\n        cookies: [...Network.Cookie[]];\n        partitionKey: Storage.PartitionKey;\n    };\n}\nexport declare namespace Storage {\n    type SetCookie = {\n        method: 'storage.setCookie';\n        params: Storage.SetCookieParameters;\n    };\n}\nexport declare namespace Storage {\n    type PartialCookie = {\n        name: string;\n        value: Network.BytesValue;\n        domain: string;\n        path?: string;\n        httpOnly?: boolean;\n        secure?: boolean;\n        sameSite?: Network.SameSite;\n        expiry?: JsUint;\n    } & Extensible;\n}\nexport declare namespace Storage {\n    type SetCookieParameters = {\n        cookie: Storage.PartialCookie;\n        partition?: Storage.PartitionDescriptor;\n    };\n}\nexport declare namespace Storage {\n    type SetCookieResult = {\n        partitionKey: Storage.PartitionKey;\n    };\n}\nexport declare namespace Storage {\n    type DeleteCookies = {\n        method: 'storage.deleteCookies';\n        params: Storage.DeleteCookiesParameters;\n    };\n}\nexport declare namespace Storage {\n    type DeleteCookiesParameters = {\n        filter?: Storage.CookieFilter;\n        partition?: Storage.PartitionDescriptor;\n    };\n}\nexport declare namespace Storage {\n    type DeleteCookiesResult = {\n        partitionKey: Storage.PartitionKey;\n    };\n}\nexport type LogEvent = Log.EntryAdded;\nexport declare namespace Log {\n    const enum Level {\n        Debug = \"debug\",\n        Info = \"info\",\n        Warn = \"warn\",\n        Error = \"error\"\n    }\n}\nexport declare namespace Log {\n    type Entry = Log.GenericLogEntry | Log.ConsoleLogEntry | Log.JavascriptLogEntry;\n}\nexport declare namespace Log {\n    type BaseLogEntry = {\n        level: Log.Level;\n        source: Script.Source;\n        text: string | null;\n        timestamp: JsUint;\n        stackTrace?: Script.StackTrace;\n    };\n}\nexport declare namespace Log {\n    type GenericLogEntry = Log.BaseLogEntry & {\n        type: string;\n    };\n}\nexport declare namespace Log {\n    type ConsoleLogEntry = Log.BaseLogEntry & {\n        type: 'console';\n        method: string;\n        args: [...Script.RemoteValue[]];\n    };\n}\nexport declare namespace Log {\n    type JavascriptLogEntry = Log.BaseLogEntry & {\n        type: 'javascript';\n    };\n}\nexport declare namespace Log {\n    type EntryAdded = {\n        method: 'log.entryAdded';\n        params: Log.Entry;\n    };\n}\nexport type InputCommand = Input.PerformActions | Input.ReleaseActions | Input.SetFiles;\nexport type InputResult = Input.PerformActionsResult | Input.ReleaseActionsResult | Input.SetFilesResult;\nexport type InputEvent = Input.FileDialogOpened;\nexport declare namespace Input {\n    type ElementOrigin = {\n        type: 'element';\n        element: Script.SharedReference;\n    };\n}\nexport declare namespace Input {\n    type PerformActions = {\n        method: 'input.performActions';\n        params: Input.PerformActionsParameters;\n    };\n}\nexport declare namespace Input {\n    type PerformActionsParameters = {\n        context: BrowsingContext.BrowsingContext;\n        actions: [...Input.SourceActions[]];\n    };\n}\nexport declare namespace Input {\n    type SourceActions = Input.NoneSourceActions | Input.KeySourceActions | Input.PointerSourceActions | Input.WheelSourceActions;\n}\nexport declare namespace Input {\n    type NoneSourceActions = {\n        type: 'none';\n        id: string;\n        actions: [...Input.NoneSourceAction[]];\n    };\n}\nexport declare namespace Input {\n    type NoneSourceAction = Input.PauseAction;\n}\nexport declare namespace Input {\n    type KeySourceActions = {\n        type: 'key';\n        id: string;\n        actions: [...Input.KeySourceAction[]];\n    };\n}\nexport declare namespace Input {\n    type KeySourceAction = Input.PauseAction | Input.KeyDownAction | Input.KeyUpAction;\n}\nexport declare namespace Input {\n    type PointerSourceActions = {\n        type: 'pointer';\n        id: string;\n        parameters?: Input.PointerParameters;\n        actions: [...Input.PointerSourceAction[]];\n    };\n}\nexport declare namespace Input {\n    const enum PointerType {\n        Mouse = \"mouse\",\n        Pen = \"pen\",\n        Touch = \"touch\"\n    }\n}\nexport declare namespace Input {\n    type PointerParameters = {\n        /**\n         * @defaultValue `\"mouse\"`\n         */\n        pointerType?: Input.PointerType;\n    };\n}\nexport declare namespace Input {\n    type PointerSourceAction = Input.PauseAction | Input.PointerDownAction | Input.PointerUpAction | Input.PointerMoveAction;\n}\nexport declare namespace Input {\n    type WheelSourceActions = {\n        type: 'wheel';\n        id: string;\n        actions: [...Input.WheelSourceAction[]];\n    };\n}\nexport declare namespace Input {\n    type WheelSourceAction = Input.PauseAction | Input.WheelScrollAction;\n}\nexport declare namespace Input {\n    type PauseAction = {\n        type: 'pause';\n        duration?: JsUint;\n    };\n}\nexport declare namespace Input {\n    type KeyDownAction = {\n        type: 'keyDown';\n        value: string;\n    };\n}\nexport declare namespace Input {\n    type KeyUpAction = {\n        type: 'keyUp';\n        value: string;\n    };\n}\nexport declare namespace Input {\n    type PointerUpAction = {\n        type: 'pointerUp';\n        button: JsUint;\n    };\n}\nexport declare namespace Input {\n    type PointerDownAction = {\n        type: 'pointerDown';\n        button: JsUint;\n    } & Input.PointerCommonProperties;\n}\nexport declare namespace Input {\n    type PointerMoveAction = {\n        type: 'pointerMove';\n        x: number;\n        y: number;\n        duration?: JsUint;\n        origin?: Input.Origin;\n    } & Input.PointerCommonProperties;\n}\nexport declare namespace Input {\n    type WheelScrollAction = {\n        type: 'scroll';\n        x: JsInt;\n        y: JsInt;\n        deltaX: JsInt;\n        deltaY: JsInt;\n        duration?: JsUint;\n        /**\n         * @defaultValue `\"viewport\"`\n         */\n        origin?: Input.Origin;\n    };\n}\nexport declare namespace Input {\n    type PointerCommonProperties = {\n        /**\n         * @defaultValue `1`\n         */\n        width?: JsUint;\n        /**\n         * @defaultValue `1`\n         */\n        height?: JsUint;\n        /**\n         * @defaultValue `0`\n         */\n        pressure?: number;\n        /**\n         * @defaultValue `0`\n         */\n        tangentialPressure?: number;\n        /**\n         * Must be between `0` and `359`, inclusive.\n         *\n         * @defaultValue `0`\n         */\n        twist?: number;\n        /**\n         * Must be between `0` and `1.5707963267948966`, inclusive.\n         *\n         * @defaultValue `0`\n         */\n        altitudeAngle?: number;\n        /**\n         * Must be between `0` and `6.283185307179586`, inclusive.\n         *\n         * @defaultValue `0`\n         */\n        azimuthAngle?: number;\n    };\n}\nexport declare namespace Input {\n    type Origin = 'viewport' | 'pointer' | Input.ElementOrigin;\n}\nexport declare namespace Input {\n    type PerformActionsResult = EmptyResult;\n}\nexport declare namespace Input {\n    type ReleaseActions = {\n        method: 'input.releaseActions';\n        params: Input.ReleaseActionsParameters;\n    };\n}\nexport declare namespace Input {\n    type ReleaseActionsParameters = {\n        context: BrowsingContext.BrowsingContext;\n    };\n}\nexport declare namespace Input {\n    type ReleaseActionsResult = EmptyResult;\n}\nexport declare namespace Input {\n    type SetFiles = {\n        method: 'input.setFiles';\n        params: Input.SetFilesParameters;\n    };\n}\nexport declare namespace Input {\n    type SetFilesParameters = {\n        context: BrowsingContext.BrowsingContext;\n        element: Script.SharedReference;\n        files: [...string[]];\n    };\n}\nexport declare namespace Input {\n    type SetFilesResult = EmptyResult;\n}\nexport declare namespace Input {\n    type FileDialogOpened = {\n        method: 'input.fileDialogOpened';\n        params: Input.FileDialogInfo;\n    };\n}\nexport declare namespace Input {\n    type FileDialogInfo = {\n        context: BrowsingContext.BrowsingContext;\n        element?: Script.SharedReference;\n        multiple: boolean;\n    };\n}\nexport type WebExtensionCommand = WebExtension.Install | WebExtension.Uninstall;\nexport type WebExtensionResult = WebExtension.InstallResult | WebExtension.UninstallResult;\nexport declare namespace WebExtension {\n    type Extension = string;\n}\nexport declare namespace WebExtension {\n    type Install = {\n        method: 'webExtension.install';\n        params: WebExtension.InstallParameters;\n    };\n}\nexport declare namespace WebExtension {\n    type InstallParameters = {\n        extensionData: WebExtension.ExtensionData;\n    };\n}\nexport declare namespace WebExtension {\n    type ExtensionData = WebExtension.ExtensionArchivePath | WebExtension.ExtensionBase64Encoded | WebExtension.ExtensionPath;\n}\nexport declare namespace WebExtension {\n    type ExtensionPath = {\n        type: 'path';\n        path: string;\n    };\n}\nexport declare namespace WebExtension {\n    type ExtensionArchivePath = {\n        type: 'archivePath';\n        path: string;\n    };\n}\nexport declare namespace WebExtension {\n    type ExtensionBase64Encoded = {\n        type: 'base64';\n        value: string;\n    };\n}\nexport declare namespace WebExtension {\n    type InstallResult = {\n        extension: WebExtension.Extension;\n    };\n}\nexport declare namespace WebExtension {\n    type Uninstall = {\n        method: 'webExtension.uninstall';\n        params: WebExtension.UninstallParameters;\n    };\n}\nexport declare namespace WebExtension {\n    type UninstallParameters = {\n        extension: WebExtension.Extension;\n    };\n}\nexport declare namespace WebExtension {\n    type UninstallResult = EmptyResult;\n}\n//# sourceMappingURL=bidiProtocolCore.d.ts.map",
      "server/bidi/third_party/bidiProtocolPermissions.d.ts": "/**\n * @license\n * Copyright 2024 Google Inc.\n * Modifications copyright (c) Microsoft Corporation.\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * THIS FILE IS AUTOGENERATED by cddlconv 0.1.6.\n * Run `node tools/generate-bidi-types.mjs` to regenerate.\n * @see https://github.com/w3c/webdriver-bidi/blob/master/index.bs\n */\nexport type PermissionsCommand = Permissions.SetPermission;\nexport declare namespace Permissions {\n    type PermissionDescriptor = {\n        name: string;\n    };\n}\nexport declare namespace Permissions {\n    const enum PermissionState {\n        Granted = \"granted\",\n        Denied = \"denied\",\n        Prompt = \"prompt\"\n    }\n}\nexport declare namespace Permissions {\n    type SetPermission = {\n        method: 'permissions.setPermission';\n        params: Permissions.SetPermissionParameters;\n    };\n}\nexport declare namespace Permissions {\n    type SetPermissionParameters = {\n        descriptor: Permissions.PermissionDescriptor;\n        state: Permissions.PermissionState;\n        origin: string;\n        userContext?: string;\n    };\n}\n//# sourceMappingURL=bidiProtocolPermissions.d.ts.map",
      "server/bidi/third_party/bidiSerializer.d.ts": "/**\n * @license\n * Copyright 2024 Google Inc.\n * Modifications copyright (c) Microsoft Corporation.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport type * as Bidi from './bidiProtocol';\n/**\n * @internal\n */\nexport declare class BidiSerializer {\n    static serialize(arg: unknown): Bidi.Script.LocalValue;\n    static _serializeNumber(arg: number): Bidi.Script.LocalValue;\n    static _serializeObject(arg: object | null): Bidi.Script.LocalValue;\n}\n/**\n * @internal\n */\nexport declare const isPlainObject: (obj: unknown) => obj is Record<any, unknown>;\n/**\n * @internal\n */\nexport declare const isRegExp: (obj: unknown) => obj is RegExp;\n/**\n * @internal\n */\nexport declare const isDate: (obj: unknown) => obj is Date;\n//# sourceMappingURL=bidiSerializer.d.ts.map",
      "server/bidi/third_party/firefoxPrefs.d.ts": "/**\n * @license\n * Copyright 2023 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\ninterface ProfileOptions {\n    preferences: Record<string, unknown>;\n    path: string;\n}\nexport declare function createProfile(options: ProfileOptions): Promise<void>;\nexport {};\n//# sourceMappingURL=firefoxPrefs.d.ts.map",
      "server/browser.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Artifact } from './artifact';\nimport { BrowserContext } from './browserContext';\nimport { SdkObject } from './instrumentation';\nimport { Page } from './page';\nimport type * as types from './types';\nimport type { ProxySettings } from './types';\nimport type { RecentLogsCollector } from './utils/debugLogger';\nimport type * as channels from '@protocol/channels';\nimport type { ChildProcess } from 'child_process';\nimport type { Language } from '../utils';\nimport type { Progress } from './progress';\nexport interface BrowserProcess {\n    onclose?: ((exitCode: number | null, signal: string | null) => void);\n    process?: ChildProcess;\n    kill(): Promise<void>;\n    close(): Promise<void>;\n}\nexport type BrowserOptions = {\n    name: string;\n    isChromium: boolean;\n    channel?: string;\n    artifactsDir: string;\n    downloadsPath: string;\n    tracesDir: string;\n    headful?: boolean;\n    persistent?: types.BrowserContextOptions;\n    browserProcess: BrowserProcess;\n    customExecutablePath?: string;\n    proxy?: ProxySettings;\n    protocolLogger: types.ProtocolLogger;\n    browserLogsCollector: RecentLogsCollector;\n    slowMo?: number;\n    wsEndpoint?: string;\n    sdkLanguage?: Language;\n    originalLaunchOptions: types.LaunchOptions;\n};\nexport declare abstract class Browser extends SdkObject {\n    static Events: {\n        Context: string;\n        Disconnected: string;\n    };\n    readonly options: BrowserOptions;\n    private _downloads;\n    _defaultContext: BrowserContext | null;\n    private _startedClosing;\n    readonly _idToVideo: Map<string, {\n        context: BrowserContext;\n        artifact: Artifact;\n    }>;\n    private _contextForReuse;\n    _closeReason: string | undefined;\n    _isCollocatedWithServer: boolean;\n    constructor(parent: SdkObject, options: BrowserOptions);\n    abstract doCreateNewContext(options: types.BrowserContextOptions): Promise<BrowserContext>;\n    abstract contexts(): BrowserContext[];\n    abstract isConnected(): boolean;\n    abstract version(): string;\n    abstract userAgent(): string;\n    sdkLanguage(): Language;\n    newContext(progress: Progress, options: types.BrowserContextOptions): Promise<BrowserContext>;\n    newContextForReuse(progress: Progress, params: channels.BrowserNewContextForReuseParams): Promise<BrowserContext>;\n    contextForReuse(): BrowserContext;\n    _downloadCreated(page: Page, uuid: string, url: string, suggestedFilename?: string): void;\n    _downloadFilenameSuggested(uuid: string, suggestedFilename: string): void;\n    _downloadFinished(uuid: string, error?: string): void;\n    _videoStarted(context: BrowserContext, videoId: string, path: string, pageOrError: Promise<Page | Error>): void;\n    _takeVideo(videoId: string): Artifact | undefined;\n    _didClose(): void;\n    close(options: {\n        reason?: string;\n    }): Promise<void>;\n    killForTests(): Promise<void>;\n}\n//# sourceMappingURL=browser.d.ts.map",
      "server/browserContext.d.ts": "/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Clock } from './clock';\nimport { Debugger } from './debugger';\nimport { DialogManager } from './dialog';\nimport { BrowserContextAPIRequestContext } from './fetch';\nimport { HarRecorder } from './har/harRecorder';\nimport { SdkObject } from './instrumentation';\nimport * as network from './network';\nimport { InitScript } from './page';\nimport { Page, PageBinding } from './page';\nimport { Selectors } from './selectors';\nimport { Tracing } from './trace/recorder/tracing';\nimport type { Artifact } from './artifact';\nimport type { Browser, BrowserOptions } from './browser';\nimport type { Download } from './download';\nimport type * as frames from './frames';\nimport type { Progress } from './progress';\nimport type { ClientCertificatesProxy } from './socksClientCertificatesInterceptor';\nimport type * as types from './types';\nimport type * as channels from '@protocol/channels';\nexport declare abstract class BrowserContext extends SdkObject {\n    static Events: {\n        Console: string;\n        Close: string;\n        Page: string;\n        PageError: string;\n        Request: string;\n        Response: string;\n        RequestFailed: string;\n        RequestFinished: string;\n        RequestAborted: string;\n        RequestFulfilled: string;\n        RequestContinued: string;\n        BeforeClose: string;\n        VideoStarted: string;\n        RecorderEvent: string;\n    };\n    readonly _pageBindings: Map<string, PageBinding>;\n    readonly _options: types.BrowserContextOptions;\n    readonly requestInterceptors: network.RouteHandler[];\n    private _isPersistentContext;\n    private _closedStatus;\n    readonly _closePromise: Promise<Error>;\n    private _closePromiseFulfill;\n    readonly _permissions: Map<string, string[]>;\n    readonly _downloads: Set<Download>;\n    readonly _browser: Browser;\n    readonly _browserContextId: string | undefined;\n    private _selectors;\n    private _origins;\n    readonly _harRecorders: Map<string, HarRecorder>;\n    readonly tracing: Tracing;\n    readonly fetchRequest: BrowserContextAPIRequestContext;\n    private _customCloseHandler?;\n    readonly _tempDirs: string[];\n    private _creatingStorageStatePage;\n    bindingsInitScript?: InitScript;\n    initScripts: InitScript[];\n    private _routesInFlight;\n    private _debugger;\n    _closeReason: string | undefined;\n    readonly clock: Clock;\n    _clientCertificatesProxy: ClientCertificatesProxy | undefined;\n    private _playwrightBindingExposed?;\n    readonly dialogManager: DialogManager;\n    constructor(browser: Browser, options: types.BrowserContextOptions, browserContextId: string | undefined);\n    isPersistentContext(): boolean;\n    selectors(): Selectors;\n    _initialize(): Promise<void>;\n    debugger(): Debugger;\n    _ensureVideosPath(): Promise<void>;\n    canResetForReuse(): boolean;\n    static reusableContextHash(params: channels.BrowserNewContextForReuseParams): string;\n    resetForReuse(progress: Progress, params: channels.BrowserNewContextForReuseParams | null): Promise<void>;\n    _browserClosed(): void;\n    private _didCloseInternal;\n    pages(): Page[];\n    abstract possiblyUninitializedPages(): Page[];\n    abstract doCreateNewPage(): Promise<Page>;\n    abstract addCookies(cookies: channels.SetNetworkCookie[]): Promise<void>;\n    abstract setGeolocation(geolocation?: types.Geolocation): Promise<void>;\n    abstract setUserAgent(userAgent: string | undefined): Promise<void>;\n    abstract cancelDownload(uuid: string): Promise<void>;\n    abstract clearCache(): Promise<void>;\n    protected abstract doGetCookies(urls: string[]): Promise<channels.NetworkCookie[]>;\n    protected abstract doClearCookies(): Promise<void>;\n    protected abstract doGrantPermissions(origin: string, permissions: string[]): Promise<void>;\n    protected abstract doClearPermissions(): Promise<void>;\n    protected abstract doSetHTTPCredentials(httpCredentials?: types.Credentials): Promise<void>;\n    protected abstract doAddInitScript(initScript: InitScript): Promise<void>;\n    protected abstract doRemoveInitScripts(initScripts: InitScript[]): Promise<void>;\n    protected abstract doUpdateExtraHTTPHeaders(): Promise<void>;\n    protected abstract doUpdateOffline(): Promise<void>;\n    protected abstract doUpdateRequestInterception(): Promise<void>;\n    protected abstract doUpdateDefaultViewport(): Promise<void>;\n    protected abstract doUpdateDefaultEmulatedMedia(): Promise<void>;\n    protected abstract doExposePlaywrightBinding(): Promise<void>;\n    protected abstract doClose(reason: string | undefined): Promise<void>;\n    protected abstract onClosePersistent(): void;\n    cookies(urls?: string | string[] | undefined): Promise<channels.NetworkCookie[]>;\n    clearCookies(options: {\n        name?: string | RegExp;\n        domain?: string | RegExp;\n        path?: string | RegExp;\n    }): Promise<void>;\n    setHTTPCredentials(httpCredentials?: types.Credentials): Promise<void>;\n    getBindingClient(name: string): unknown | undefined;\n    exposePlaywrightBindingIfNeeded(): Promise<void>;\n    needsPlaywrightBinding(): boolean;\n    exposeBinding(progress: Progress, name: string, needsHandle: boolean, playwrightBinding: frames.FunctionWithSource, forClient?: unknown): Promise<PageBinding>;\n    removeExposedBindings(bindings: PageBinding[]): Promise<void>;\n    grantPermissions(permissions: string[], origin?: string): Promise<void>;\n    clearPermissions(): Promise<void>;\n    setExtraHTTPHeaders(progress: Progress, headers: types.HeadersArray): Promise<void>;\n    setOffline(progress: Progress, offline: boolean): Promise<void>;\n    _loadDefaultContextAsIs(progress: Progress): Promise<Page | undefined>;\n    _loadDefaultContext(progress: Progress): Promise<void>;\n    protected _authenticateProxyViaHeader(): void;\n    protected _authenticateProxyViaCredentials(): void;\n    addInitScript(progress: Progress | undefined, source: string): Promise<InitScript>;\n    removeInitScripts(initScripts: InitScript[]): Promise<void>;\n    addRequestInterceptor(progress: Progress, handler: network.RouteHandler): Promise<void>;\n    removeRequestInterceptor(handler: network.RouteHandler): Promise<void>;\n    isClosingOrClosed(): boolean;\n    private _deleteAllDownloads;\n    private _deleteAllTempDirs;\n    setCustomCloseHandler(handler: (() => Promise<any>) | undefined): void;\n    close(options: {\n        reason?: string;\n    }): Promise<void>;\n    newPage(progress: Progress, forStorageState?: boolean): Promise<Page>;\n    addVisitedOrigin(origin: string): void;\n    storageState(progress: Progress, indexedDB?: boolean): Promise<channels.BrowserContextStorageStateResult>;\n    isCreatingStorageStatePage(): boolean;\n    setStorageState(progress: Progress, state: channels.BrowserNewContextParams['storageState'], mode: 'initial' | 'resetForReuse'): Promise<void>;\n    extendInjectedScript(source: string, arg?: any): Promise<void[][]>;\n    safeNonStallingEvaluateInAllFrames(expression: string, world: types.World, options?: {\n        throwOnJSErrors?: boolean;\n    }): Promise<void>;\n    harStart(page: Page | null, options: channels.RecordHarOptions): string;\n    harExport(harId: string | undefined): Promise<Artifact>;\n    addRouteInFlight(route: network.Route): void;\n    removeRouteInFlight(route: network.Route): void;\n    notifyRoutesInFlightAboutRemovedHandler(handler: network.RouteHandler): Promise<void>;\n}\nexport declare function validateBrowserContextOptions(options: types.BrowserContextOptions, browserOptions: BrowserOptions): void;\nexport declare function verifyGeolocation(geolocation?: types.Geolocation): asserts geolocation is types.Geolocation;\nexport declare function verifyClientCertificates(clientCertificates?: types.BrowserContextOptions['clientCertificates']): void;\nexport declare function normalizeProxySettings(proxy: types.ProxySettings): types.ProxySettings;\n//# sourceMappingURL=browserContext.d.ts.map",
      "server/browserTransport.d.ts": "import type { ConnectionTransport, ProtocolRequest, ProtocolResponse } from './transport';\nexport type BrowserWebSocketTransportOptions = {\n    protocols?: string | string[];\n};\nexport declare class BrowserWebSocketTransport implements ConnectionTransport {\n    private readonly _ws;\n    readonly wsEndpoint: string;\n    onmessage?: (message: ProtocolResponse) => void;\n    onclose?: (reason?: string) => void;\n    static connect(url: string, options?: BrowserWebSocketTransportOptions): Promise<BrowserWebSocketTransport>;\n    constructor(url: string, options: BrowserWebSocketTransportOptions);\n    private _waitForOpen;\n    send(message: ProtocolRequest): void;\n    close(): void;\n}\n//# sourceMappingURL=browserTransport.d.ts.map",
      "server/browserType.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SdkObject } from './instrumentation';\nimport { RecentLogsCollector } from './utils/debugLogger';\nimport type { Browser, BrowserOptions } from './browser';\nimport type { BrowserContext } from './browserContext';\nimport type { Progress } from './progress';\nimport type { ProtocolError } from './protocolError';\nimport type { BrowserName } from './registry';\nimport type { ConnectionTransport } from './transport';\nimport type * as types from './types';\nimport type * as channels from '@protocol/channels';\nexport declare const kNoXServerRunningError: string;\nexport declare abstract class BrowserType extends SdkObject {\n    private _name;\n    constructor(parent: SdkObject, browserName: BrowserName);\n    executablePath(): string;\n    name(): string;\n    launch(progress: Progress, options: types.LaunchOptions, protocolLogger?: types.ProtocolLogger): Promise<Browser>;\n    launchPersistentContext(progress: Progress, userDataDir: string, options: channels.BrowserTypeLaunchPersistentContextOptions & {\n        cdpPort?: number;\n        internalIgnoreHTTPSErrors?: boolean;\n        socksProxyPort?: number;\n    }): Promise<BrowserContext>;\n    private _innerLaunchWithRetries;\n    private _innerLaunch;\n    private _prepareToLaunch;\n    private _launchProcess;\n    _createArtifactDirs(options: types.LaunchOptions): Promise<void>;\n    connectOverCDP(progress: Progress, endpointURL: string, options: {\n        slowMo?: number;\n        timeout?: number;\n        headers?: types.HeadersArray;\n    }): Promise<Browser>;\n    _launchWithSeleniumHub(progress: Progress, hubUrl: string, options: types.LaunchOptions): Promise<Browser>;\n    private _validateLaunchOptions;\n    protected _createUserDataDirArgMisuseError(userDataDirArg: string): Error;\n    private _rewriteStartupLog;\n    waitForReadyState(options: types.LaunchOptions, browserLogsCollector: RecentLogsCollector): Promise<{\n        wsEndpoint?: string;\n    }>;\n    prepareUserDataDir(options: types.LaunchOptions, userDataDir: string): Promise<void>;\n    supportsPipeTransport(): boolean;\n    getExecutableName(options: types.LaunchOptions): string;\n    abstract defaultArgs(options: types.LaunchOptions, isPersistent: boolean, userDataDir: string): Promise<string[]>;\n    abstract connectToTransport(transport: ConnectionTransport, options: BrowserOptions, browserLogsCollector: RecentLogsCollector): Promise<Browser>;\n    abstract amendEnvironment(env: NodeJS.ProcessEnv, userDataDir: string, isPersistent: boolean, options: types.LaunchOptions): NodeJS.ProcessEnv;\n    abstract doRewriteStartupLog(error: ProtocolError): ProtocolError;\n    abstract attemptToGracefullyCloseBrowser(transport: ConnectionTransport): void;\n}\n//# sourceMappingURL=browserType.d.ts.map",
      "server/callLog.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport declare function compressCallLog(log: string[]): string[];\ndeclare function findRepeatedSubsequences(s: string[]): {\n    sequence: string[];\n    count: number;\n}[];\nexport declare const findRepeatedSubsequencesForTest: typeof findRepeatedSubsequences;\nexport {};\n//# sourceMappingURL=callLog.d.ts.map",
      "server/chromium/chromium.d.ts": "/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { CRBrowser } from './crBrowser';\nimport { RecentLogsCollector } from '../utils/debugLogger';\nimport { BrowserType } from '../browserType';\nimport { Browser } from '../browser';\nimport type { BrowserOptions } from '../browser';\nimport type { SdkObject } from '../instrumentation';\nimport type { Progress } from '../progress';\nimport type { ProtocolError } from '../protocolError';\nimport type { ConnectionTransport } from '../transport';\nimport type { BrowserContext } from '../browserContext';\nimport type * as types from '../types';\nimport type * as channels from '@protocol/channels';\nexport declare class Chromium extends BrowserType {\n    private _devtools;\n    private _bidiChromium;\n    constructor(parent: SdkObject, bidiChromium: BrowserType);\n    launch(progress: Progress, options: types.LaunchOptions, protocolLogger?: types.ProtocolLogger): Promise<Browser>;\n    launchPersistentContext(progress: Progress, userDataDir: string, options: channels.BrowserTypeLaunchPersistentContextOptions & {\n        cdpPort?: number;\n        internalIgnoreHTTPSErrors?: boolean;\n        socksProxyPort?: number;\n    }): Promise<BrowserContext>;\n    connectOverCDP(progress: Progress, endpointURL: string, options: {\n        slowMo?: number;\n        headers?: types.HeadersArray;\n    }): Promise<any>;\n    _connectOverCDPInternal(progress: Progress, endpointURL: string, options: types.LaunchOptions & {\n        headers?: types.HeadersArray;\n    }, onClose?: () => Promise<void>): Promise<any>;\n    private _createDevTools;\n    connectToTransport(transport: ConnectionTransport, options: BrowserOptions, browserLogsCollector: RecentLogsCollector): Promise<CRBrowser>;\n    doRewriteStartupLog(error: ProtocolError): ProtocolError;\n    amendEnvironment(env: NodeJS.ProcessEnv): NodeJS.ProcessEnv;\n    attemptToGracefullyCloseBrowser(transport: ConnectionTransport): void;\n    _launchWithSeleniumHub(progress: Progress, hubUrl: string, options: types.LaunchOptions): Promise<CRBrowser>;\n    defaultArgs(options: types.LaunchOptions, isPersistent: boolean, userDataDir: string): Promise<string[]>;\n    private _innerDefaultArgs;\n    waitForReadyState(options: types.LaunchOptions, browserLogsCollector: RecentLogsCollector): Promise<{\n        wsEndpoint?: string;\n    }>;\n    getExecutableName(options: types.LaunchOptions): string;\n}\nexport declare function waitForReadyState(options: types.LaunchOptions, browserLogsCollector: RecentLogsCollector): Promise<{\n    wsEndpoint?: string;\n}>;\n//# sourceMappingURL=chromium.d.ts.map",
      "server/chromium/chromiumSwitches.d.ts": "/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport declare const chromiumSwitches: (assistantMode?: boolean, channel?: string, android?: boolean) => string[];\n//# sourceMappingURL=chromiumSwitches.d.ts.map",
      "server/chromium/crBrowser.d.ts": "/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Artifact } from '../artifact';\nimport { Browser } from '../browser';\nimport { BrowserContext } from '../browserContext';\nimport { Frame } from '../frames';\nimport { Page } from '../page';\nimport { CRConnection } from './crConnection';\nimport { CRPage } from './crPage';\nimport { CRServiceWorker } from './crServiceWorker';\nimport { RecentLogsCollector } from '../utils/debugLogger';\nimport type { InitScript, Worker } from '../page';\nimport type { ConnectionTransport } from '../transport';\nimport type { BrowserWebSocketTransportOptions } from '../browserTransport';\nimport type * as types from '../types';\nimport type { CDPSession, CRSession } from './crConnection';\nimport type { CRDevTools } from './crDevTools';\nimport type { Protocol } from './protocol';\nimport type { BrowserOptions } from '../browser';\nimport type { SdkObject } from '../instrumentation';\nimport type { ProtocolLogger } from '../types';\nimport type * as channels from '@protocol/channels';\nexport type CRBrowserConnectOptions = Partial<BrowserOptions> & {\n    transportOptions?: BrowserWebSocketTransportOptions;\n    browserLogsCollector?: RecentLogsCollector;\n    protocolLogger?: ProtocolLogger;\n};\nexport type CRBrowserOptions = CRBrowserConnectOptions;\nexport declare class CRBrowser extends Browser {\n    readonly _connection: CRConnection;\n    _session: CRSession;\n    private _clientRootSessionPromise;\n    readonly _contexts: Map<string, CRBrowserContext>;\n    _crPages: Map<string, CRPage>;\n    _serviceWorkers: Map<string, CRServiceWorker>;\n    _devtools?: CRDevTools;\n    private _version;\n    private _majorVersion;\n    private _tracingRecording;\n    private _tracingClient;\n    private _userAgent;\n    static connect(wsEndpoint: string, options?: CRBrowserConnectOptions): Promise<CRBrowser>;\n    static connect(parent: SdkObject, transport: ConnectionTransport, options: BrowserOptions, devtools?: CRDevTools): Promise<CRBrowser>;\n    private static _connect;\n    constructor(parent: SdkObject, connection: CRConnection, options: BrowserOptions);\n    doCreateNewContext(options: types.BrowserContextOptions): Promise<BrowserContext>;\n    contexts(): BrowserContext[];\n    version(): string;\n    majorVersion(): number;\n    userAgent(): string;\n    _platform(): 'mac' | 'linux' | 'win';\n    isClank(): boolean;\n    _waitForAllPagesToBeInitialized(): Promise<void>;\n    _onAttachedToTarget({ targetInfo, sessionId, waitingForDebugger }: Protocol.Target.attachedToTargetPayload): void;\n    _onDetachedFromTarget(payload: Protocol.Target.detachedFromTargetPayload): void;\n    private _didDisconnect;\n    private _findOwningPage;\n    _onDownloadWillBegin(payload: Protocol.Browser.downloadWillBeginPayload): void;\n    _onDownloadProgress(payload: any): void;\n    _closePage(crPage: CRPage): Promise<void>;\n    newBrowserCDPSession(): Promise<CDPSession>;\n    startTracing(page?: Page, options?: {\n        screenshots?: boolean;\n        categories?: string[];\n    }): Promise<void>;\n    stopTracing(): Promise<Artifact>;\n    isConnected(): boolean;\n    _clientRootSession(): Promise<CDPSession>;\n}\nexport declare class CRBrowserContext extends BrowserContext {\n    static CREvents: {\n        ServiceWorker: string;\n    };\n    readonly _browser: CRBrowser;\n    constructor(browser: CRBrowser, browserContextId: string | undefined, options: types.BrowserContextOptions);\n    _initialize(): Promise<void>;\n    private _crPages;\n    possiblyUninitializedPages(): Page[];\n    doCreateNewPage(): Promise<Page>;\n    doGetCookies(urls: string[]): Promise<channels.NetworkCookie[]>;\n    addCookies(cookies: channels.SetNetworkCookie[]): Promise<void>;\n    doClearCookies(): Promise<void>;\n    doGrantPermissions(origin: string, permissions: string[]): Promise<void>;\n    doClearPermissions(): Promise<void>;\n    setGeolocation(geolocation?: types.Geolocation): Promise<void>;\n    doUpdateExtraHTTPHeaders(): Promise<void>;\n    setUserAgent(userAgent: string | undefined): Promise<void>;\n    doUpdateOffline(): Promise<void>;\n    doSetHTTPCredentials(httpCredentials?: types.Credentials): Promise<void>;\n    doAddInitScript(initScript: InitScript): Promise<void>;\n    doRemoveInitScripts(initScripts: InitScript[]): Promise<void>;\n    doUpdateRequestInterception(): Promise<void>;\n    doUpdateDefaultViewport(): Promise<void>;\n    doUpdateDefaultEmulatedMedia(): Promise<void>;\n    doExposePlaywrightBinding(): Promise<void>;\n    doClose(reason: string | undefined): Promise<void>;\n    stopVideoRecording(): Promise<void>;\n    onClosePersistent(): void;\n    clearCache(): Promise<void>;\n    cancelDownload(guid: string): Promise<void>;\n    serviceWorkers(): Worker[];\n    newCDPSession(page: Page | Frame): Promise<CDPSession>;\n}\n//# sourceMappingURL=crBrowser.d.ts.map",
      "server/chromium/crConnection.d.ts": "/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SdkObject } from '../instrumentation';\nimport type { ConnectionTransport, ProtocolResponse } from '../transport';\nimport type { Protocol } from './protocol';\nimport type { RecentLogsCollector } from '../utils/debugLogger';\nimport type { ProtocolLogger } from '../types';\nexport declare const ConnectionEvents: {\n    Disconnected: symbol;\n};\nexport declare const kBrowserCloseMessageId = -9999;\nexport declare class CRConnection extends SdkObject {\n    private _lastId;\n    private readonly _transport;\n    readonly _sessions: Map<string, CRSession>;\n    private readonly _protocolLogger;\n    private readonly _browserLogsCollector;\n    _browserDisconnectedLogs: string | undefined;\n    readonly rootSession: CRSession;\n    _closed: boolean;\n    constructor(parent: SdkObject, transport: ConnectionTransport, protocolLogger: ProtocolLogger, browserLogsCollector: RecentLogsCollector);\n    _rawSend(sessionId: string, method: string, params: any): number;\n    _onMessage(message: ProtocolResponse): Promise<void>;\n    _onClose(reason?: string): void;\n    close(): void;\n    createBrowserSession(): Promise<CDPSession>;\n}\ntype SessionEventListener = (method: string, params?: Object) => void;\nexport declare class CRSession extends SdkObject {\n    private readonly _connection;\n    private _eventListener?;\n    private readonly _callbacks;\n    private readonly _sessionId;\n    private readonly _parentSession;\n    private _crashed;\n    private _closed;\n    on: <T extends keyof Protocol.Events | symbol>(event: T, listener: (payload: T extends symbol ? any : Protocol.Events[T extends keyof Protocol.Events ? T : never]) => void) => this;\n    addListener: <T extends keyof Protocol.Events | symbol>(event: T, listener: (payload: T extends symbol ? any : Protocol.Events[T extends keyof Protocol.Events ? T : never]) => void) => this;\n    off: <T extends keyof Protocol.Events | symbol>(event: T, listener: (payload: T extends symbol ? any : Protocol.Events[T extends keyof Protocol.Events ? T : never]) => void) => this;\n    removeListener: <T extends keyof Protocol.Events | symbol>(event: T, listener: (payload: T extends symbol ? any : Protocol.Events[T extends keyof Protocol.Events ? T : never]) => void) => this;\n    once: <T extends keyof Protocol.Events | symbol>(event: T, listener: (payload: T extends symbol ? any : Protocol.Events[T extends keyof Protocol.Events ? T : never]) => void) => this;\n    constructor(connection: CRConnection, parentSession: CRSession | null, sessionId: string, eventListener?: SessionEventListener);\n    _markAsCrashed(): void;\n    createChildSession(sessionId: string, eventListener?: SessionEventListener): CRSession;\n    send<T extends keyof Protocol.CommandParameters>(method: T, params?: Protocol.CommandParameters[T]): Promise<Protocol.CommandReturnValues[T]>;\n    _sendMayFail<T extends keyof Protocol.CommandParameters>(method: T, params?: Protocol.CommandParameters[T]): Promise<Protocol.CommandReturnValues[T] | void>;\n    _onMessage(object: ProtocolResponse): void;\n    detach(): Promise<void>;\n    dispose(): void;\n}\nexport declare class CDPSession extends SdkObject {\n    static Events: {\n        Event: string;\n        Closed: string;\n    };\n    private _session;\n    private _listeners;\n    constructor(parentSession: CRSession, sessionId: string);\n    send(method: string, params?: any): Promise<any>;\n    detach(): Promise<void>;\n    attachToTarget(targetId: string): Promise<CDPSession>;\n    private _onClose;\n}\nexport {};\n//# sourceMappingURL=crConnection.d.ts.map",
      "server/chromium/crConsole.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { CRPage } from './crBrowser';\nimport type { JSHandle } from './crHandle';\nimport type * as types from '../types';\n/**\n * Console message type (matches Runtime.consoleAPICalled type).\n */\nexport type ConsoleMessageType = 'log' | 'debug' | 'info' | 'error' | 'warning' | 'dir' | 'dirxml' | 'table' | 'trace' | 'clear' | 'startGroup' | 'startGroupCollapsed' | 'endGroup' | 'assert' | 'profile' | 'profileEnd' | 'count' | 'timeEnd';\n/**\n * ConsoleMessage represents a console message from the browser.\n */\nexport declare class ConsoleMessage {\n    private _page;\n    private _type;\n    private _text?;\n    private _args;\n    private _location;\n    constructor(page: CRPage, type: ConsoleMessageType, text: string | undefined, args: JSHandle[], location?: types.ConsoleMessageLocation);\n    /**\n     * Returns the page that emitted this console message.\n     */\n    page(): CRPage;\n    /**\n     * Returns the type of console message (log, debug, info, error, warning, etc.).\n     */\n    type(): ConsoleMessageType;\n    /**\n     * Returns the text of the console message.\n     */\n    text(): string;\n    /**\n     * Returns the arguments passed to the console call as JSHandle objects.\n     */\n    args(): JSHandle[];\n    /**\n     * Returns the location in the source code where the console call was made.\n     */\n    location(): types.ConsoleMessageLocation;\n}\n//# sourceMappingURL=crConsole.d.ts.map",
      "server/chromium/crCoverage.d.ts": "/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { CRSession } from './crConnection';\nimport type * as channels from '@protocol/channels';\nimport type { Progress } from '@protocol/progress';\nexport declare class CRCoverage {\n    private _jsCoverage;\n    private _cssCoverage;\n    constructor(client: CRSession);\n    startJSCoverage(progress: Progress, options: channels.PageStartJSCoverageParams): Promise<void>;\n    stopJSCoverage(): Promise<channels.PageStopJSCoverageResult>;\n    startCSSCoverage(progress: Progress, options: channels.PageStartCSSCoverageParams): Promise<void>;\n    stopCSSCoverage(): Promise<channels.PageStopCSSCoverageResult>;\n}\n//# sourceMappingURL=crCoverage.d.ts.map",
      "server/chromium/crDevTools.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { CRSession } from './crConnection';\nexport declare class CRDevTools {\n    private _preferencesPath;\n    private _prefs;\n    private _savePromise;\n    __testHookOnBinding?: (parsed: any) => any;\n    constructor(preferencesPath: string);\n    install(session: CRSession): void;\n    _save(): void;\n}\n//# sourceMappingURL=crDevTools.d.ts.map",
      "server/chromium/crDialog.d.ts": "/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { CRPage } from './crBrowser';\nimport type { CRSession } from './crConnection';\nexport type DialogType = 'alert' | 'beforeunload' | 'confirm' | 'prompt';\n/**\n * Dialog represents a JavaScript dialog (alert, confirm, prompt, beforeunload).\n */\nexport declare class Dialog {\n    private _page;\n    private _session;\n    private _type;\n    private _message;\n    private _defaultValue;\n    private _handled;\n    constructor(page: CRPage, session: CRSession, type: DialogType, message: string, defaultValue?: string);\n    /**\n     * Returns the page that triggered this dialog.\n     */\n    page(): CRPage;\n    /**\n     * Returns the type of the dialog (alert, confirm, prompt, beforeunload).\n     */\n    type(): DialogType;\n    /**\n     * Returns the message displayed in the dialog.\n     */\n    message(): string;\n    /**\n     * Returns the default value for prompt dialogs.\n     */\n    defaultValue(): string;\n    /**\n     * Accept the dialog. For prompt dialogs, optionally provide a value.\n     */\n    accept(promptText?: string): Promise<void>;\n    /**\n     * Dismiss the dialog.\n     */\n    dismiss(): Promise<void>;\n    /**\n     * Close the dialog with default action (accept for beforeunload, dismiss otherwise).\n     */\n    close(): Promise<void>;\n}\n//# sourceMappingURL=crDialog.d.ts.map",
      "server/chromium/crDragDrop.d.ts": "import type { CRPage } from './crPage';\nimport type * as types from '../types';\nimport type { Progress } from '../progress';\ndeclare global {\n    interface Window {\n        __cleanupDrag?: () => Promise<boolean>;\n    }\n}\nexport declare class DragManager {\n    private _crPage;\n    private _dragState;\n    private _lastPosition;\n    constructor(page: CRPage);\n    cancelDrag(): Promise<boolean>;\n    interceptDragCausedByMove(progress: Progress, x: number, y: number, button: types.MouseButton | 'none', buttons: Set<types.MouseButton>, modifiers: Set<types.KeyboardModifier>, moveCallback: () => Promise<void>): Promise<void>;\n    isDragging(): boolean;\n    drop(progress: Progress, x: number, y: number, modifiers: Set<types.KeyboardModifier>): Promise<void>;\n}\n//# sourceMappingURL=crDragDrop.d.ts.map",
      "server/chromium/crExecutionContext.d.ts": "/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as js from '../javascript';\nimport type { CRSession } from './crConnection';\nimport type { Protocol } from './protocol';\nexport declare class CRExecutionContext implements js.ExecutionContextDelegate {\n    _client: CRSession;\n    _contextId: number;\n    constructor(client: CRSession, contextPayload: Protocol.Runtime.ExecutionContextDescription);\n    rawEvaluateJSON(expression: string): Promise<any>;\n    rawEvaluateHandle(context: js.ExecutionContext, expression: string): Promise<js.JSHandle>;\n    evaluateWithArguments(expression: string, returnByValue: boolean, utilityScript: js.JSHandle, values: any[], handles: js.JSHandle[]): Promise<any>;\n    getProperties(object: js.JSHandle): Promise<Map<string, js.JSHandle>>;\n    releaseHandle(handle: js.JSHandle): Promise<void>;\n}\nexport declare function createHandle(context: js.ExecutionContext, remoteObject: Protocol.Runtime.RemoteObject): js.JSHandle;\n//# sourceMappingURL=crExecutionContext.d.ts.map",
      "server/chromium/crFrame.d.ts": "/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SdkObject } from '../instrumentation';\nimport { ElementHandle } from './crHandle';\nimport { Locator } from './locator';\nimport type { CRPage } from './crBrowser';\nimport type { Protocol } from './protocol';\nimport type { CRSession } from './crConnection';\nimport type { LocatorOptions, ByRoleOptions } from './locator';\n/**\n * Simplified Frame class for browser-based CDP connections.\n * This implementation focuses on basic frame operations that work via CDP.\n */\nexport declare class Frame extends SdkObject {\n    readonly _page: CRPage;\n    _id: string;\n    private _parentFrame;\n    readonly _childFrames: Set<Frame>;\n    private _url;\n    private _name;\n    private _detached;\n    _session: CRSession;\n    constructor(page: CRPage, frameId: string, parentFrame: Frame | null, session: CRSession);\n    _updateFromFramePayload(payload: Protocol.Page.Frame): void;\n    _detach(): void;\n    /**\n     * Returns the frame's URL.\n     */\n    url(): string;\n    /**\n     * Returns the frame's name attribute.\n     */\n    name(): string;\n    /**\n     * Returns the parent frame, or null if this is the main frame.\n     */\n    parentFrame(): Frame | null;\n    /**\n     * Returns an array of child frames.\n     */\n    childFrames(): Frame[];\n    /**\n     * Returns whether the frame has been detached.\n     */\n    isDetached(): boolean;\n    /**\n     * Returns the page that owns this frame.\n     */\n    page(): CRPage;\n    /**\n     * Navigate the frame to a URL.\n     */\n    goto(url: string, options?: {\n        waitUntil?: 'load' | 'domcontentloaded' | 'networkidle';\n        timeout?: number;\n    }): Promise<void>;\n    /**\n     * Get the frame's HTML content.\n     */\n    content(): Promise<string>;\n    /**\n     * Set the frame's HTML content.\n     */\n    setContent(html: string): Promise<void>;\n    /**\n     * Get the frame's title.\n     */\n    title(): Promise<string>;\n    /**\n     * Evaluate JavaScript in the frame context.\n     */\n    evaluate<T = unknown>(expression: string | ((...args: unknown[]) => T), ...args: unknown[]): Promise<T>;\n    /**\n     * Query for a single element.\n     */\n    $(selector: string): Promise<ElementHandle | null>;\n    /**\n     * Query for all matching elements.\n     */\n    $$(selector: string): Promise<ElementHandle[]>;\n    /**\n     * Evaluate on a queried element.\n     */\n    $eval<R>(selector: string, pageFunction: (el: Element, ...args: unknown[]) => R, ...args: unknown[]): Promise<R>;\n    /**\n     * Evaluate on all queried elements.\n     */\n    $$eval<R>(selector: string, pageFunction: (els: Element[], ...args: unknown[]) => R, ...args: unknown[]): Promise<R>;\n    /**\n     * Create a locator for the given selector.\n     */\n    locator(selector: string, options?: LocatorOptions): Locator;\n    /**\n     * Locate by test id.\n     */\n    getByTestId(testId: string | RegExp): Locator;\n    /**\n     * Locate by text content.\n     */\n    getByText(text: string | RegExp, options?: {\n        exact?: boolean;\n    }): Locator;\n    /**\n     * Locate by ARIA role.\n     */\n    getByRole(role: string, options?: ByRoleOptions): Locator;\n    /**\n     * Locate by label text.\n     */\n    getByLabel(text: string | RegExp, options?: {\n        exact?: boolean;\n    }): Locator;\n    /**\n     * Locate by placeholder text.\n     */\n    getByPlaceholder(text: string | RegExp, options?: {\n        exact?: boolean;\n    }): Locator;\n    /**\n     * Locate by alt text.\n     */\n    getByAltText(text: string | RegExp, options?: {\n        exact?: boolean;\n    }): Locator;\n    /**\n     * Locate by title attribute.\n     */\n    getByTitle(text: string | RegExp, options?: {\n        exact?: boolean;\n    }): Locator;\n    /**\n     * Wait for selector to appear in the frame.\n     */\n    waitForSelector(selector: string, options?: {\n        state?: 'attached' | 'detached' | 'visible' | 'hidden';\n        timeout?: number;\n    }): Promise<ElementHandle | null>;\n}\n/**\n * FrameManager manages the frame tree for a page.\n */\nexport declare class FrameManager {\n    private _page;\n    private _frames;\n    private _mainFrame;\n    constructor(page: CRPage);\n    mainFrame(): Frame | undefined;\n    frames(): Frame[];\n    frame(frameId: string): Frame | null;\n    frameAttached(frameId: string, parentFrameId: string | null, session: CRSession): Frame;\n    frameNavigated(frameId: string, framePayload: Protocol.Page.Frame): void;\n    frameDetached(frameId: string): void;\n    private _removeFramesRecursively;\n}\n//# sourceMappingURL=crFrame.d.ts.map",
      "server/chromium/crHandle.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { CRSession } from './crConnection';\nimport type { CRPage } from './crBrowser';\nimport type * as types from '../types';\n/**\n * JSHandle represents an in-page JavaScript object.\n */\nexport declare class JSHandle<T = unknown> {\n    protected _session: CRSession;\n    protected _page: CRPage;\n    protected _objectId: string;\n    protected _disposed: boolean;\n    private _preview;\n    constructor(page: CRPage, session: CRSession, objectId: string, preview?: string);\n    /**\n     * Evaluate a function on this object.\n     */\n    evaluate<R>(pageFunction: (arg: T, ...args: unknown[]) => R, ...args: unknown[]): Promise<R>;\n    /**\n     * Evaluate a function that returns a handle.\n     */\n    evaluateHandle<R>(pageFunction: (arg: T, ...args: unknown[]) => R, ...args: unknown[]): Promise<JSHandle<R>>;\n    /**\n     * Get a property of this object as a handle.\n     */\n    getProperty(propertyName: string): Promise<JSHandle>;\n    /**\n     * Get all properties of this object.\n     */\n    getProperties(): Promise<Map<string, JSHandle>>;\n    /**\n     * Get the JSON value of this object.\n     */\n    jsonValue(): Promise<T>;\n    /**\n     * Returns this as an ElementHandle if it's an element.\n     */\n    asElement(): ElementHandle | null;\n    /**\n     * Dispose of this handle.\n     */\n    dispose(): Promise<void>;\n    toString(): string;\n}\n/**\n * ElementHandle represents an in-page DOM element.\n */\nexport declare class ElementHandle extends JSHandle<Element> {\n    constructor(page: CRPage, session: CRSession, objectId: string, preview?: string);\n    asElement(): ElementHandle;\n    /**\n     * Get attribute value.\n     */\n    getAttribute(name: string): Promise<string | null>;\n    /**\n     * Get input value.\n     */\n    inputValue(): Promise<string>;\n    /**\n     * Get text content.\n     */\n    textContent(): Promise<string | null>;\n    /**\n     * Get inner text.\n     */\n    innerText(): Promise<string>;\n    /**\n     * Get inner HTML.\n     */\n    innerHTML(): Promise<string>;\n    /**\n     * Check if element is checked (for checkboxes/radios).\n     */\n    isChecked(): Promise<boolean>;\n    /**\n     * Check if element is disabled.\n     */\n    isDisabled(): Promise<boolean>;\n    /**\n     * Check if element is editable.\n     */\n    isEditable(): Promise<boolean>;\n    /**\n     * Check if element is enabled.\n     */\n    isEnabled(): Promise<boolean>;\n    /**\n     * Check if element is hidden.\n     */\n    isHidden(): Promise<boolean>;\n    /**\n     * Check if element is visible.\n     */\n    isVisible(): Promise<boolean>;\n    /**\n     * Dispatch an event on the element.\n     */\n    dispatchEvent(type: string, eventInit?: Record<string, unknown>): Promise<void>;\n    /**\n     * Scroll element into view if needed.\n     */\n    scrollIntoViewIfNeeded(): Promise<void>;\n    /**\n     * Get element's bounding box.\n     */\n    boundingBox(): Promise<types.Rect | null>;\n    /**\n     * Click the element.\n     */\n    click(options?: types.MouseClickOptions): Promise<void>;\n    /**\n     * Double-click the element.\n     */\n    dblclick(options?: {\n        button?: types.MouseButton;\n        delay?: number;\n    }): Promise<void>;\n    /**\n     * Hover over the element.\n     */\n    hover(): Promise<void>;\n    /**\n     * Focus the element.\n     */\n    focus(): Promise<void>;\n    /**\n     * Type text into the element.\n     */\n    type(text: string, options?: {\n        delay?: number;\n    }): Promise<void>;\n    /**\n     * Fill the element with text (clears first).\n     */\n    fill(value: string): Promise<void>;\n    /**\n     * Press a key on the focused element.\n     */\n    press(key: string, options?: {\n        delay?: number;\n    }): Promise<void>;\n    /**\n     * Check a checkbox or radio button.\n     */\n    check(): Promise<void>;\n    /**\n     * Uncheck a checkbox.\n     */\n    uncheck(): Promise<void>;\n    /**\n     * Set checked state.\n     */\n    setChecked(checked: boolean): Promise<void>;\n    /**\n     * Take a screenshot of the element.\n     */\n    screenshot(options?: {\n        type?: 'png' | 'jpeg';\n        quality?: number;\n    }): Promise<Uint8Array>;\n    /**\n     * Query for a single element within this element.\n     */\n    $(selector: string): Promise<ElementHandle | null>;\n    /**\n     * Query for all elements within this element.\n     */\n    $$(selector: string): Promise<ElementHandle[]>;\n    /**\n     * Wait for an element state.\n     */\n    waitForElementState(state: 'visible' | 'hidden' | 'enabled' | 'disabled', options?: {\n        timeout?: number;\n    }): Promise<void>;\n}\n//# sourceMappingURL=crHandle.d.ts.map",
      "server/chromium/crInput.d.ts": "/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as input from '../input';\nimport type * as types from '../types';\nimport type { CRSession } from './crConnection';\nimport type { DragManager } from './crDragDrop';\nimport type { CRPage } from './crPage';\nimport type { Progress } from '../progress';\nexport declare class RawKeyboardImpl implements input.RawKeyboard {\n    private _client;\n    private _isMac;\n    private _dragManger;\n    constructor(_client: CRSession, _isMac: boolean, _dragManger: DragManager);\n    _commandsForCode(code: string, modifiers: Set<types.KeyboardModifier>): string[];\n    keydown(progress: Progress, modifiers: Set<types.KeyboardModifier>, keyName: string, description: input.KeyDescription, autoRepeat: boolean): Promise<void>;\n    keyup(progress: Progress, modifiers: Set<types.KeyboardModifier>, keyName: string, description: input.KeyDescription): Promise<void>;\n    sendText(progress: Progress, text: string): Promise<void>;\n}\nexport declare class RawMouseImpl implements input.RawMouse {\n    private _client;\n    private _page;\n    private _dragManager;\n    constructor(page: CRPage, client: CRSession, dragManager: DragManager);\n    move(progress: Progress, x: number, y: number, button: types.MouseButton | 'none', buttons: Set<types.MouseButton>, modifiers: Set<types.KeyboardModifier>, forClick: boolean): Promise<void>;\n    down(progress: Progress, x: number, y: number, button: types.MouseButton, buttons: Set<types.MouseButton>, modifiers: Set<types.KeyboardModifier>, clickCount: number): Promise<void>;\n    up(progress: Progress, x: number, y: number, button: types.MouseButton, buttons: Set<types.MouseButton>, modifiers: Set<types.KeyboardModifier>, clickCount: number): Promise<void>;\n    wheel(progress: Progress, x: number, y: number, buttons: Set<types.MouseButton>, modifiers: Set<types.KeyboardModifier>, deltaX: number, deltaY: number): Promise<void>;\n}\nexport declare class RawTouchscreenImpl implements input.RawTouchscreen {\n    private _client;\n    constructor(client: CRSession);\n    tap(progress: Progress, x: number, y: number, modifiers: Set<types.KeyboardModifier>): Promise<void>;\n}\n//# sourceMappingURL=crInput.d.ts.map",
      "server/chromium/crNetwork.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { CRSession } from './crConnection';\nimport type { CRPage } from './crBrowser';\nexport type URLMatch = string | RegExp | ((url: URL) => boolean);\n/**\n * Request represents a network request.\n */\nexport declare class Request {\n    private _page;\n    private _requestId;\n    private _url;\n    private _method;\n    private _headers;\n    private _postData;\n    private _resourceType;\n    private _redirectedFrom;\n    private _redirectedTo;\n    private _response;\n    private _failureText;\n    private _isNavigationRequest;\n    constructor(page: CRPage, requestId: string, url: string, method: string, headers: Record<string, string>, postData: string | undefined, resourceType: string, isNavigationRequest: boolean);\n    url(): string;\n    method(): string;\n    headers(): Record<string, string>;\n    postData(): string | null;\n    postDataJSON(): unknown | null;\n    resourceType(): string;\n    isNavigationRequest(): boolean;\n    redirectedFrom(): Request | null;\n    redirectedTo(): Request | null;\n    failure(): {\n        errorText: string;\n    } | null;\n    response(): Promise<Response | null>;\n    _setResponse(response: Response): void;\n    _setRedirectedFrom(request: Request): void;\n    _setFailure(text: string): void;\n}\n/**\n * Response represents a network response.\n */\nexport declare class Response {\n    private _request;\n    private _url;\n    private _status;\n    private _statusText;\n    private _headers;\n    private _body;\n    private _bodyPromise;\n    private _session;\n    private _requestId;\n    constructor(request: Request, session: CRSession, requestId: string, url: string, status: number, statusText: string, headers: Record<string, string>);\n    url(): string;\n    status(): number;\n    statusText(): string;\n    headers(): Record<string, string>;\n    ok(): boolean;\n    request(): Request;\n    body(): Promise<Uint8Array>;\n    private _fetchBody;\n    text(): Promise<string>;\n    json(): Promise<unknown>;\n}\n/**\n * Route represents an intercepted route.\n */\nexport declare class Route {\n    private _request;\n    private _session;\n    private _requestId;\n    private _handled;\n    constructor(request: Request, session: CRSession, requestId: string);\n    request(): Request;\n    /**\n     * Continue the request.\n     */\n    continue(options?: {\n        url?: string;\n        method?: string;\n        headers?: Record<string, string>;\n        postData?: string;\n    }): Promise<void>;\n    /**\n     * Fulfill the request with a response.\n     */\n    fulfill(options?: {\n        status?: number;\n        headers?: Record<string, string>;\n        contentType?: string;\n        body?: string | Uint8Array;\n        json?: unknown;\n    }): Promise<void>;\n    /**\n     * Abort the request.\n     */\n    abort(errorCode?: string): Promise<void>;\n}\n/**\n * NetworkManager handles network events and routing.\n */\nexport declare class NetworkManager {\n    private _page;\n    private _session;\n    private _requests;\n    private _routes;\n    private _interceptionEnabled;\n    constructor(page: CRPage, session: CRSession);\n    initialize(): Promise<void>;\n    route(urlMatch: URLMatch, handler: (route: Route, request: Request) => Promise<void> | void): Promise<void>;\n    unroute(urlMatch: URLMatch, handler?: (route: Route, request: Request) => Promise<void> | void): Promise<void>;\n    private _updateInterception;\n    private _onRequestWillBeSent;\n    private _onResponseReceived;\n    private _onLoadingFinished;\n    private _onLoadingFailed;\n    private _onRequestPaused;\n    private _matchUrl;\n}\n//# sourceMappingURL=crNetwork.d.ts.map",
      "server/chromium/crNetworkManager.d.ts": "/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as network from '../network';\nimport type { CRSession } from './crConnection';\nimport type { Protocol } from './protocol';\nimport type { RegisteredListener } from '../utils/eventsHelper';\nimport type * as contexts from '../browserContext';\nimport type * as frames from '../frames';\nimport type { Page } from '../page';\nimport type * as types from '../types';\nimport type { CRServiceWorker } from './crServiceWorker';\ntype SessionInfo = {\n    session: CRSession;\n    isMain?: boolean;\n    workerFrame?: frames.Frame;\n    eventListeners: RegisteredListener[];\n};\nexport declare class CRNetworkManager {\n    private _page;\n    private _serviceWorker;\n    private _requestIdToRequest;\n    private _requestIdToRequestWillBeSentEvent;\n    private _credentials;\n    private _attemptedAuthentications;\n    private _userRequestInterceptionEnabled;\n    private _protocolRequestInterceptionEnabled;\n    private _offline;\n    private _extraHTTPHeaders;\n    private _requestIdToRequestPausedEvent;\n    private _responseExtraInfoTracker;\n    private _sessions;\n    constructor(page: Page | null, serviceWorker: CRServiceWorker | null);\n    addSession(session: CRSession, workerFrame?: frames.Frame, isMain?: boolean): Promise<void>;\n    removeSession(session: CRSession): void;\n    private _forEachSession;\n    authenticate(credentials: types.Credentials | null): Promise<void>;\n    setOffline(offline: boolean): Promise<void>;\n    private _setOfflineForSession;\n    setRequestInterception(value: boolean): Promise<void>;\n    _updateProtocolRequestInterception(): Promise<void>;\n    private _updateProtocolRequestInterceptionForSession;\n    setExtraHTTPHeaders(extraHTTPHeaders: types.HeadersArray): Promise<void>;\n    private _setExtraHTTPHeadersForSession;\n    clearCache(): Promise<void>;\n    _onRequestWillBeSent(sessionInfo: SessionInfo, event: Protocol.Network.requestWillBeSentPayload): void;\n    _onRequestServedFromCache(event: Protocol.Network.requestServedFromCachePayload): void;\n    _onRequestWillBeSentExtraInfo(event: Protocol.Network.requestWillBeSentExtraInfoPayload): void;\n    _onAuthRequired(sessionInfo: SessionInfo, event: Protocol.Fetch.authRequiredPayload): void;\n    _shouldProvideCredentials(url: string): boolean;\n    _onRequestPaused(sessionInfo: SessionInfo, event: Protocol.Fetch.requestPausedPayload): void;\n    _onRequest(requestWillBeSentSessionInfo: SessionInfo, requestWillBeSentEvent: Protocol.Network.requestWillBeSentPayload, requestPausedSessionInfo: SessionInfo | undefined, requestPausedEvent: Protocol.Fetch.requestPausedPayload | undefined): void;\n    _createResponse(request: InterceptableRequest, responsePayload: Protocol.Network.Response, hasExtraInfo: boolean): network.Response;\n    _deleteRequest(request: InterceptableRequest): void;\n    _handleRequestRedirect(request: InterceptableRequest, responsePayload: Protocol.Network.Response, timestamp: number, hasExtraInfo: boolean): void;\n    _onResponseReceivedExtraInfo(event: Protocol.Network.responseReceivedExtraInfoPayload): void;\n    _onResponseReceived(sessionInfo: SessionInfo, event: Protocol.Network.responseReceivedPayload): void;\n    _onLoadingFinished(sessionInfo: SessionInfo, event: Protocol.Network.loadingFinishedPayload): void;\n    _onLoadingFailed(sessionInfo: SessionInfo, event: Protocol.Network.loadingFailedPayload): void;\n    private _maybeUpdateRequestSession;\n}\ndeclare class InterceptableRequest {\n    readonly request: network.Request;\n    readonly _requestId: string;\n    readonly _interceptionId: string | undefined;\n    readonly _documentId: string | undefined;\n    readonly _timestamp: number;\n    readonly _wallTime: number;\n    readonly _route: RouteImpl | null;\n    readonly _originalRequestRoute: RouteImpl | undefined;\n    session: CRSession;\n    constructor(options: {\n        session: CRSession;\n        context: contexts.BrowserContext;\n        frame: frames.Frame | null;\n        serviceWorker: CRServiceWorker | null;\n        documentId?: string;\n        route: RouteImpl | null;\n        requestWillBeSentEvent: Protocol.Network.requestWillBeSentPayload;\n        requestPausedEvent: Protocol.Fetch.requestPausedPayload | undefined;\n        redirectedFrom: InterceptableRequest | null;\n        headersOverride: types.HeadersArray | null;\n    });\n}\ndeclare class RouteImpl implements network.RouteDelegate {\n    private readonly _session;\n    private _interceptionId;\n    _alreadyContinuedParams: Protocol.Fetch.continueRequestParameters | undefined;\n    _fulfilled: boolean;\n    constructor(session: CRSession, interceptionId: string);\n    continue(overrides: types.NormalizedContinueOverrides): Promise<void>;\n    fulfill(response: types.NormalizedFulfillResponse): Promise<void>;\n    abort(errorCode?: string): Promise<void>;\n}\nexport {};\n//# sourceMappingURL=crNetworkManager.d.ts.map",
      "server/chromium/crPage.d.ts": "/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as dom from '../dom';\nimport * as frames from '../frames';\nimport { Page } from '../page';\nimport { CRBrowserContext } from './crBrowser';\nimport { CRCoverage } from './crCoverage';\nimport { RawKeyboardImpl, RawMouseImpl, RawTouchscreenImpl } from './crInput';\nimport { CRNetworkManager } from './crNetworkManager';\nimport type { CRSession } from './crConnection';\nimport type { Protocol } from './protocol';\nimport type { InitScript, PageDelegate } from '../page';\nimport type { Progress } from '../progress';\nimport type * as types from '../types';\nimport type * as channels from '@protocol/channels';\nexport type WindowBounds = {\n    top?: number;\n    left?: number;\n    width?: number;\n    height?: number;\n};\nexport declare class CRPage implements PageDelegate {\n    readonly utilityWorldName: string;\n    readonly _mainFrameSession: FrameSession;\n    readonly _sessions: Map<string, FrameSession>;\n    readonly _page: Page;\n    readonly rawMouse: RawMouseImpl;\n    readonly rawKeyboard: RawKeyboardImpl;\n    readonly rawTouchscreen: RawTouchscreenImpl;\n    readonly _targetId: string;\n    readonly _opener: CRPage | null;\n    readonly _networkManager: CRNetworkManager;\n    private readonly _pdf;\n    private readonly _coverage;\n    readonly _browserContext: CRBrowserContext;\n    readonly _nextWindowOpenPopupFeatures: string[][];\n    static mainFrameSession(page: Page): FrameSession;\n    constructor(client: CRSession, targetId: string, browserContext: CRBrowserContext, opener: CRPage | null, bits: {\n        hasUIWindow: boolean;\n    });\n    private _forAllFrameSessions;\n    _sessionForFrame(frame: frames.Frame): FrameSession;\n    private _sessionForHandle;\n    willBeginDownload(): void;\n    didClose(): void;\n    navigateFrame(frame: frames.Frame, url: string, referrer: string | undefined): Promise<frames.GotoResult>;\n    updateExtraHTTPHeaders(): Promise<void>;\n    updateGeolocation(): Promise<void>;\n    updateOffline(): Promise<void>;\n    updateHttpCredentials(): Promise<void>;\n    updateEmulatedViewportSize(preserveWindowBoundaries?: boolean): Promise<void>;\n    bringToFront(): Promise<void>;\n    updateEmulateMedia(): Promise<void>;\n    updateUserAgent(): Promise<void>;\n    updateRequestInterception(): Promise<void>;\n    updateFileChooserInterception(): Promise<void>;\n    reload(): Promise<void>;\n    private _go;\n    goBack(): Promise<boolean>;\n    goForward(): Promise<boolean>;\n    requestGC(): Promise<void>;\n    addInitScript(initScript: InitScript, world?: types.World): Promise<void>;\n    exposePlaywrightBinding(): Promise<void>;\n    removeInitScripts(initScripts: InitScript[]): Promise<void>;\n    closePage(runBeforeUnload: boolean): Promise<void>;\n    setBackgroundColor(color?: {\n        r: number;\n        g: number;\n        b: number;\n        a: number;\n    }): Promise<void>;\n    takeScreenshot(progress: Progress, format: 'png' | 'jpeg', documentRect: types.Rect | undefined, viewportRect: types.Rect | undefined, quality: number | undefined, fitsViewport: boolean, scale: 'css' | 'device'): Promise<Buffer>;\n    getContentFrame(handle: dom.ElementHandle): Promise<frames.Frame | null>;\n    getOwnerFrame(handle: dom.ElementHandle): Promise<string | null>;\n    getBoundingBox(handle: dom.ElementHandle): Promise<types.Rect | null>;\n    scrollRectIntoViewIfNeeded(handle: dom.ElementHandle, rect?: types.Rect): Promise<'error:notvisible' | 'error:notconnected' | 'done'>;\n    setScreencastOptions(options: {\n        width: number;\n        height: number;\n        quality: number;\n    } | null): Promise<void>;\n    rafCountForStablePosition(): number;\n    getContentQuads(handle: dom.ElementHandle): Promise<types.Quad[] | null>;\n    setInputFilePaths(handle: dom.ElementHandle<HTMLInputElement>, files: string[]): Promise<void>;\n    adoptElementHandle<T extends Node>(handle: dom.ElementHandle<T>, to: dom.FrameExecutionContext): Promise<dom.ElementHandle<T>>;\n    inputActionEpilogue(): Promise<void>;\n    resetForReuse(progress: Progress): Promise<void>;\n    pdf(options: channels.PagePdfParams): Promise<Buffer>;\n    coverage(): CRCoverage;\n    getFrameElement(frame: frames.Frame): Promise<dom.ElementHandle>;\n    shouldToggleStyleSheetToSyncAnimations(): boolean;\n}\ndeclare class FrameSession {\n    readonly _client: CRSession;\n    readonly _crPage: CRPage;\n    readonly _page: Page;\n    private readonly _parentSession;\n    private readonly _childSessions;\n    private readonly _contextIdToContext;\n    private _eventListeners;\n    readonly _targetId: string;\n    private _firstNonInitialNavigationCommittedPromise;\n    private _firstNonInitialNavigationCommittedFulfill;\n    private _firstNonInitialNavigationCommittedReject;\n    private _windowId;\n    private _swappedIn;\n    private _videoRecorder;\n    private _screencastId;\n    private _screencastClients;\n    private _metricsOverride;\n    private _workerSessions;\n    private _initScriptIds;\n    private _bufferedAttachedToTargetEvents;\n    constructor(crPage: CRPage, client: CRSession, targetId: string, parentSession: FrameSession | null);\n    _isMainFrame(): boolean;\n    private _addRendererListeners;\n    private _addBrowserListeners;\n    _initialize(hasUIWindow: boolean): Promise<void>;\n    dispose(): void;\n    _navigate(frame: frames.Frame, url: string, referrer: string | undefined): Promise<frames.GotoResult>;\n    _onLifecycleEvent(event: Protocol.Page.lifecycleEventPayload): void;\n    _handleFrameTree(frameTree: Protocol.Page.FrameTree): void;\n    private _eventBelongsToStaleFrame;\n    _onFrameAttached(frameId: string, parentFrameId: string | null): void;\n    _onFrameNavigated(framePayload: Protocol.Page.Frame, initial: boolean): void;\n    _onFrameRequestedNavigation(payload: Protocol.Page.frameRequestedNavigationPayload): void;\n    _onFrameNavigatedWithinDocument(frameId: string, url: string): void;\n    _onFrameDetached(frameId: string, reason: 'remove' | 'swap'): void;\n    _onExecutionContextCreated(contextPayload: Protocol.Runtime.ExecutionContextDescription): void;\n    _onExecutionContextDestroyed(executionContextId: number): void;\n    _onExecutionContextsCleared(): void;\n    _onAttachedToTarget(event: Protocol.Target.attachedToTargetPayload): void;\n    _onDetachedFromTarget(event: Protocol.Target.detachedFromTargetPayload): void;\n    _onWindowOpen(event: Protocol.Page.windowOpenPayload): void;\n    _onConsoleAPI(event: Protocol.Runtime.consoleAPICalledPayload): Promise<void>;\n    _onBindingCalled(event: Protocol.Runtime.bindingCalledPayload): Promise<void>;\n    _onDialog(event: Protocol.Page.javascriptDialogOpeningPayload): void;\n    _handleException(exceptionDetails: Protocol.Runtime.ExceptionDetails): void;\n    _onTargetCrashed(): Promise<void>;\n    _onLogEntryAdded(event: Protocol.Log.entryAddedPayload): void;\n    _onFileChooserOpened(event: Protocol.Page.fileChooserOpenedPayload): Promise<void>;\n    _willBeginDownload(): void;\n    _onScreencastFrame(payload: Protocol.Page.screencastFramePayload): void;\n    _createVideoRecorder(screencastId: string, options: types.PageScreencastOptions): Promise<void>;\n    _startVideoRecording(options: types.PageScreencastOptions): Promise<void>;\n    _stopVideoRecording(): Promise<void>;\n    _startScreencast(client: any, options?: Protocol.Page.startScreencastParameters): Promise<void>;\n    _stopScreencast(client: any): Promise<void>;\n    _updateGeolocation(initial: boolean): Promise<void>;\n    _updateViewport(preserveWindowBoundaries?: boolean): Promise<void>;\n    windowBounds(): Promise<WindowBounds>;\n    setWindowBounds(bounds: WindowBounds): Promise<Protocol.Browser.setWindowBoundsReturnValue>;\n    _updateEmulateMedia(): Promise<void>;\n    _updateUserAgent(): Promise<void>;\n    private _setDefaultFontFamilies;\n    _updateFileChooserInterception(initial: boolean): Promise<void>;\n    _evaluateOnNewDocument(initScript: InitScript, world: types.World, runImmediately?: boolean): Promise<void>;\n    _removeEvaluatesOnNewDocument(initScripts: InitScript[]): Promise<void>;\n    exposePlaywrightBinding(): Promise<void>;\n    _getContentFrame(handle: dom.ElementHandle): Promise<frames.Frame | null>;\n    _getOwnerFrame(handle: dom.ElementHandle): Promise<string | null>;\n    _getBoundingBox(handle: dom.ElementHandle): Promise<types.Rect | null>;\n    private _framePosition;\n    _scrollRectIntoViewIfNeeded(handle: dom.ElementHandle, rect?: types.Rect): Promise<'error:notvisible' | 'error:notconnected' | 'done'>;\n    _getContentQuads(handle: dom.ElementHandle): Promise<types.Quad[] | null>;\n    _adoptElementHandle<T extends Node>(handle: dom.ElementHandle<T>, to: dom.FrameExecutionContext): Promise<dom.ElementHandle<T>>;\n    _adoptBackendNodeId(backendNodeId: Protocol.DOM.BackendNodeId, to: dom.FrameExecutionContext): Promise<dom.ElementHandle>;\n}\nexport {};\n//# sourceMappingURL=crPage.d.ts.map",
      "server/chromium/crPdf.d.ts": "/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { CRSession } from './crConnection';\nimport type * as channels from '@protocol/channels';\nexport declare class CRPDF {\n    private _client;\n    constructor(client: CRSession);\n    generate(options: channels.PagePdfParams): Promise<Buffer>;\n}\n//# sourceMappingURL=crPdf.d.ts.map",
      "server/chromium/crProtocolHelper.d.ts": "/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { CRSession } from './crConnection';\nimport type { Protocol } from './protocol';\nimport type * as types from '../types';\nexport declare function getExceptionMessage(exceptionDetails: Protocol.Runtime.ExceptionDetails): string;\nexport declare function releaseObject(client: CRSession, objectId: string): Promise<void>;\nexport declare function saveProtocolStream(client: CRSession, handle: string, path: string): Promise<void>;\nexport declare function readProtocolStream(client: CRSession, handle: string): Promise<Buffer>;\nexport declare function toConsoleMessageLocation(stackTrace: Protocol.Runtime.StackTrace | undefined): types.ConsoleMessageLocation;\nexport declare function exceptionToError(exceptionDetails: Protocol.Runtime.ExceptionDetails): Error;\nexport declare function toModifiersMask(modifiers: Set<types.KeyboardModifier>): number;\nexport declare function toButtonsMask(buttons: Set<types.MouseButton>): number;\n//# sourceMappingURL=crProtocolHelper.d.ts.map",
      "server/chromium/crServiceWorker.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Worker } from '../page';\nimport * as network from '../network';\nimport type { CRBrowserContext } from './crBrowser';\nimport type { CRSession } from './crConnection';\nexport declare class CRServiceWorker extends Worker {\n    readonly browserContext: CRBrowserContext;\n    private readonly _networkManager?;\n    private _session;\n    constructor(browserContext: CRBrowserContext, session: CRSession, url: string);\n    didClose(): void;\n    updateOffline(): Promise<void>;\n    updateHttpCredentials(): Promise<void>;\n    updateExtraHTTPHeaders(): Promise<void>;\n    updateRequestInterception(): Promise<void>;\n    needsRequestInterception(): boolean;\n    reportRequestFinished(request: network.Request, response: network.Response | null): void;\n    requestFailed(request: network.Request, _canceled: boolean): void;\n    requestReceivedResponse(response: network.Response): void;\n    requestStarted(request: network.Request, route?: network.RouteDelegate): void;\n    private _isNetworkInspectionEnabled;\n}\n//# sourceMappingURL=crServiceWorker.d.ts.map",
      "server/chromium/defaultFontFamilies.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { Protocol } from './protocol';\nexport declare const platformToFontFamilies: {\n    [key in 'linux' | 'mac' | 'win']: Protocol.Page.setFontFamiliesParameters;\n};\n//# sourceMappingURL=defaultFontFamilies.d.ts.map",
      "server/chromium/locator.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { CRPage } from './crBrowser';\nimport type { ElementHandle } from './crHandle';\nimport type * as types from '../types';\nexport interface LocatorOptions {\n    hasText?: string | RegExp;\n    hasNotText?: string | RegExp;\n    has?: Locator;\n    hasNot?: Locator;\n}\nexport interface ByRoleOptions {\n    checked?: boolean;\n    disabled?: boolean;\n    exact?: boolean;\n    expanded?: boolean;\n    includeHidden?: boolean;\n    level?: number;\n    name?: string | RegExp;\n    pressed?: boolean;\n    selected?: boolean;\n}\n/**\n * Locator - represents a way to find element(s) on the page.\n * Locators are lazy - they don't query the page until needed.\n */\nexport declare class Locator {\n    readonly _page: CRPage;\n    readonly _selector: string;\n    constructor(page: CRPage, selector: string, options?: LocatorOptions);\n    page(): CRPage;\n    /**\n     * Chain to a child locator.\n     */\n    locator(selector: string, options?: LocatorOptions): Locator;\n    /**\n     * Filter this locator.\n     */\n    filter(options?: LocatorOptions): Locator;\n    /**\n     * Get the first matching element.\n     */\n    first(): Locator;\n    /**\n     * Get the last matching element.\n     */\n    last(): Locator;\n    /**\n     * Get the nth matching element (0-indexed).\n     */\n    nth(index: number): Locator;\n    /**\n     * Locate by test id attribute.\n     */\n    getByTestId(testId: string | RegExp): Locator;\n    /**\n     * Locate by text content.\n     */\n    getByText(text: string | RegExp, options?: {\n        exact?: boolean;\n    }): Locator;\n    /**\n     * Locate by ARIA role.\n     */\n    getByRole(role: string, options?: ByRoleOptions): Locator;\n    /**\n     * Locate by label text.\n     */\n    getByLabel(text: string | RegExp, options?: {\n        exact?: boolean;\n    }): Locator;\n    /**\n     * Locate by placeholder text.\n     */\n    getByPlaceholder(text: string | RegExp, options?: {\n        exact?: boolean;\n    }): Locator;\n    /**\n     * Locate by alt text.\n     */\n    getByAltText(text: string | RegExp, options?: {\n        exact?: boolean;\n    }): Locator;\n    /**\n     * Locate by title attribute.\n     */\n    getByTitle(text: string | RegExp, options?: {\n        exact?: boolean;\n    }): Locator;\n    /**\n     * Click the element.\n     */\n    click(options?: types.MouseClickOptions): Promise<void>;\n    /**\n     * Double-click the element.\n     */\n    dblclick(options?: {\n        button?: types.MouseButton;\n        delay?: number;\n    }): Promise<void>;\n    /**\n     * Fill the element with text.\n     */\n    fill(value: string): Promise<void>;\n    /**\n     * Type text into the element.\n     */\n    type(text: string, options?: {\n        delay?: number;\n    }): Promise<void>;\n    /**\n     * Press a key on the element.\n     */\n    press(key: string, options?: {\n        delay?: number;\n    }): Promise<void>;\n    /**\n     * Focus the element.\n     */\n    focus(): Promise<void>;\n    /**\n     * Hover over the element.\n     */\n    hover(): Promise<void>;\n    /**\n     * Check a checkbox/radio.\n     */\n    check(): Promise<void>;\n    /**\n     * Uncheck a checkbox.\n     */\n    uncheck(): Promise<void>;\n    /**\n     * Set checked state.\n     */\n    setChecked(checked: boolean): Promise<void>;\n    /**\n     * Scroll element into view.\n     */\n    scrollIntoViewIfNeeded(): Promise<void>;\n    /**\n     * Take a screenshot of the element.\n     */\n    screenshot(options?: {\n        type?: 'png' | 'jpeg';\n        quality?: number;\n    }): Promise<Uint8Array>;\n    /**\n     * Get the number of matching elements.\n     */\n    count(): Promise<number>;\n    /**\n     * Get the element handle.\n     */\n    elementHandle(options?: {\n        timeout?: number;\n    }): Promise<ElementHandle>;\n    /**\n     * Get all element handles.\n     */\n    elementHandles(): Promise<ElementHandle[]>;\n    /**\n     * Get attribute value.\n     */\n    getAttribute(name: string): Promise<string | null>;\n    /**\n     * Get text content.\n     */\n    textContent(): Promise<string | null>;\n    /**\n     * Get inner text.\n     */\n    innerText(): Promise<string>;\n    /**\n     * Get inner HTML.\n     */\n    innerHTML(): Promise<string>;\n    /**\n     * Get input value.\n     */\n    inputValue(): Promise<string>;\n    /**\n     * Get bounding box.\n     */\n    boundingBox(): Promise<types.Rect | null>;\n    /**\n     * Check if element is visible.\n     */\n    isVisible(): Promise<boolean>;\n    /**\n     * Check if element is hidden.\n     */\n    isHidden(): Promise<boolean>;\n    /**\n     * Check if element is enabled.\n     */\n    isEnabled(): Promise<boolean>;\n    /**\n     * Check if element is disabled.\n     */\n    isDisabled(): Promise<boolean>;\n    /**\n     * Check if element is checked.\n     */\n    isChecked(): Promise<boolean>;\n    /**\n     * Check if element is editable.\n     */\n    isEditable(): Promise<boolean>;\n    /**\n     * Wait for the element.\n     */\n    waitFor(options?: {\n        state?: 'attached' | 'detached' | 'visible' | 'hidden';\n        timeout?: number;\n    }): Promise<void>;\n    /**\n     * Get all matching locators.\n     */\n    all(): Promise<Locator[]>;\n    /**\n     * Get all inner texts.\n     */\n    allInnerTexts(): Promise<string[]>;\n    /**\n     * Get all text contents.\n     */\n    allTextContents(): Promise<string[]>;\n    /**\n     * Evaluate a function on the element.\n     */\n    evaluate<R>(pageFunction: (el: Element, ...args: unknown[]) => R, ...args: unknown[]): Promise<R>;\n    /**\n     * Evaluate a function on all matching elements.\n     */\n    evaluateAll<R>(pageFunction: (els: Element[], ...args: unknown[]) => R, ...args: unknown[]): Promise<R>;\n    private _resolveElement;\n    toString(): string;\n}\n//# sourceMappingURL=locator.d.ts.map",
      "server/chromium/videoRecorder.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Page } from '../page';\nimport type * as types from '../types';\nexport declare class VideoRecorder {\n    private _process;\n    private _gracefullyClose;\n    private _lastWritePromise;\n    private _firstFrameTimestamp;\n    private _lastFrame;\n    private _lastWriteNodeTime;\n    private _frameQueue;\n    private _isStopped;\n    private _ffmpegPath;\n    static launch(page: Page, ffmpegPath: string, options: types.PageScreencastOptions): Promise<VideoRecorder>;\n    private constructor();\n    private _launch;\n    writeFrame(frame: Buffer, timestamp: number): void;\n    private _sendFrames;\n    private _sendFrame;\n    stop(): Promise<void>;\n}\n//# sourceMappingURL=videoRecorder.d.ts.map",
      "server/clock.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { BrowserContext } from './browserContext';\nimport type { Progress } from '@protocol/progress';\nexport declare class Clock {\n    private _browserContext;\n    private _initScripts;\n    constructor(browserContext: BrowserContext);\n    uninstall(progress: Progress): Promise<void>;\n    fastForward(progress: Progress, ticks: number | string): Promise<void>;\n    install(progress: Progress, time: number | string | undefined): Promise<void>;\n    pauseAt(progress: Progress, ticks: number | string): Promise<void>;\n    resumeNoReply(): void;\n    resume(progress: Progress): Promise<void>;\n    setFixedTime(progress: Progress, time: string | number): Promise<void>;\n    setSystemTime(progress: Progress, time: string | number): Promise<void>;\n    runFor(progress: Progress, ticks: number | string): Promise<void>;\n    private _installIfNeeded;\n    private _evaluateInFrames;\n}\n//# sourceMappingURL=clock.d.ts.map",
      "server/codegen/csharp.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { Language, LanguageGenerator, LanguageGeneratorOptions } from './types';\nimport type * as actions from '@recorder/actions';\ntype CSharpLanguageMode = 'library' | 'mstest' | 'nunit';\nexport declare class CSharpLanguageGenerator implements LanguageGenerator {\n    id: string;\n    groupName: string;\n    name: string;\n    highlighter: Language;\n    _mode: CSharpLanguageMode;\n    constructor(mode: CSharpLanguageMode);\n    generateAction(actionInContext: actions.ActionInContext): string;\n    _generateActionInner(actionInContext: actions.ActionInContext): string;\n    private _formatPageAlias;\n    private _generateActionCall;\n    private _asLocator;\n    generateHeader(options: LanguageGeneratorOptions): string;\n    generateStandaloneHeader(options: LanguageGeneratorOptions): string;\n    generateTestRunnerHeader(options: LanguageGeneratorOptions): string;\n    generateFooter(saveStorage: string | undefined): string;\n}\nexport {};\n//# sourceMappingURL=csharp.d.ts.map",
      "server/codegen/java.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { Language, LanguageGenerator, LanguageGeneratorOptions } from './types';\nimport type * as actions from '@recorder/actions';\ntype JavaLanguageMode = 'library' | 'junit';\nexport declare class JavaLanguageGenerator implements LanguageGenerator {\n    id: string;\n    groupName: string;\n    name: string;\n    highlighter: Language;\n    _mode: JavaLanguageMode;\n    constructor(mode: JavaLanguageMode);\n    generateAction(actionInContext: actions.ActionInContext): string;\n    private _generateActionCall;\n    private _asLocator;\n    generateHeader(options: LanguageGeneratorOptions): string;\n    generateFooter(saveStorage: string | undefined): string;\n}\nexport {};\n//# sourceMappingURL=java.d.ts.map",
      "server/codegen/javascript.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { Language, LanguageGenerator, LanguageGeneratorOptions } from './types';\nimport type * as actions from '@recorder/actions';\nexport declare class JavaScriptLanguageGenerator implements LanguageGenerator {\n    id: string;\n    groupName: string;\n    name: string;\n    highlighter: Language;\n    private _isTest;\n    constructor(isTest: boolean);\n    generateAction(actionInContext: actions.ActionInContext): string;\n    private _generateActionCall;\n    private _asLocator;\n    generateHeader(options: LanguageGeneratorOptions): string;\n    generateFooter(saveStorage: string | undefined): string;\n    generateTestHeader(options: LanguageGeneratorOptions): string;\n    generateTestFooter(saveStorage: string | undefined): string;\n    generateStandaloneHeader(options: LanguageGeneratorOptions): string;\n    generateStandaloneFooter(saveStorage: string | undefined): string;\n}\nexport declare class JavaScriptFormatter {\n    private _baseIndent;\n    private _baseOffset;\n    private _lines;\n    constructor(offset?: number);\n    prepend(text: string): void;\n    add(text: string): void;\n    newLine(): void;\n    format(): string;\n}\nexport declare function quoteMultiline(text: string, indent?: string): string;\n//# sourceMappingURL=javascript.d.ts.map",
      "server/codegen/jsonl.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { Language, LanguageGenerator, LanguageGeneratorOptions } from './types';\nimport type * as actions from '@recorder/actions';\nexport declare class JsonlLanguageGenerator implements LanguageGenerator {\n    id: string;\n    groupName: string;\n    name: string;\n    highlighter: Language;\n    generateAction(actionInContext: actions.ActionInContext): string;\n    generateHeader(options: LanguageGeneratorOptions): string;\n    generateFooter(saveStorage: string | undefined): string;\n}\n//# sourceMappingURL=jsonl.d.ts.map",
      "server/codegen/language.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { BrowserContextOptions } from '../../..';\nimport type * as types from '../types';\nimport type { LanguageGenerator, LanguageGeneratorOptions } from './types';\nimport type * as actions from '@recorder/actions';\nexport declare function generateCode(actions: actions.ActionInContext[], languageGenerator: LanguageGenerator, options: LanguageGeneratorOptions): {\n    header: string;\n    footer: string;\n    actionTexts: string[];\n    text: string;\n};\nexport declare function sanitizeDeviceOptions(device: any, options: BrowserContextOptions): BrowserContextOptions;\nexport declare function toSignalMap(action: actions.Action): {\n    popup: any;\n    download: any;\n    dialog: any;\n};\nexport declare function toKeyboardModifiers(modifiers: number): types.SmartKeyboardModifier[];\nexport declare function fromKeyboardModifiers(modifiers?: types.SmartKeyboardModifier[]): number;\nexport declare function toClickOptionsForSourceCode(action: actions.ClickAction): types.MouseClickOptions;\n//# sourceMappingURL=language.d.ts.map",
      "server/codegen/languages.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { CSharpLanguageGenerator } from './csharp';\nimport { JavaLanguageGenerator } from './java';\nimport { JavaScriptLanguageGenerator } from './javascript';\nimport { JsonlLanguageGenerator } from './jsonl';\nimport { PythonLanguageGenerator } from './python';\nexport declare function languageSet(): Set<JavaScriptLanguageGenerator | PythonLanguageGenerator | CSharpLanguageGenerator | JavaLanguageGenerator | JsonlLanguageGenerator>;\n//# sourceMappingURL=languages.d.ts.map",
      "server/codegen/python.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { Language, LanguageGenerator, LanguageGeneratorOptions } from './types';\nimport type * as actions from '@recorder/actions';\nexport declare class PythonLanguageGenerator implements LanguageGenerator {\n    id: string;\n    groupName: string;\n    name: string;\n    highlighter: Language;\n    private _awaitPrefix;\n    private _asyncPrefix;\n    private _isAsync;\n    private _isPyTest;\n    constructor(isAsync: boolean, isPyTest: boolean);\n    generateAction(actionInContext: actions.ActionInContext): string;\n    private _generateActionCall;\n    private _asLocator;\n    generateHeader(options: LanguageGeneratorOptions): string;\n    generateFooter(saveStorage: string | undefined): string;\n}\n//# sourceMappingURL=python.d.ts.map",
      "server/codegen/types.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { BrowserContextOptions, LaunchOptions } from '../../../types/types';\nimport type { Language } from '../../utils';\nimport type * as actions from '@recorder/actions';\nexport type { Language } from '../../utils';\nexport type LanguageGeneratorOptions = {\n    browserName: string;\n    launchOptions: LaunchOptions;\n    contextOptions: BrowserContextOptions;\n    deviceName?: string;\n    saveStorage?: string;\n    generateAutoExpect?: boolean;\n};\nexport interface LanguageGenerator {\n    id: string;\n    groupName: string;\n    name: string;\n    highlighter: Language;\n    generateHeader(options: LanguageGeneratorOptions): string;\n    generateAction(actionInContext: actions.ActionInContext): string;\n    generateFooter(saveStorage: string | undefined): string;\n}\n//# sourceMappingURL=types.d.ts.map",
      "server/console.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type * as js from './javascript';\nimport type { Page, Worker } from './page';\nimport type { ConsoleMessageLocation } from './types';\nexport declare class ConsoleMessage {\n    private _type;\n    private _text?;\n    private _args;\n    private _location;\n    private _page;\n    private _worker;\n    constructor(page: Page | null, worker: Worker | null, type: string, text: string | undefined, args: js.JSHandle[], location?: ConsoleMessageLocation);\n    page(): Page;\n    worker(): Worker;\n    type(): string;\n    text(): string;\n    args(): js.JSHandle[];\n    location(): ConsoleMessageLocation;\n}\n//# sourceMappingURL=console.d.ts.map",
      "server/cookieStore.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type * as channels from '@protocol/channels';\nexport declare class Cookie {\n    private _raw;\n    constructor(data: channels.NetworkCookie);\n    name(): string;\n    matches(url: URL): boolean;\n    equals(other: Cookie): boolean;\n    networkCookie(): channels.NetworkCookie;\n    updateExpiresFrom(other: Cookie): void;\n    expired(): boolean;\n}\nexport declare class CookieStore {\n    private readonly _nameToCookies;\n    addCookies(cookies: channels.NetworkCookie[]): void;\n    cookies(url: URL): channels.NetworkCookie[];\n    allCookies(): channels.NetworkCookie[];\n    private _addCookie;\n    private _cookiesIterator;\n    private static pruneExpired;\n}\ntype RawCookie = {\n    name: string;\n    value: string;\n    domain?: string;\n    path?: string;\n    expires?: number;\n    httpOnly?: boolean;\n    secure?: boolean;\n    sameSite?: 'Strict' | 'Lax' | 'None';\n};\nexport declare function parseRawCookie(header: string): RawCookie | null;\nexport declare function domainMatches(value: string, domain: string): boolean;\nexport {};\n//# sourceMappingURL=cookieStore.d.ts.map",
      "server/debugController.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SdkObject } from './instrumentation';\nimport type { Language } from '../utils';\nimport type { Playwright } from './playwright';\nimport type { Mode } from '@recorder/recorderTypes';\nimport type { Progress } from '@protocol/progress';\nexport declare class DebugController extends SdkObject {\n    static Events: {\n        StateChanged: string;\n        InspectRequested: string;\n        SourceChanged: string;\n        Paused: string;\n        SetModeRequested: string;\n    };\n    private _trackHierarchyListener;\n    private _playwright;\n    _sdkLanguage: Language;\n    _generateAutoExpect: boolean;\n    constructor(playwright: Playwright);\n    initialize(codegenId: string, sdkLanguage: Language): void;\n    dispose(): void;\n    setReportStateChanged(enabled: boolean): void;\n    setRecorderMode(progress: Progress, params: {\n        mode: Mode;\n        testIdAttributeName?: string;\n        generateAutoExpect?: boolean;\n    }): Promise<void>;\n    highlight(progress: Progress, params: {\n        selector?: string;\n        ariaTemplate?: string;\n    }): Promise<void>;\n    hideHighlight(progress: Progress): Promise<void>;\n    resume(progress: Progress): Promise<void>;\n    kill(): void;\n    private _emitSnapshot;\n    private _allRecorders;\n    private _closeBrowsersWithoutPages;\n}\n//# sourceMappingURL=debugController.d.ts.map",
      "server/debugLogger.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Simple debug logger for browser environment.\n */\nexport declare const debugLogger: {\n    isEnabled(name: string): boolean;\n    log(name: string, message: string | Error): void;\n};\n/**\n * Collects recent logs for error reporting.\n */\nexport declare class RecentLogsCollector {\n    private _logs;\n    private _maxLogs;\n    log(message: string): void;\n    recentLogs(): string[];\n}\n//# sourceMappingURL=debugLogger.d.ts.map",
      "server/debugger.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { EventEmitter } from 'events';\nimport { BrowserContext } from './browserContext';\nimport type { CallMetadata, InstrumentationListener, SdkObject } from './instrumentation';\nexport declare class Debugger extends EventEmitter implements InstrumentationListener {\n    private _pauseOnNextStatement;\n    private _pausedCallsMetadata;\n    private _enabled;\n    private _context;\n    static Events: {\n        PausedStateChanged: string;\n    };\n    private _muted;\n    constructor(context: BrowserContext);\n    setMuted(muted: boolean): Promise<void>;\n    onBeforeCall(sdkObject: SdkObject, metadata: CallMetadata): Promise<void>;\n    onBeforeInputAction(sdkObject: SdkObject, metadata: CallMetadata): Promise<void>;\n    pause(sdkObject: SdkObject, metadata: CallMetadata): Promise<void>;\n    resume(step: boolean): void;\n    pauseOnNextStatement(): void;\n    isPaused(metadata?: CallMetadata): boolean;\n    pausedDetails(): {\n        metadata: CallMetadata;\n        sdkObject: SdkObject;\n    }[];\n}\n//# sourceMappingURL=debugger.d.ts.map",
      "server/deviceDescriptors.d.ts": "/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { Devices } from './types';\nexport declare const deviceDescriptors: Devices;\n//# sourceMappingURL=deviceDescriptors.d.ts.map",
      "server/dialog.d.ts": "/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SdkObject } from './instrumentation';\nimport type { Instrumentation } from './instrumentation';\nimport type { Page } from './page';\ntype OnHandle = (accept: boolean, promptText?: string) => Promise<void>;\nexport type DialogType = 'alert' | 'beforeunload' | 'confirm' | 'prompt';\nexport declare class Dialog extends SdkObject {\n    private _page;\n    private _type;\n    private _message;\n    private _onHandle;\n    private _handled;\n    private _defaultValue;\n    constructor(page: Page, type: DialogType, message: string, onHandle: OnHandle, defaultValue?: string);\n    page(): Page;\n    type(): string;\n    message(): string;\n    defaultValue(): string;\n    accept(promptText?: string): Promise<void>;\n    dismiss(): Promise<void>;\n    close(): Promise<void>;\n}\nexport declare class DialogManager {\n    private _instrumentation;\n    private _dialogHandlers;\n    private _openedDialogs;\n    constructor(instrumentation: Instrumentation);\n    dialogDidOpen(dialog: Dialog): void;\n    dialogWillClose(dialog: Dialog): void;\n    addDialogHandler(handler: (dialog: Dialog) => boolean): void;\n    removeDialogHandler(handler: (dialog: Dialog) => boolean): void;\n    hasOpenDialogsForPage(page: Page): boolean;\n    closeBeforeUnloadDialogs(): Promise<void>;\n}\nexport {};\n//# sourceMappingURL=dialog.d.ts.map",
      "server/dom.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as js from './javascript';\nimport type * as frames from './frames';\nimport type { ElementState, InjectedScript } from '@injected/injectedScript';\nimport type { Page } from './page';\nimport type { Progress } from './progress';\nimport type { ScreenshotOptions } from './screenshotter';\nimport type * as types from './types';\nimport type * as channels from '@protocol/channels';\nexport type InputFilesItems = {\n    filePayloads?: types.FilePayload[];\n    localPaths?: string[];\n    localDirectory?: string;\n};\ntype ActionName = 'click' | 'hover' | 'dblclick' | 'tap' | 'move and up' | 'move and down';\ntype PerformActionResult = 'error:notvisible' | 'error:notconnected' | 'error:notinviewport' | 'error:optionsnotfound' | 'error:optionnotenabled' | {\n    missingState: ElementState;\n} | {\n    hitTargetDescription: string;\n} | 'done';\nexport declare class NonRecoverableDOMError extends Error {\n}\nexport declare function isNonRecoverableDOMError(error: Error): error is NonRecoverableDOMError;\nexport declare class FrameExecutionContext extends js.ExecutionContext {\n    readonly frame: frames.Frame;\n    private _injectedScriptPromise?;\n    readonly world: types.World | null;\n    constructor(delegate: js.ExecutionContextDelegate, frame: frames.Frame, world: types.World | null);\n    adoptIfNeeded(handle: js.JSHandle): Promise<js.JSHandle> | null;\n    evaluate<Arg, R>(pageFunction: js.Func1<Arg, R>, arg?: Arg): Promise<R>;\n    evaluateHandle<Arg, R>(pageFunction: js.Func1<Arg, R>, arg?: Arg): Promise<js.SmartHandle<R>>;\n    evaluateExpression(expression: string, options: {\n        isFunction?: boolean;\n    }, arg?: any): Promise<any>;\n    evaluateExpressionHandle(expression: string, options: {\n        isFunction?: boolean;\n    }, arg?: any): Promise<js.JSHandle<any>>;\n    injectedScript(): Promise<js.JSHandle<InjectedScript>>;\n}\nexport declare class ElementHandle<T extends Node = Node> extends js.JSHandle<T> {\n    __elementhandle: T;\n    readonly _context: FrameExecutionContext;\n    readonly _page: Page;\n    readonly _objectId: string;\n    readonly _frame: frames.Frame;\n    constructor(context: FrameExecutionContext, objectId: string);\n    _initializePreview(): Promise<void>;\n    asElement(): ElementHandle<T> | null;\n    evaluateInUtility<R, Arg>(pageFunction: js.Func1<[js.JSHandle<InjectedScript>, ElementHandle<T>, Arg], R>, arg: Arg): Promise<R | 'error:notconnected'>;\n    evaluateHandleInUtility<R, Arg>(pageFunction: js.Func1<[js.JSHandle<InjectedScript>, ElementHandle<T>, Arg], R>, arg: Arg): Promise<js.JSHandle<R> | 'error:notconnected'>;\n    ownerFrame(): Promise<frames.Frame | null>;\n    isIframeElement(): Promise<boolean | 'error:notconnected'>;\n    contentFrame(): Promise<frames.Frame | null>;\n    getAttribute(progress: Progress, name: string): Promise<string | null>;\n    inputValue(progress: Progress): Promise<string>;\n    textContent(progress: Progress): Promise<string | null>;\n    innerText(progress: Progress): Promise<string>;\n    innerHTML(progress: Progress): Promise<string>;\n    dispatchEvent(progress: Progress, type: string, eventInit?: Object): Promise<void>;\n    _scrollRectIntoViewIfNeeded(progress: Progress, rect?: types.Rect): Promise<'error:notvisible' | 'error:notconnected' | 'done'>;\n    _waitAndScrollIntoViewIfNeeded(progress: Progress, waitForVisible: boolean): Promise<void>;\n    scrollIntoViewIfNeeded(progress: Progress): Promise<void>;\n    private _clickablePoint;\n    private _offsetPoint;\n    _retryAction(progress: Progress, actionName: string, action: (retry: number) => Promise<PerformActionResult>, options: {\n        trial?: boolean;\n        force?: boolean;\n        skipActionPreChecks?: boolean;\n    }): Promise<'error:notconnected' | 'done'>;\n    _retryPointerAction(progress: Progress, actionName: ActionName, waitForEnabled: boolean, action: (point: types.Point) => Promise<void>, options: {\n        waitAfter: boolean | 'disabled';\n    } & types.PointerActionOptions & types.PointerActionWaitOptions): Promise<'error:notconnected' | 'done'>;\n    _performPointerAction(progress: Progress, actionName: ActionName, waitForEnabled: boolean, action: (point: types.Point) => Promise<void>, forceScrollOptions: ScrollIntoViewOptions | undefined, options: {\n        waitAfter: boolean | 'disabled';\n    } & types.PointerActionOptions & types.PointerActionWaitOptions): Promise<PerformActionResult>;\n    private _markAsTargetElement;\n    hover(progress: Progress, options: types.PointerActionOptions & types.PointerActionWaitOptions): Promise<void>;\n    _hover(progress: Progress, options: types.PointerActionOptions & types.PointerActionWaitOptions): Promise<'error:notconnected' | 'done'>;\n    click(progress: Progress, options: {\n        noWaitAfter?: boolean;\n    } & types.MouseClickOptions & types.PointerActionWaitOptions): Promise<void>;\n    _click(progress: Progress, options: {\n        waitAfter: boolean | 'disabled';\n    } & types.MouseClickOptions & types.PointerActionWaitOptions): Promise<'error:notconnected' | 'done'>;\n    dblclick(progress: Progress, options: types.MouseMultiClickOptions & types.PointerActionWaitOptions): Promise<void>;\n    _dblclick(progress: Progress, options: types.MouseMultiClickOptions & types.PointerActionWaitOptions): Promise<'error:notconnected' | 'done'>;\n    tap(progress: Progress, options: types.PointerActionWaitOptions): Promise<void>;\n    _tap(progress: Progress, options: types.PointerActionWaitOptions): Promise<'error:notconnected' | 'done'>;\n    selectOption(progress: Progress, elements: ElementHandle[], values: types.SelectOption[], options: types.CommonActionOptions): Promise<string[]>;\n    _selectOption(progress: Progress, elements: ElementHandle[], values: types.SelectOption[], options: types.CommonActionOptions): Promise<string[] | 'error:notconnected'>;\n    fill(progress: Progress, value: string, options: types.CommonActionOptions): Promise<void>;\n    _fill(progress: Progress, value: string, options: types.CommonActionOptions): Promise<'error:notconnected' | 'done'>;\n    selectText(progress: Progress, options: types.CommonActionOptions): Promise<void>;\n    setInputFiles(progress: Progress, params: Omit<channels.ElementHandleSetInputFilesParams, 'timeout'>): Promise<void>;\n    _setInputFiles(progress: Progress, items: InputFilesItems): Promise<'error:notconnected' | 'done'>;\n    focus(progress: Progress): Promise<void>;\n    _focus(progress: Progress, resetSelectionIfNotFocused?: boolean): Promise<'error:notconnected' | 'done'>;\n    _blur(progress: Progress): Promise<'error:notconnected' | 'done'>;\n    type(progress: Progress, text: string, options: {\n        delay?: number;\n    } & types.StrictOptions): Promise<void>;\n    _type(progress: Progress, text: string, options: {\n        delay?: number;\n    } & types.StrictOptions): Promise<'error:notconnected' | 'done'>;\n    press(progress: Progress, key: string, options: {\n        delay?: number;\n        noWaitAfter?: boolean;\n    } & types.StrictOptions): Promise<void>;\n    _press(progress: Progress, key: string, options: {\n        delay?: number;\n        noWaitAfter?: boolean;\n    } & types.StrictOptions): Promise<'error:notconnected' | 'done'>;\n    check(progress: Progress, options: {\n        position?: types.Point;\n    } & types.PointerActionWaitOptions): Promise<void>;\n    uncheck(progress: Progress, options: {\n        position?: types.Point;\n    } & types.PointerActionWaitOptions): Promise<void>;\n    _setChecked(progress: Progress, state: boolean, options: {\n        position?: types.Point;\n    } & types.PointerActionWaitOptions): Promise<'error:notconnected' | 'done'>;\n    boundingBox(): Promise<types.Rect | null>;\n    ariaSnapshot(): Promise<string>;\n    screenshot(progress: Progress, options: ScreenshotOptions): Promise<Buffer>;\n    querySelector(selector: string, options: types.StrictOptions): Promise<ElementHandle | null>;\n    querySelectorAll(selector: string): Promise<ElementHandle<Element>[]>;\n    evalOnSelector(selector: string, strict: boolean, expression: string, isFunction: boolean | undefined, arg: any): Promise<any>;\n    evalOnSelectorAll(selector: string, expression: string, isFunction: boolean | undefined, arg: any): Promise<any>;\n    isVisible(progress: Progress): Promise<boolean>;\n    isHidden(progress: Progress): Promise<boolean>;\n    isEnabled(progress: Progress): Promise<boolean>;\n    isDisabled(progress: Progress): Promise<boolean>;\n    isEditable(progress: Progress): Promise<boolean>;\n    isChecked(progress: Progress): Promise<boolean>;\n    waitForElementState(progress: Progress, state: 'visible' | 'hidden' | 'stable' | 'enabled' | 'disabled' | 'editable'): Promise<void>;\n    waitForSelector(progress: Progress, selector: string, options: types.WaitForElementOptions): Promise<ElementHandle<Element> | null>;\n    _adoptTo(context: FrameExecutionContext): Promise<ElementHandle<T>>;\n    _checkFrameIsHitTarget(point: types.Point): Promise<{\n        framePoint: types.Point | undefined;\n    } | 'error:notconnected' | {\n        hitTargetDescription: string;\n    }>;\n}\nexport declare function throwRetargetableDOMError<T>(result: T | 'error:notconnected'): T;\nexport declare function throwElementIsNotAttached(): never;\nexport declare function assertDone(result: 'done'): void;\nexport declare const kUnableToAdoptErrorMessage = \"Unable to adopt element handle from a different document\";\nexport {};\n//# sourceMappingURL=dom.d.ts.map",
      "server/download.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Page } from './page';\nimport { Artifact } from './artifact';\nexport declare class Download {\n    readonly artifact: Artifact;\n    readonly url: string;\n    private _page;\n    private _suggestedFilename;\n    constructor(page: Page, downloadsPath: string, uuid: string, url: string, suggestedFilename?: string);\n    page(): Page;\n    _filenameSuggested(suggestedFilename: string): void;\n    suggestedFilename(): string;\n    private _fireDownloadEvent;\n}\n//# sourceMappingURL=download.d.ts.map",
      "server/electron/electron.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ManualPromise } from '../../utils';\nimport { CRBrowser } from '../chromium/crBrowser';\nimport { CRConnection } from '../chromium/crConnection';\nimport { SdkObject } from '../instrumentation';\nimport * as js from '../javascript';\nimport type { BrowserContext } from '../browserContext';\nimport type { Protocol } from '../chromium/protocol';\nimport type { Page } from '../page';\nimport type { Playwright } from '../playwright';\nimport type { Progress } from '../progress';\nimport type * as channels from '@protocol/channels';\nimport type * as childProcess from 'child_process';\nimport type { BrowserWindow } from 'electron';\nexport declare class ElectronApplication extends SdkObject {\n    static Events: {\n        Close: string;\n        Console: string;\n    };\n    private _browserContext;\n    private _nodeConnection;\n    private _nodeSession;\n    private _nodeExecutionContext;\n    _nodeElectronHandlePromise: ManualPromise<js.JSHandle<typeof import('electron')>>;\n    private _process;\n    constructor(parent: SdkObject, browser: CRBrowser, nodeConnection: CRConnection, process: childProcess.ChildProcess);\n    _onConsoleAPI(event: Protocol.Runtime.consoleAPICalledPayload): Promise<void>;\n    initialize(): Promise<void>;\n    process(): childProcess.ChildProcess;\n    context(): BrowserContext;\n    close(): Promise<void>;\n    browserWindow(page: Page): Promise<js.JSHandle<BrowserWindow>>;\n}\nexport declare class Electron extends SdkObject {\n    constructor(playwright: Playwright);\n    launch(progress: Progress, options: Omit<channels.ElectronLaunchParams, 'timeout'>): Promise<ElectronApplication>;\n}\n//# sourceMappingURL=electron.d.ts.map",
      "server/electron/loader.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\ndeclare const app: any;\ndeclare const chromiumSwitches: any;\ndeclare const originalWhenReady: any;\ndeclare const originalEmit: any;\ndeclare let readyEventArgs: any[];\ndeclare let isReady: boolean;\ndeclare let whenReadyCallback: (event: any) => any;\ndeclare const whenReadyPromise: Promise<void>;\n//# sourceMappingURL=loader.d.ts.map",
      "server/errors.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { SerializedError } from '@protocol/channels';\ndeclare class CustomError extends Error {\n    constructor(message: string);\n}\nexport declare class TimeoutError extends CustomError {\n}\nexport declare class TargetClosedError extends CustomError {\n    constructor(cause?: string, logs?: string);\n}\nexport declare function isTargetClosedError(error: Error): boolean;\nexport declare function serializeError(e: any): SerializedError;\nexport declare function parseError(error: SerializedError): Error;\nexport {};\n//# sourceMappingURL=errors.d.ts.map",
      "server/eventEmitter.d.ts": "/**\n * Copyright Joyent, Inc. and other Node contributors.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Simplified EventEmitter for browser/server environments.\n * Based on Node.js EventEmitter but without platform dependencies.\n */\ntype EventType = string | symbol;\ntype Listener = (...args: any[]) => any;\nexport declare class EventEmitter {\n    private _events;\n    private _eventsCount;\n    private _maxListeners;\n    constructor();\n    setMaxListeners(n: number): this;\n    getMaxListeners(): number;\n    emit(type: EventType, ...args: any[]): boolean;\n    addListener(type: EventType, listener: Listener): this;\n    on(type: EventType, listener: Listener): this;\n    private _addListener;\n    prependListener(type: EventType, listener: Listener): this;\n    once(type: EventType, listener: Listener): this;\n    prependOnceListener(type: EventType, listener: Listener): this;\n    removeListener(type: EventType, listener: Listener): this;\n    off(type: EventType, listener: Listener): this;\n    removeAllListeners(type?: EventType): this;\n    listeners(type: EventType): Listener[];\n    rawListeners(type: EventType): Listener[];\n    listenerCount(type: EventType): number;\n    eventNames(): Array<string | symbol>;\n}\nexport {};\n//# sourceMappingURL=eventEmitter.d.ts.map",
      "server/eventsHelper.d.ts": "/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { EventEmitter } from './eventEmitter';\nexport type RegisteredListener = {\n    emitter: EventEmitter;\n    eventName: (string | symbol);\n    handler: (...args: any[]) => void;\n};\ndeclare class EventsHelper {\n    static addEventListener(emitter: EventEmitter, eventName: (string | symbol), handler: (...args: any[]) => void): RegisteredListener;\n    static removeEventListeners(listeners: Array<{\n        emitter: EventEmitter;\n        eventName: (string | symbol);\n        handler: (...args: any[]) => void;\n    }>): void;\n}\nexport declare const eventsHelper: typeof EventsHelper;\nexport {};\n//# sourceMappingURL=eventsHelper.d.ts.map",
      "server/fetch.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport http from 'http';\nimport { BrowserContext } from './browserContext';\nimport { SdkObject } from './instrumentation';\nimport { Tracing } from './trace/recorder/tracing';\nimport type { Playwright } from './playwright';\nimport type { Progress } from './progress';\nimport type * as types from './types';\nimport type { HeadersArray, ProxySettings } from './types';\nimport type { HTTPCredentials } from '../../types/types';\nimport type * as channels from '@protocol/channels';\nimport type * as har from '@trace/har';\ntype FetchRequestOptions = {\n    userAgent: string;\n    extraHTTPHeaders?: HeadersArray;\n    failOnStatusCode?: boolean;\n    httpCredentials?: HTTPCredentials;\n    proxy?: ProxySettings;\n    ignoreHTTPSErrors?: boolean;\n    maxRedirects?: number;\n    baseURL?: string;\n    clientCertificates?: types.BrowserContextOptions['clientCertificates'];\n};\ntype HeadersObject = Readonly<{\n    [name: string]: string;\n}>;\nexport type APIRequestEvent = {\n    url: URL;\n    method: string;\n    headers: HeadersObject;\n    cookies: channels.NameValue[];\n    postData?: Buffer;\n};\nexport type APIRequestFinishedEvent = {\n    requestEvent: APIRequestEvent;\n    httpVersion: string;\n    headers: http.IncomingHttpHeaders;\n    cookies: channels.NetworkCookie[];\n    rawHeaders: string[];\n    statusCode: number;\n    statusMessage: string;\n    body?: Buffer;\n    timings: har.Timings;\n    serverIPAddress?: string;\n    serverPort?: number;\n    securityDetails?: har.SecurityDetails;\n};\nexport declare abstract class APIRequestContext extends SdkObject {\n    static Events: {\n        Dispose: string;\n        Request: string;\n        RequestFinished: string;\n    };\n    readonly fetchResponses: Map<string, Buffer>;\n    readonly fetchLog: Map<string, string[]>;\n    protected static allInstances: Set<APIRequestContext>;\n    _closeReason: string | undefined;\n    static findResponseBody(guid: string): Buffer | undefined;\n    constructor(parent: SdkObject);\n    protected _disposeImpl(): void;\n    disposeResponse(fetchUid: string): void;\n    abstract tracing(): Tracing;\n    abstract dispose(options: {\n        reason?: string;\n    }): Promise<void>;\n    abstract _defaultOptions(): FetchRequestOptions;\n    abstract _addCookies(cookies: channels.NetworkCookie[]): Promise<void>;\n    abstract _cookies(url: URL): Promise<channels.NetworkCookie[]>;\n    abstract storageState(progress: Progress, indexedDB?: boolean): Promise<channels.APIRequestContextStorageStateResult>;\n    private _storeResponseBody;\n    fetch(progress: Progress, params: channels.APIRequestContextFetchParams): Promise<channels.APIResponse>;\n    private _parseSetCookieHeader;\n    private _updateRequestCookieHeader;\n    private _sendRequestWithRetries;\n    private _sendRequest;\n    private _getHttpCredentials;\n}\nexport declare class BrowserContextAPIRequestContext extends APIRequestContext {\n    private readonly _context;\n    constructor(context: BrowserContext);\n    tracing(): Tracing;\n    dispose(options: {\n        reason?: string;\n    }): Promise<void>;\n    _defaultOptions(): FetchRequestOptions;\n    _addCookies(cookies: channels.NetworkCookie[]): Promise<void>;\n    _cookies(url: URL): Promise<channels.NetworkCookie[]>;\n    storageState(progress: Progress, indexedDB?: boolean): Promise<channels.APIRequestContextStorageStateResult>;\n}\nexport declare class GlobalAPIRequestContext extends APIRequestContext {\n    private readonly _cookieStore;\n    private readonly _options;\n    private readonly _origins;\n    private readonly _tracing;\n    constructor(playwright: Playwright, options: channels.PlaywrightNewRequestOptions);\n    tracing(): Tracing;\n    dispose(options: {\n        reason?: string;\n    }): Promise<void>;\n    _defaultOptions(): FetchRequestOptions;\n    _addCookies(cookies: channels.NetworkCookie[]): Promise<void>;\n    _cookies(url: URL): Promise<channels.NetworkCookie[]>;\n    storageState(progress: Progress, indexedDB?: boolean): Promise<channels.APIRequestContextStorageStateResult>;\n}\nexport {};\n//# sourceMappingURL=fetch.d.ts.map",
      "server/fileChooser.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { ElementHandle } from './dom';\nimport type { Page } from './page';\nexport declare class FileChooser {\n    private _page;\n    private _elementHandle;\n    private _isMultiple;\n    constructor(page: Page, elementHandle: ElementHandle, isMultiple: boolean);\n    element(): ElementHandle;\n    isMultiple(): boolean;\n    page(): Page;\n}\n//# sourceMappingURL=fileChooser.d.ts.map",
      "server/fileUploadUtils.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { InputFilesItems } from './dom';\nimport type { Frame } from './frames';\nimport type * as channels from '@protocol/channels';\nexport declare const fileUploadSizeLimit: number;\nexport declare function prepareFilesForUpload(frame: Frame, params: Omit<channels.ElementHandleSetInputFilesParams, 'timeout'>): Promise<InputFilesItems>;\n//# sourceMappingURL=fileUploadUtils.d.ts.map",
      "server/firefox/ffBrowser.d.ts": "/**\n * Copyright 2018 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Browser } from '../browser';\nimport { BrowserContext } from '../browserContext';\nimport { FFConnection } from './ffConnection';\nimport { FFPage } from './ffPage';\nimport type { BrowserOptions } from '../browser';\nimport type { SdkObject } from '../instrumentation';\nimport type { InitScript, Page } from '../page';\nimport type { ConnectionTransport } from '../transport';\nimport type * as types from '../types';\nimport type { FFSession } from './ffConnection';\nimport type { Protocol } from './protocol';\nimport type * as channels from '@protocol/channels';\nexport declare class FFBrowser extends Browser {\n    private _connection;\n    readonly session: FFSession;\n    readonly _ffPages: Map<string, FFPage>;\n    readonly _contexts: Map<string, FFBrowserContext>;\n    private _version;\n    private _userAgent;\n    static connect(parent: SdkObject, transport: ConnectionTransport, options: BrowserOptions): Promise<FFBrowser>;\n    constructor(parent: SdkObject, connection: FFConnection, options: BrowserOptions);\n    _initVersion(): Promise<void>;\n    isConnected(): boolean;\n    doCreateNewContext(options: types.BrowserContextOptions): Promise<BrowserContext>;\n    contexts(): BrowserContext[];\n    version(): string;\n    userAgent(): string;\n    _onDetachedFromTarget(payload: Protocol.Browser.detachedFromTargetPayload): void;\n    _onAttachedToTarget(payload: Protocol.Browser.attachedToTargetPayload): void;\n    _onDownloadCreated(payload: Protocol.Browser.downloadCreatedPayload): void;\n    _onDownloadFinished(payload: Protocol.Browser.downloadFinishedPayload): void;\n    _onVideoRecordingFinished(payload: Protocol.Browser.videoRecordingFinishedPayload): void;\n    _onDisconnect(): void;\n}\nexport declare class FFBrowserContext extends BrowserContext {\n    readonly _browser: FFBrowser;\n    constructor(browser: FFBrowser, browserContextId: string | undefined, options: types.BrowserContextOptions);\n    _initialize(): Promise<void>;\n    _ffPages(): FFPage[];\n    possiblyUninitializedPages(): Page[];\n    doCreateNewPage(): Promise<Page>;\n    doGetCookies(urls: string[]): Promise<channels.NetworkCookie[]>;\n    addCookies(cookies: channels.SetNetworkCookie[]): Promise<void>;\n    doClearCookies(): Promise<void>;\n    doGrantPermissions(origin: string, permissions: string[]): Promise<void>;\n    doClearPermissions(): Promise<void>;\n    setGeolocation(geolocation?: types.Geolocation): Promise<void>;\n    doUpdateExtraHTTPHeaders(): Promise<void>;\n    setUserAgent(userAgent: string | undefined): Promise<void>;\n    doUpdateOffline(): Promise<void>;\n    doSetHTTPCredentials(httpCredentials?: types.Credentials): Promise<void>;\n    doAddInitScript(initScript: InitScript): Promise<void>;\n    doRemoveInitScripts(initScripts: InitScript[]): Promise<void>;\n    private _updateInitScripts;\n    doUpdateRequestInterception(): Promise<void>;\n    doUpdateDefaultViewport(): Promise<void>;\n    doUpdateDefaultEmulatedMedia(): Promise<void>;\n    doExposePlaywrightBinding(): Promise<void>;\n    onClosePersistent(): void;\n    clearCache(): Promise<void>;\n    doClose(reason: string | undefined): Promise<void>;\n    cancelDownload(uuid: string): Promise<void>;\n}\n//# sourceMappingURL=ffBrowser.d.ts.map",
      "server/firefox/ffConnection.d.ts": "/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { EventEmitter } from 'events';\nimport type { ConnectionTransport, ProtocolRequest, ProtocolResponse } from '../transport';\nimport type { Protocol } from './protocol';\nimport type { RecentLogsCollector } from '../utils/debugLogger';\nimport type { ProtocolLogger } from '../types';\nexport declare const ConnectionEvents: {\n    Disconnected: symbol;\n};\nexport declare const kBrowserCloseMessageId = -9999;\nexport declare class FFConnection extends EventEmitter {\n    private _lastId;\n    private _transport;\n    private readonly _protocolLogger;\n    private readonly _browserLogsCollector;\n    _browserDisconnectedLogs: string | undefined;\n    readonly rootSession: FFSession;\n    readonly _sessions: Map<string, FFSession>;\n    _closed: boolean;\n    constructor(transport: ConnectionTransport, protocolLogger: ProtocolLogger, browserLogsCollector: RecentLogsCollector);\n    nextMessageId(): number;\n    _rawSend(message: ProtocolRequest): void;\n    _onMessage(message: ProtocolResponse): Promise<void>;\n    _onClose(reason?: string): void;\n    close(): void;\n    createSession(sessionId: string): FFSession;\n}\nexport declare class FFSession extends EventEmitter {\n    _connection: FFConnection;\n    _disposed: boolean;\n    private _callbacks;\n    private _sessionId;\n    private _rawSend;\n    private _crashed;\n    on: <T extends keyof Protocol.Events | symbol>(event: T, listener: (payload: T extends symbol ? any : Protocol.Events[T extends keyof Protocol.Events ? T : never]) => void) => this;\n    addListener: <T extends keyof Protocol.Events | symbol>(event: T, listener: (payload: T extends symbol ? any : Protocol.Events[T extends keyof Protocol.Events ? T : never]) => void) => this;\n    off: <T extends keyof Protocol.Events | symbol>(event: T, listener: (payload: T extends symbol ? any : Protocol.Events[T extends keyof Protocol.Events ? T : never]) => void) => this;\n    removeListener: <T extends keyof Protocol.Events | symbol>(event: T, listener: (payload: T extends symbol ? any : Protocol.Events[T extends keyof Protocol.Events ? T : never]) => void) => this;\n    once: <T extends keyof Protocol.Events | symbol>(event: T, listener: (payload: T extends symbol ? any : Protocol.Events[T extends keyof Protocol.Events ? T : never]) => void) => this;\n    constructor(connection: FFConnection, sessionId: string, rawSend: (message: any) => void);\n    markAsCrashed(): void;\n    send<T extends keyof Protocol.CommandParameters>(method: T, params?: Protocol.CommandParameters[T]): Promise<Protocol.CommandReturnValues[T]>;\n    sendMayFail<T extends keyof Protocol.CommandParameters>(method: T, params?: Protocol.CommandParameters[T]): Promise<Protocol.CommandReturnValues[T] | void>;\n    dispatchMessage(object: ProtocolResponse): void;\n    dispose(): void;\n}\n//# sourceMappingURL=ffConnection.d.ts.map",
      "server/firefox/ffExecutionContext.d.ts": "/**\n * Copyright 2019 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as js from '../javascript';\nimport type { FFSession } from './ffConnection';\nimport type { Protocol } from './protocol';\nexport declare class FFExecutionContext implements js.ExecutionContextDelegate {\n    _session: FFSession;\n    _executionContextId: string;\n    constructor(session: FFSession, executionContextId: string);\n    rawEvaluateJSON(expression: string): Promise<any>;\n    rawEvaluateHandle(context: js.ExecutionContext, expression: string): Promise<js.JSHandle>;\n    evaluateWithArguments(expression: string, returnByValue: boolean, utilityScript: js.JSHandle, values: any[], handles: js.JSHandle[]): Promise<any>;\n    getProperties(object: js.JSHandle): Promise<Map<string, js.JSHandle>>;\n    releaseHandle(handle: js.JSHandle): Promise<void>;\n}\nexport declare function createHandle(context: js.ExecutionContext, remoteObject: Protocol.Runtime.RemoteObject): js.JSHandle;\n//# sourceMappingURL=ffExecutionContext.d.ts.map",
      "server/firefox/ffInput.d.ts": "/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type * as input from '../input';\nimport type { Page } from '../page';\nimport type { Progress } from '../progress';\nimport type * as types from '../types';\nimport type { FFSession } from './ffConnection';\nexport declare class RawKeyboardImpl implements input.RawKeyboard {\n    private _client;\n    constructor(client: FFSession);\n    keydown(progress: Progress, modifiers: Set<types.KeyboardModifier>, keyName: string, description: input.KeyDescription, autoRepeat: boolean): Promise<void>;\n    keyup(progress: Progress, modifiers: Set<types.KeyboardModifier>, keyName: string, description: input.KeyDescription): Promise<void>;\n    sendText(progress: Progress, text: string): Promise<void>;\n}\nexport declare class RawMouseImpl implements input.RawMouse {\n    private _client;\n    private _page?;\n    constructor(client: FFSession);\n    move(progress: Progress, x: number, y: number, button: types.MouseButton | 'none', buttons: Set<types.MouseButton>, modifiers: Set<types.KeyboardModifier>, forClick: boolean): Promise<void>;\n    down(progress: Progress, x: number, y: number, button: types.MouseButton, buttons: Set<types.MouseButton>, modifiers: Set<types.KeyboardModifier>, clickCount: number): Promise<void>;\n    up(progress: Progress, x: number, y: number, button: types.MouseButton, buttons: Set<types.MouseButton>, modifiers: Set<types.KeyboardModifier>, clickCount: number): Promise<void>;\n    wheel(progress: Progress, x: number, y: number, buttons: Set<types.MouseButton>, modifiers: Set<types.KeyboardModifier>, deltaX: number, deltaY: number): Promise<void>;\n    setPage(page: Page): void;\n}\nexport declare class RawTouchscreenImpl implements input.RawTouchscreen {\n    private _client;\n    constructor(client: FFSession);\n    tap(progress: Progress, x: number, y: number, modifiers: Set<types.KeyboardModifier>): Promise<void>;\n}\n//# sourceMappingURL=ffInput.d.ts.map",
      "server/firefox/ffNetworkManager.d.ts": "/**\n * Copyright 2019 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { FFSession } from './ffConnection';\nimport type { Page } from '../page';\nimport type { Protocol } from './protocol';\nexport declare class FFNetworkManager {\n    private _session;\n    private _requests;\n    private _page;\n    private _eventListeners;\n    constructor(session: FFSession, page: Page);\n    dispose(): void;\n    setRequestInterception(enabled: boolean): Promise<void>;\n    _onRequestWillBeSent(event: Protocol.Network.requestWillBeSentPayload): void;\n    _onResponseReceived(event: Protocol.Network.responseReceivedPayload): void;\n    _onRequestFinished(event: Protocol.Network.requestFinishedPayload): void;\n    _onRequestFailed(event: Protocol.Network.requestFailedPayload): void;\n}\n//# sourceMappingURL=ffNetworkManager.d.ts.map",
      "server/firefox/ffPage.d.ts": "/**\n * Copyright 2019 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as dom from '../dom';\nimport { InitScript } from '../page';\nimport { Page } from '../page';\nimport { FFSession } from './ffConnection';\nimport { RawKeyboardImpl, RawMouseImpl, RawTouchscreenImpl } from './ffInput';\nimport { FFNetworkManager } from './ffNetworkManager';\nimport type { Progress } from '../progress';\nimport type { FFBrowserContext } from './ffBrowser';\nimport type { Protocol } from './protocol';\nimport type * as frames from '../frames';\nimport type { PageDelegate } from '../page';\nimport type * as types from '../types';\nexport declare const UTILITY_WORLD_NAME = \"__playwright_utility_world__\";\nexport declare class FFPage implements PageDelegate {\n    readonly cspErrorsAsynchronousForInlineScripts = true;\n    readonly rawMouse: RawMouseImpl;\n    readonly rawKeyboard: RawKeyboardImpl;\n    readonly rawTouchscreen: RawTouchscreenImpl;\n    readonly _session: FFSession;\n    readonly _page: Page;\n    readonly _networkManager: FFNetworkManager;\n    readonly _browserContext: FFBrowserContext;\n    private _reportedAsNew;\n    readonly _opener: FFPage | null;\n    private readonly _contextIdToContext;\n    private _eventListeners;\n    private _workers;\n    private _screencastId;\n    private _initScripts;\n    constructor(session: FFSession, browserContext: FFBrowserContext, opener: FFPage | null);\n    _markAsError(error: Error): Promise<void>;\n    _onWebSocketCreated(event: Protocol.Page.webSocketCreatedPayload): void;\n    _onWebSocketClosed(event: Protocol.Page.webSocketClosedPayload): void;\n    _onWebSocketFrameReceived(event: Protocol.Page.webSocketFrameReceivedPayload): void;\n    _onWebSocketFrameSent(event: Protocol.Page.webSocketFrameSentPayload): void;\n    _onExecutionContextCreated(payload: Protocol.Runtime.executionContextCreatedPayload): void;\n    _onExecutionContextDestroyed(payload: Protocol.Runtime.executionContextDestroyedPayload): void;\n    _onExecutionContextsCleared(): void;\n    private _removeContextsForFrame;\n    _onLinkClicked(phase: 'before' | 'after'): void;\n    _onNavigationStarted(params: Protocol.Page.navigationStartedPayload): void;\n    _onNavigationAborted(params: Protocol.Page.navigationAbortedPayload): void;\n    _onNavigationCommitted(params: Protocol.Page.navigationCommittedPayload): void;\n    _onSameDocumentNavigation(params: Protocol.Page.sameDocumentNavigationPayload): void;\n    _onFrameAttached(params: Protocol.Page.frameAttachedPayload): void;\n    _onFrameDetached(params: Protocol.Page.frameDetachedPayload): void;\n    _onEventFired(payload: Protocol.Page.eventFiredPayload): void;\n    _onUncaughtError(params: Protocol.Page.uncaughtErrorPayload): void;\n    _onConsole(payload: Protocol.Runtime.consolePayload): void;\n    _onDialogOpened(params: Protocol.Page.dialogOpenedPayload): void;\n    _onBindingCalled(event: Protocol.Page.bindingCalledPayload): Promise<void>;\n    _onFileChooserOpened(payload: Protocol.Page.fileChooserOpenedPayload): Promise<void>;\n    _onWorkerCreated(event: Protocol.Page.workerCreatedPayload): Promise<void>;\n    _onWorkerDestroyed(event: Protocol.Page.workerDestroyedPayload): void;\n    _onDispatchMessageFromWorker(event: Protocol.Page.dispatchMessageFromWorkerPayload): Promise<void>;\n    _onCrashed(event: Protocol.Page.crashedPayload): Promise<void>;\n    _onVideoRecordingStarted(event: Protocol.Page.videoRecordingStartedPayload): void;\n    didClose(): void;\n    navigateFrame(frame: frames.Frame, url: string, referer: string | undefined): Promise<frames.GotoResult>;\n    updateExtraHTTPHeaders(): Promise<void>;\n    updateEmulatedViewportSize(): Promise<void>;\n    bringToFront(): Promise<void>;\n    updateEmulateMedia(): Promise<void>;\n    updateRequestInterception(): Promise<void>;\n    updateFileChooserInterception(): Promise<void>;\n    reload(): Promise<void>;\n    goBack(): Promise<boolean>;\n    goForward(): Promise<boolean>;\n    requestGC(): Promise<void>;\n    addInitScript(initScript: InitScript, worldName?: string): Promise<void>;\n    removeInitScripts(initScripts: InitScript[]): Promise<void>;\n    private _updateInitScripts;\n    closePage(runBeforeUnload: boolean): Promise<void>;\n    setBackgroundColor(color?: {\n        r: number;\n        g: number;\n        b: number;\n        a: number;\n    }): Promise<void>;\n    takeScreenshot(progress: Progress, format: 'png' | 'jpeg', documentRect: types.Rect | undefined, viewportRect: types.Rect | undefined, quality: number | undefined, fitsViewport: boolean, scale: 'css' | 'device'): Promise<Buffer>;\n    getContentFrame(handle: dom.ElementHandle): Promise<frames.Frame | null>;\n    getOwnerFrame(handle: dom.ElementHandle): Promise<string | null>;\n    getBoundingBox(handle: dom.ElementHandle): Promise<types.Rect | null>;\n    scrollRectIntoViewIfNeeded(handle: dom.ElementHandle, rect?: types.Rect): Promise<'error:notvisible' | 'error:notconnected' | 'done'>;\n    setScreencastOptions(options: {\n        width: number;\n        height: number;\n        quality: number;\n    } | null): Promise<void>;\n    private _onScreencastFrame;\n    rafCountForStablePosition(): number;\n    getContentQuads(handle: dom.ElementHandle): Promise<types.Quad[] | null>;\n    setInputFilePaths(handle: dom.ElementHandle<HTMLInputElement>, files: string[]): Promise<void>;\n    adoptElementHandle<T extends Node>(handle: dom.ElementHandle<T>, to: dom.FrameExecutionContext): Promise<dom.ElementHandle<T>>;\n    inputActionEpilogue(): Promise<void>;\n    resetForReuse(progress: Progress): Promise<void>;\n    getFrameElement(frame: frames.Frame): Promise<dom.ElementHandle>;\n    shouldToggleStyleSheetToSyncAnimations(): boolean;\n}\n//# sourceMappingURL=ffPage.d.ts.map",
      "server/firefox/firefox.d.ts": "/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { FFBrowser } from './ffBrowser';\nimport { BrowserType } from '../browserType';\nimport type { Browser, BrowserOptions } from '../browser';\nimport type { SdkObject } from '../instrumentation';\nimport type { ProtocolError } from '../protocolError';\nimport type { ConnectionTransport } from '../transport';\nimport type * as types from '../types';\nimport type { RecentLogsCollector } from '../utils/debugLogger';\nimport type { BrowserContext } from '../browserContext';\nimport type * as channels from '@protocol/channels';\nimport type { Progress } from '@protocol/progress';\nexport declare class Firefox extends BrowserType {\n    private _bidiFirefox;\n    constructor(parent: SdkObject, bidiFirefox: BrowserType);\n    launch(progress: Progress, options: types.LaunchOptions, protocolLogger?: types.ProtocolLogger): Promise<Browser>;\n    launchPersistentContext(progress: Progress, userDataDir: string, options: channels.BrowserTypeLaunchPersistentContextOptions & {\n        cdpPort?: number;\n        internalIgnoreHTTPSErrors?: boolean;\n        socksProxyPort?: number;\n    }): Promise<BrowserContext>;\n    connectToTransport(transport: ConnectionTransport, options: BrowserOptions): Promise<FFBrowser>;\n    doRewriteStartupLog(error: ProtocolError): ProtocolError;\n    amendEnvironment(env: NodeJS.ProcessEnv): NodeJS.ProcessEnv;\n    attemptToGracefullyCloseBrowser(transport: ConnectionTransport): void;\n    defaultArgs(options: types.LaunchOptions, isPersistent: boolean, userDataDir: string): Promise<string[]>;\n    waitForReadyState(options: types.LaunchOptions, browserLogsCollector: RecentLogsCollector): Promise<{\n        wsEndpoint?: string;\n    }>;\n}\n//# sourceMappingURL=firefox.d.ts.map",
      "server/formData.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type * as channels from '@protocol/channels';\nexport declare class MultipartFormData {\n    private readonly _boundary;\n    private readonly _chunks;\n    constructor();\n    contentTypeHeader(): string;\n    addField(name: string, value: string): void;\n    addFileField(name: string, value: NonNullable<channels.FormField['file']>): void;\n    finish(): Buffer;\n    private _beginMultiPartHeader;\n    private _finishMultiPartHeader;\n    private _finishMultiPartField;\n    private _addBoundary;\n}\n//# sourceMappingURL=formData.d.ts.map",
      "server/frameSelectors.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { ElementHandle } from './dom';\nimport type { Frame } from './frames';\nimport type { InjectedScript } from '@injected/injectedScript';\nimport type { JSHandle } from './javascript';\nimport type * as types from './types';\nimport type { ParsedSelector } from '../utils/isomorphic/selectorParser';\nexport type SelectorInfo = {\n    parsed: ParsedSelector;\n    world: types.World;\n    strict: boolean;\n};\nexport type SelectorInFrame = {\n    frame: Frame;\n    info: SelectorInfo;\n    scope?: ElementHandle;\n};\nexport declare class FrameSelectors {\n    readonly frame: Frame;\n    constructor(frame: Frame);\n    private _parseSelector;\n    query(selector: string, options?: types.StrictOptions & {\n        mainWorld?: boolean;\n    }, scope?: ElementHandle): Promise<ElementHandle<Element> | null>;\n    queryArrayInMainWorld(selector: string, scope?: ElementHandle): Promise<JSHandle<Element[]>>;\n    queryCount(selector: string, options: any): Promise<number>;\n    queryAll(selector: string, scope?: ElementHandle): Promise<ElementHandle<Element>[]>;\n    private _jumpToAriaRefFrameIfNeeded;\n    resolveFrameForSelector(selector: string, options?: types.StrictOptions, scope?: ElementHandle): Promise<SelectorInFrame | null>;\n    resolveInjectedForSelector(selector: string, options?: {\n        strict?: boolean;\n        mainWorld?: boolean;\n    }, scope?: ElementHandle): Promise<{\n        injected: JSHandle<InjectedScript>;\n        info: SelectorInfo;\n        frame: Frame;\n        scope?: ElementHandle;\n    } | undefined>;\n}\n//# sourceMappingURL=frameSelectors.d.ts.map",
      "server/frames.d.ts": "/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { BrowserContext } from './browserContext';\nimport * as dom from './dom';\nimport { FrameSelectors } from './frameSelectors';\nimport { SdkObject } from './instrumentation';\nimport * as js from './javascript';\nimport * as network from './network';\nimport { Page } from './page';\nimport * as types from './types';\nimport { LongStandingScope } from '../utils';\nimport type { ConsoleMessage } from './console';\nimport type { FrameExpectParams } from '@injected/injectedScript';\nimport type { Progress } from './progress';\nimport type { ScreenshotOptions } from './screenshotter';\nimport type { ParsedSelector } from '../utils/isomorphic/selectorParser';\nimport type * as channels from '@protocol/channels';\ntype DocumentInfo = {\n    documentId: string | undefined;\n    request: network.Request | undefined;\n};\nexport type GotoResult = {\n    newDocumentId?: string;\n};\ntype ConsoleTagHandler = () => void;\ntype RegularLifecycleEvent = Exclude<types.LifecycleEvent, 'networkidle'>;\nexport type FunctionWithSource = (source: {\n    context: BrowserContext;\n    page: Page;\n    frame: Frame;\n}, ...args: any) => any;\nexport type NavigationEvent = {\n    url: string;\n    name: string;\n    newDocument?: DocumentInfo;\n    error?: Error;\n    isPublic?: boolean;\n};\nexport declare class NavigationAbortedError extends Error {\n    readonly documentId?: string;\n    constructor(documentId: string | undefined, message: string);\n}\ntype ExpectResult = {\n    matches: boolean;\n    received?: any;\n    log?: string[];\n    timedOut?: boolean;\n    errorMessage?: string;\n};\nexport declare class FrameManager {\n    private _page;\n    private _frames;\n    private _mainFrame;\n    readonly _consoleMessageTags: Map<string, ConsoleTagHandler>;\n    readonly _signalBarriers: Set<SignalBarrier>;\n    private _webSockets;\n    private _nextFrameSeq;\n    constructor(page: Page);\n    nextFrameSeq(): number;\n    createDummyMainFrameIfNeeded(): void;\n    dispose(): void;\n    mainFrame(): Frame;\n    frames(): Frame[];\n    frame(frameId: string): Frame | null;\n    frameAttached(frameId: string, parentFrameId: string | null | undefined): Frame;\n    waitForSignalsCreatedBy<T>(progress: Progress, waitAfter: boolean, action: () => Promise<T>): Promise<T>;\n    frameWillPotentiallyRequestNavigation(): void;\n    frameDidPotentiallyRequestNavigation(): void;\n    frameRequestedNavigation(frameId: string, documentId?: string): void;\n    frameCommittedNewDocumentNavigation(frameId: string, url: string, name: string, documentId: string, initial: boolean): void;\n    frameCommittedSameDocumentNavigation(frameId: string, url: string): void;\n    frameAbortedNavigation(frameId: string, errorText: string, documentId?: string): void;\n    frameDetached(frameId: string): void;\n    frameLifecycleEvent(frameId: string, event: RegularLifecycleEvent): void;\n    requestStarted(request: network.Request, route?: network.RouteDelegate): void;\n    requestReceivedResponse(response: network.Response): void;\n    reportRequestFinished(request: network.Request, response: network.Response | null): void;\n    requestFailed(request: network.Request, canceled: boolean): void;\n    removeChildFramesRecursively(frame: Frame): void;\n    private _removeFramesRecursively;\n    private _inflightRequestFinished;\n    private _inflightRequestStarted;\n    interceptConsoleMessage(message: ConsoleMessage): boolean;\n    clearWebSockets(frame: Frame): void;\n    onWebSocketCreated(requestId: string, url: string): void;\n    onWebSocketRequest(requestId: string): void;\n    onWebSocketResponse(requestId: string, status: number, statusText: string): void;\n    onWebSocketFrameSent(requestId: string, opcode: number, data: string): void;\n    webSocketFrameReceived(requestId: string, opcode: number, data: string): void;\n    webSocketClosed(requestId: string): void;\n    webSocketError(requestId: string, errorMessage: string): void;\n    private _fireInternalFrameNavigation;\n}\nexport declare class Frame extends SdkObject {\n    static Events: {\n        InternalNavigation: string;\n        AddLifecycle: string;\n        RemoveLifecycle: string;\n    };\n    _id: string;\n    readonly seq: number;\n    _firedLifecycleEvents: Set<types.LifecycleEvent>;\n    private _firedNetworkIdleSelf;\n    _currentDocument: DocumentInfo;\n    private _pendingDocument;\n    readonly _page: Page;\n    private _parentFrame;\n    _url: string;\n    private _contextData;\n    private _childFrames;\n    _name: string;\n    _inflightRequests: Set<network.Request>;\n    private _networkIdleTimer;\n    private _setContentCounter;\n    readonly _detachedScope: LongStandingScope;\n    private _raceAgainstEvaluationStallingEventsPromises;\n    readonly _redirectedNavigations: Map<string, {\n        url: string;\n        gotoPromise: Promise<network.Response | null>;\n    }>;\n    readonly selectors: FrameSelectors;\n    constructor(page: Page, id: string, parentFrame: Frame | null);\n    isDetached(): boolean;\n    _onLifecycleEvent(event: RegularLifecycleEvent): void;\n    _onClearLifecycle(): void;\n    setPendingDocument(documentInfo: DocumentInfo | undefined): void;\n    pendingDocument(): DocumentInfo | undefined;\n    _invalidateNonStallingEvaluations(message: string): void;\n    raceAgainstEvaluationStallingEvents<T>(cb: () => Promise<T>): Promise<T>;\n    nonStallingRawEvaluateInExistingMainContext(expression: string): Promise<any>;\n    nonStallingEvaluateInExistingContext(expression: string, world: types.World): Promise<any>;\n    _recalculateNetworkIdle(frameThatAllowsRemovingNetworkIdle?: Frame): void;\n    raceNavigationAction(progress: Progress, action: () => Promise<network.Response | null>): Promise<network.Response | null>;\n    redirectNavigation(url: string, documentId: string, referer: string | undefined): void;\n    goto(progress: Progress, url: string, options?: types.GotoOptions): Promise<network.Response | null>;\n    gotoImpl(progress: Progress, url: string, options: types.GotoOptions): Promise<network.Response | null>;\n    _waitForNavigation(progress: Progress, requiresNewDocument: boolean, options: types.NavigateOptions): Promise<network.Response | null>;\n    _waitForLoadState(progress: Progress, state: types.LifecycleEvent): Promise<void>;\n    frameElement(): Promise<dom.ElementHandle>;\n    _context(world: types.World): Promise<dom.FrameExecutionContext>;\n    _mainContext(): Promise<dom.FrameExecutionContext>;\n    private _existingMainContext;\n    _utilityContext(): Promise<dom.FrameExecutionContext>;\n    evaluateExpression(expression: string, options?: {\n        isFunction?: boolean;\n        world?: types.World;\n    }, arg?: any): Promise<any>;\n    evaluateExpressionHandle(expression: string, options?: {\n        isFunction?: boolean;\n        world?: types.World;\n    }, arg?: any): Promise<js.JSHandle<any>>;\n    querySelector(selector: string, options: types.StrictOptions): Promise<dom.ElementHandle<Element> | null>;\n    waitForSelector(progress: Progress, selector: string, performActionPreChecksAndLog: boolean, options: types.WaitForElementOptions, scope?: dom.ElementHandle): Promise<dom.ElementHandle<Element> | null>;\n    dispatchEvent(progress: Progress, selector: string, type: string, eventInit: Object, options: types.QueryOnSelectorOptions, scope?: dom.ElementHandle): Promise<void>;\n    evalOnSelector(selector: string, strict: boolean, expression: string, isFunction: boolean | undefined, arg: any, scope?: dom.ElementHandle): Promise<any>;\n    evalOnSelectorAll(selector: string, expression: string, isFunction: boolean | undefined, arg: any, scope?: dom.ElementHandle): Promise<any>;\n    maskSelectors(selectors: ParsedSelector[], color: string): Promise<void>;\n    querySelectorAll(selector: string): Promise<dom.ElementHandle<Element>[]>;\n    queryCount(selector: string, options: any): Promise<number>;\n    content(): Promise<string>;\n    setContent(progress: Progress, html: string, options: types.NavigateOptions): Promise<void>;\n    name(): string;\n    url(): string;\n    origin(): string | undefined;\n    parentFrame(): Frame | null;\n    childFrames(): Frame[];\n    addScriptTag(params: {\n        url?: string;\n        content?: string;\n        type?: string;\n    }): Promise<dom.ElementHandle>;\n    addStyleTag(params: {\n        url?: string;\n        content?: string;\n    }): Promise<dom.ElementHandle>;\n    private _raceWithCSPError;\n    retryWithProgressAndTimeouts<R>(progress: Progress, timeouts: number[], action: (continuePolling: symbol) => Promise<R | symbol>): Promise<R>;\n    isNonRetriableError(e: Error): boolean;\n    private _retryWithProgressIfNotConnected;\n    rafrafTimeoutScreenshotElementWithProgress(progress: Progress, selector: string, timeout: number, options: ScreenshotOptions): Promise<Buffer>;\n    click(progress: Progress, selector: string, options: {\n        noWaitAfter?: boolean;\n    } & types.MouseClickOptions & types.PointerActionWaitOptions): Promise<void>;\n    dblclick(progress: Progress, selector: string, options: types.MouseMultiClickOptions & types.PointerActionWaitOptions): Promise<void>;\n    dragAndDrop(progress: Progress, source: string, target: string, options: types.DragActionOptions & types.PointerActionWaitOptions): Promise<void>;\n    tap(progress: Progress, selector: string, options: types.PointerActionWaitOptions): Promise<void>;\n    fill(progress: Progress, selector: string, value: string, options: types.StrictOptions & {\n        force?: boolean;\n    }): Promise<void>;\n    focus(progress: Progress, selector: string, options: types.StrictOptions): Promise<void>;\n    blur(progress: Progress, selector: string, options: types.StrictOptions): Promise<void>;\n    resolveSelector(progress: Progress, selector: string, options?: {\n        mainWorld?: boolean;\n    }): Promise<{\n        resolvedSelector: string;\n    }>;\n    textContent(progress: Progress, selector: string, options: types.QueryOnSelectorOptions, scope?: dom.ElementHandle): Promise<string | null>;\n    innerText(progress: Progress, selector: string, options: types.QueryOnSelectorOptions, scope?: dom.ElementHandle): Promise<string>;\n    innerHTML(progress: Progress, selector: string, options: types.QueryOnSelectorOptions, scope?: dom.ElementHandle): Promise<string>;\n    getAttribute(progress: Progress, selector: string, name: string, options: types.QueryOnSelectorOptions, scope?: dom.ElementHandle): Promise<string | null>;\n    inputValue(progress: Progress, selector: string, options: types.StrictOptions, scope?: dom.ElementHandle): Promise<string>;\n    highlight(progress: Progress, selector: string): Promise<any>;\n    hideHighlight(): Promise<any>;\n    private _elementState;\n    isVisible(progress: Progress, selector: string, options?: types.StrictOptions, scope?: dom.ElementHandle): Promise<boolean>;\n    isVisibleInternal(progress: Progress, selector: string, options?: types.StrictOptions, scope?: dom.ElementHandle): Promise<boolean>;\n    isHidden(progress: Progress, selector: string, options?: types.StrictOptions, scope?: dom.ElementHandle): Promise<boolean>;\n    isDisabled(progress: Progress, selector: string, options: types.QueryOnSelectorOptions, scope?: dom.ElementHandle): Promise<boolean>;\n    isEnabled(progress: Progress, selector: string, options: types.QueryOnSelectorOptions, scope?: dom.ElementHandle): Promise<boolean>;\n    isEditable(progress: Progress, selector: string, options: types.QueryOnSelectorOptions, scope?: dom.ElementHandle): Promise<boolean>;\n    isChecked(progress: Progress, selector: string, options: types.QueryOnSelectorOptions, scope?: dom.ElementHandle): Promise<boolean>;\n    hover(progress: Progress, selector: string, options: types.PointerActionOptions & types.PointerActionWaitOptions): Promise<void>;\n    selectOption(progress: Progress, selector: string, elements: dom.ElementHandle[], values: types.SelectOption[], options: types.CommonActionOptions): Promise<string[]>;\n    setInputFiles(progress: Progress, selector: string, params: Omit<channels.FrameSetInputFilesParams, 'timeout'>): Promise<channels.FrameSetInputFilesResult>;\n    type(progress: Progress, selector: string, text: string, options: {\n        delay?: number;\n    } & types.StrictOptions): Promise<void>;\n    press(progress: Progress, selector: string, key: string, options: {\n        delay?: number;\n        noWaitAfter?: boolean;\n    } & types.StrictOptions): Promise<void>;\n    check(progress: Progress, selector: string, options: types.PointerActionWaitOptions): Promise<void>;\n    uncheck(progress: Progress, selector: string, options: types.PointerActionWaitOptions): Promise<void>;\n    waitForTimeout(progress: Progress, timeout: number): Promise<any>;\n    ariaSnapshot(progress: Progress, selector: string): Promise<string>;\n    expect(progress: Progress, selector: string | undefined, options: FrameExpectParams, timeout?: number): Promise<ExpectResult>;\n    private _expectInternal;\n    waitForFunctionExpression<R>(progress: Progress, expression: string, isFunction: boolean | undefined, arg: any, options: {\n        pollingInterval?: number;\n    }, world?: types.World): Promise<js.SmartHandle<R>>;\n    waitForFunctionValueInUtility<R>(progress: Progress, pageFunction: js.Func1<any, R>): Promise<R>;\n    title(): Promise<string>;\n    rafrafTimeout(progress: Progress, timeout: number): Promise<void>;\n    _onDetached(): void;\n    private _callOnElementOnceMatches;\n    private _setContext;\n    _contextCreated(world: types.World, context: dom.FrameExecutionContext): void;\n    _contextDestroyed(context: dom.FrameExecutionContext): void;\n    _startNetworkIdleTimer(): void;\n    _stopNetworkIdleTimer(): void;\n    extendInjectedScript(source: string, arg?: any): Promise<void>;\n    private _asLocator;\n}\ndeclare class SignalBarrier {\n    private _progress;\n    private _protectCount;\n    private _promise;\n    constructor(progress: Progress);\n    waitFor(): PromiseLike<void>;\n    addFrameNavigation(frame: Frame): void;\n    retain(): void;\n    release(): void;\n}\nexport {};\n//# sourceMappingURL=frames.d.ts.map",
      "server/har/harRecorder.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Artifact } from '../artifact';\nimport type { BrowserContext } from '../browserContext';\nimport type { HarTracerDelegate } from './harTracer';\nimport type { Page } from '../page';\nimport type * as channels from '@protocol/channels';\nimport type * as har from '@trace/har';\nexport declare class HarRecorder implements HarTracerDelegate {\n    private _artifact;\n    private _isFlushed;\n    private _tracer;\n    private _entries;\n    private _zipFile;\n    private _writtenZipEntries;\n    constructor(context: BrowserContext, page: Page | null, options: channels.RecordHarOptions);\n    onEntryStarted(entry: har.Entry): void;\n    onEntryFinished(entry: har.Entry): void;\n    onContentBlob(sha1: string, buffer: Buffer): void;\n    flush(): Promise<void>;\n    export(): Promise<Artifact>;\n}\n//# sourceMappingURL=harRecorder.d.ts.map",
      "server/har/harTracer.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { BrowserContext } from '../browserContext';\nimport { APIRequestContext } from '../fetch';\nimport type { Page } from '../page';\nimport type * as har from '@trace/har';\nexport interface HarTracerDelegate {\n    onEntryStarted(entry: har.Entry): void;\n    onEntryFinished(entry: har.Entry): void;\n    onContentBlob(sha1: string, buffer: Buffer): void;\n}\ntype HarTracerOptions = {\n    content: 'omit' | 'attach' | 'embed';\n    includeTraceInfo: boolean;\n    recordRequestOverrides: boolean;\n    waitForContentOnStop: boolean;\n    urlFilter?: string | RegExp;\n    slimMode?: boolean;\n    omitSecurityDetails?: boolean;\n    omitCookies?: boolean;\n    omitTiming?: boolean;\n    omitServerIP?: boolean;\n    omitPages?: boolean;\n    omitSizes?: boolean;\n    omitScripts?: boolean;\n};\nexport declare class HarTracer {\n    private _context;\n    private _barrierPromises;\n    private _delegate;\n    private _options;\n    private _pageEntries;\n    private _eventListeners;\n    private _started;\n    private _entrySymbol;\n    private _baseURL;\n    private _page;\n    constructor(context: BrowserContext | APIRequestContext, page: Page | null, delegate: HarTracerDelegate, options: HarTracerOptions);\n    start(options: {\n        omitScripts: boolean;\n    }): void;\n    private _shouldIncludeEntryWithUrl;\n    private _entryForRequest;\n    private _createPageEntryIfNeeded;\n    private _onDOMContentLoaded;\n    private _onLoad;\n    private _addBarrier;\n    private _onAPIRequest;\n    private _onAPIRequestFinished;\n    private _onRequest;\n    private _recordRequestHeadersAndCookies;\n    private _recordRequestOverrides;\n    private _onRequestFinished;\n    private _onRequestFailed;\n    private _onRequestAborted;\n    private _onRequestFulfilled;\n    private _onRequestContinued;\n    private _storeResponseContent;\n    private _onResponse;\n    private _recordResponseHeaders;\n    private _computeHarEntryTotalTime;\n    flush(): Promise<void>;\n    stop(): har.Log;\n    private _postDataForRequest;\n    private _postDataForBuffer;\n}\nexport {};\n//# sourceMappingURL=harTracer.d.ts.map",
      "server/harBackend.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ZipFile } from './utils/zipFile';\nimport type { HeadersArray } from '../utils/isomorphic/types';\nimport type * as har from '@trace/har';\nexport declare class HarBackend {\n    readonly id: string;\n    private _harFile;\n    private _zipFile;\n    private _baseDir;\n    constructor(harFile: har.HARFile, baseDir: string | null, zipFile: ZipFile | null);\n    lookup(url: string, method: string, headers: HeadersArray, postData: Buffer | undefined, isNavigationRequest: boolean): Promise<{\n        action: 'error' | 'redirect' | 'fulfill' | 'noentry';\n        message?: string;\n        redirectURL?: string;\n        status?: number;\n        headers?: HeadersArray;\n        body?: Buffer;\n    }>;\n    private _loadContent;\n    private _harFindResponse;\n    dispose(): void;\n}\n//# sourceMappingURL=harBackend.d.ts.map",
      "server/helper.d.ts": "/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { Progress } from './progress';\nimport type * as types from './types';\nimport type { EventEmitter } from 'events';\ndeclare class Helper {\n    static completeUserURL(urlString: string): string;\n    static enclosingIntRect(rect: types.Rect): types.Rect;\n    static enclosingIntSize(size: types.Size): types.Size;\n    static getViewportSizeFromWindowFeatures(features: string[]): types.Size | null;\n    static waitForEvent(progress: Progress, emitter: EventEmitter, event: string | symbol, predicate?: Function): {\n        promise: Promise<any>;\n        dispose: () => void;\n    };\n    static secondsToRoundishMillis(value: number): number;\n    static millisToRoundishMillis(value: number): number;\n    static debugProtocolLogger(protocolLogger?: types.ProtocolLogger): types.ProtocolLogger;\n    static formatBrowserLogs(logs: string[], disconnectReason?: string): string;\n}\nexport declare const helper: typeof Helper;\nexport {};\n//# sourceMappingURL=helper.d.ts.map",
      "server/index.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport type { BrowserInfo, Executable } from './registry';\nexport { Registry, installBrowsersForNpmInstall, registry, registryDirectory, writeDockerVersion } from './registry';\nexport { DispatcherConnection, RootDispatcher } from './dispatchers/dispatcher';\nexport { PlaywrightDispatcher } from './dispatchers/playwrightDispatcher';\nexport { createPlaywright } from './playwright';\nexport type { DispatcherScope } from './dispatchers/dispatcher';\nexport type { Playwright } from './playwright';\nexport { installRootRedirect, openTraceInBrowser, openTraceViewerApp, runTraceViewerApp, startTraceViewerServer } from './trace/viewer/traceViewer';\n//# sourceMappingURL=index.d.ts.map",
      "server/input.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { Progress } from './progress';\nimport type { Page } from './page';\nimport type * as types from './types';\nexport declare const keypadLocation = 3;\nexport type KeyDescription = {\n    keyCode: number;\n    keyCodeWithoutLocation: number;\n    key: string;\n    text: string;\n    code: string;\n    location: number;\n    shifted?: KeyDescription;\n};\nexport interface RawKeyboard {\n    keydown(progress: Progress, modifiers: Set<types.KeyboardModifier>, keyName: string, description: KeyDescription, autoRepeat: boolean): Promise<void>;\n    keyup(progress: Progress, modifiers: Set<types.KeyboardModifier>, keyName: string, description: KeyDescription): Promise<void>;\n    sendText(progress: Progress, text: string): Promise<void>;\n}\nexport declare class Keyboard {\n    private _pressedModifiers;\n    private _pressedKeys;\n    private _raw;\n    private _page;\n    constructor(raw: RawKeyboard, page: Page);\n    down(progress: Progress, key: string): Promise<void>;\n    private _keyDescriptionForString;\n    up(progress: Progress, key: string): Promise<void>;\n    insertText(progress: Progress, text: string): Promise<void>;\n    type(progress: Progress, text: string, options?: {\n        delay?: number;\n    }): Promise<void>;\n    press(progress: Progress, key: string, options?: {\n        delay?: number;\n    }): Promise<void>;\n    ensureModifiers(progress: Progress, mm: types.SmartKeyboardModifier[]): Promise<types.KeyboardModifier[]>;\n    _modifiers(): Set<types.KeyboardModifier>;\n}\nexport declare function resolveSmartModifierString(key: string): string;\nexport declare function resolveSmartModifier(m: types.SmartKeyboardModifier): types.KeyboardModifier;\nexport interface RawMouse {\n    move(progress: Progress, x: number, y: number, button: types.MouseButton | 'none', buttons: Set<types.MouseButton>, modifiers: Set<types.KeyboardModifier>, forClick: boolean): Promise<void>;\n    down(progress: Progress, x: number, y: number, button: types.MouseButton, buttons: Set<types.MouseButton>, modifiers: Set<types.KeyboardModifier>, clickCount: number): Promise<void>;\n    up(progress: Progress, x: number, y: number, button: types.MouseButton, buttons: Set<types.MouseButton>, modifiers: Set<types.KeyboardModifier>, clickCount: number): Promise<void>;\n    wheel(progress: Progress, x: number, y: number, buttons: Set<types.MouseButton>, modifiers: Set<types.KeyboardModifier>, deltaX: number, deltaY: number): Promise<void>;\n}\nexport declare class Mouse {\n    private _keyboard;\n    private _x;\n    private _y;\n    private _lastButton;\n    private _buttons;\n    private _raw;\n    private _page;\n    constructor(raw: RawMouse, page: Page);\n    currentPoint(): {\n        x: number;\n        y: number;\n    };\n    move(progress: Progress, x: number, y: number, options?: {\n        steps?: number;\n        forClick?: boolean;\n    }): Promise<void>;\n    down(progress: Progress, options?: {\n        button?: types.MouseButton;\n        clickCount?: number;\n    }): Promise<void>;\n    up(progress: Progress, options?: {\n        button?: types.MouseButton;\n        clickCount?: number;\n    }): Promise<void>;\n    click(progress: Progress, x: number, y: number, options?: {\n        delay?: number;\n        button?: types.MouseButton;\n        clickCount?: number;\n        steps?: number;\n    }): Promise<void>;\n    wheel(progress: Progress, deltaX: number, deltaY: number): Promise<void>;\n}\nexport interface RawTouchscreen {\n    tap(progress: Progress, x: number, y: number, modifiers: Set<types.KeyboardModifier>): Promise<void>;\n}\nexport declare class Touchscreen {\n    private _raw;\n    private _page;\n    constructor(raw: RawTouchscreen, page: Page);\n    tap(progress: Progress, x: number, y: number): Promise<void>;\n}\n//# sourceMappingURL=input.d.ts.map",
      "server/instrumentation.d.ts": "/**\n * Copyright (c) Microsoft Corporation. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { Browser } from './browser';\nimport type { BrowserContext } from './browserContext';\nimport type { BrowserType } from './browserType';\nimport type { Dialog } from './dialog';\nimport type { Download } from './download';\nimport type { APIRequestContext } from './fetch';\nimport type { Frame } from './frames';\nimport type { Page } from './page';\nimport type { Playwright } from './playwright';\nimport type { CallMetadata } from '@protocol/callMetadata';\nexport type { CallMetadata } from '@protocol/callMetadata';\nimport type { LogName } from './utils/debugLogger';\nexport type Attribution = {\n    playwright: Playwright;\n    browserType?: BrowserType;\n    browser?: Browser;\n    context?: BrowserContext | APIRequestContext;\n    page?: Page;\n    frame?: Frame;\n};\ntype Listener = (...args: any[]) => void;\ndeclare class BasicEventEmitter {\n    private _listeners;\n    private _maxListeners;\n    on(event: string | symbol, listener: Listener): this;\n    addListener(event: string | symbol, listener: Listener): this;\n    once(event: string | symbol, listener: Listener): this;\n    off(event: string | symbol, listener: Listener): this;\n    removeListener(event: string | symbol, listener: Listener): this;\n    removeAllListeners(event?: string | symbol): this;\n    emit(event: string | symbol, ...args: any[]): boolean;\n    setMaxListeners(n: number): this;\n    listenerCount(event: string | symbol): number;\n}\nexport declare class SdkObject extends BasicEventEmitter {\n    guid: string;\n    attribution: Attribution;\n    instrumentation: Instrumentation;\n    logName?: LogName;\n    constructor(parent: SdkObject, guidPrefix?: string, guid?: string);\n}\nexport declare function createRootSdkObject(): SdkObject;\nexport interface Instrumentation {\n    addListener(listener: InstrumentationListener, context: BrowserContext | APIRequestContext | null): void;\n    removeListener(listener: InstrumentationListener): void;\n    onBeforeCall(sdkObject: SdkObject, metadata: CallMetadata): Promise<void>;\n    onBeforeInputAction(sdkObject: SdkObject, metadata: CallMetadata): Promise<void>;\n    onCallLog(sdkObject: SdkObject, metadata: CallMetadata, logName: string, message: string): void;\n    onAfterCall(sdkObject: SdkObject, metadata: CallMetadata): Promise<void>;\n    onPageOpen(page: Page): void;\n    onPageClose(page: Page): void;\n    onBrowserOpen(browser: Browser): void;\n    onBrowserClose(browser: Browser): void;\n    onDialog(dialog: Dialog): void;\n    onDownload(page: Page, download: Download): void;\n}\nexport interface InstrumentationListener {\n    onBeforeCall?(sdkObject: SdkObject, metadata: CallMetadata): Promise<void>;\n    onBeforeInputAction?(sdkObject: SdkObject, metadata: CallMetadata): Promise<void>;\n    onCallLog?(sdkObject: SdkObject, metadata: CallMetadata, logName: string, message: string): void;\n    onAfterCall?(sdkObject: SdkObject, metadata: CallMetadata): Promise<void>;\n    onPageOpen?(page: Page): void;\n    onPageClose?(page: Page): void;\n    onBrowserOpen?(browser: Browser): void;\n    onBrowserClose?(browser: Browser): void;\n    onDialog?(dialog: Dialog): void;\n    onDownload?(page: Page, download: Download): void;\n}\nexport declare function createInstrumentation(): Instrumentation;\n//# sourceMappingURL=instrumentation.d.ts.map",
      "server/javascript.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SdkObject } from './instrumentation';\nimport type * as dom from './dom';\nimport type { UtilityScript } from '@injected/utilityScript';\ninterface TaggedAsJSHandle<T> {\n    __jshandle: T;\n}\ninterface TaggedAsElementHandle<T> {\n    __elementhandle: T;\n}\ntype NoHandles<Arg> = Arg extends TaggedAsJSHandle<any> ? never : (Arg extends object ? {\n    [Key in keyof Arg]: NoHandles<Arg[Key]>;\n} : Arg);\ntype Unboxed<Arg> = Arg extends TaggedAsElementHandle<infer T> ? T : Arg extends TaggedAsJSHandle<infer T> ? T : Arg extends NoHandles<Arg> ? Arg : Arg extends [infer A0] ? [Unboxed<A0>] : Arg extends [infer A0, infer A1] ? [Unboxed<A0>, Unboxed<A1>] : Arg extends [infer A0, infer A1, infer A2] ? [Unboxed<A0>, Unboxed<A1>, Unboxed<A2>] : Arg extends Array<infer T> ? Array<Unboxed<T>> : Arg extends object ? {\n    [Key in keyof Arg]: Unboxed<Arg[Key]>;\n} : Arg;\nexport type Func0<R> = string | (() => R | Promise<R>);\nexport type Func1<Arg, R> = string | ((arg: Unboxed<Arg>) => R | Promise<R>);\nexport type FuncOn<On, Arg2, R> = string | ((on: On, arg2: Unboxed<Arg2>) => R | Promise<R>);\nexport type SmartHandle<T> = T extends Node ? dom.ElementHandle<T> : JSHandle<T>;\nexport interface ExecutionContextDelegate {\n    rawEvaluateJSON(expression: string): Promise<any>;\n    rawEvaluateHandle(context: ExecutionContext, expression: string): Promise<JSHandle>;\n    evaluateWithArguments(expression: string, returnByValue: boolean, utilityScript: JSHandle, values: any[], handles: JSHandle[]): Promise<any>;\n    getProperties(object: JSHandle): Promise<Map<string, JSHandle>>;\n    releaseHandle(handle: JSHandle): Promise<void>;\n}\nexport declare class ExecutionContext extends SdkObject {\n    readonly delegate: ExecutionContextDelegate;\n    private _utilityScriptPromise;\n    private _contextDestroyedScope;\n    readonly worldNameForTest: string;\n    constructor(parent: SdkObject, delegate: ExecutionContextDelegate, worldNameForTest: string);\n    contextDestroyed(reason: string): void;\n    _raceAgainstContextDestroyed<T>(promise: Promise<T>): Promise<T>;\n    rawEvaluateJSON(expression: string): Promise<any>;\n    rawEvaluateHandle(expression: string): Promise<JSHandle>;\n    evaluateWithArguments(expression: string, returnByValue: boolean, values: any[], handles: JSHandle[]): Promise<any>;\n    getProperties(object: JSHandle): Promise<Map<string, JSHandle>>;\n    releaseHandle(handle: JSHandle): Promise<void>;\n    adoptIfNeeded(handle: JSHandle): Promise<JSHandle> | null;\n    utilityScript(): Promise<JSHandle<UtilityScript>>;\n    doSlowMo(): Promise<void>;\n}\nexport declare class JSHandle<T = any> extends SdkObject {\n    __jshandle: T;\n    readonly _context: ExecutionContext;\n    _disposed: boolean;\n    readonly _objectId: string | undefined;\n    readonly _value: any;\n    private _objectType;\n    protected _preview: string;\n    private _previewCallback;\n    constructor(context: ExecutionContext, type: string, preview: string | undefined, objectId?: string, value?: any);\n    evaluate<R, Arg>(pageFunction: FuncOn<T, Arg, R>, arg?: Arg): Promise<R>;\n    evaluateHandle<R, Arg>(pageFunction: FuncOn<T, Arg, R>, arg?: Arg): Promise<SmartHandle<R>>;\n    evaluateExpression(expression: string, options: {\n        isFunction?: boolean;\n    }, arg: any): Promise<any>;\n    evaluateExpressionHandle(expression: string, options: {\n        isFunction?: boolean;\n    }, arg: any): Promise<JSHandle<any>>;\n    getProperty(propertyName: string): Promise<JSHandle>;\n    getProperties(): Promise<Map<string, JSHandle>>;\n    rawValue(): any;\n    jsonValue(): Promise<T>;\n    asElement(): dom.ElementHandle | null;\n    dispose(): void;\n    toString(): string;\n    _setPreviewCallback(callback: (preview: string) => void): void;\n    preview(): string;\n    worldNameForTest(): string;\n    _setPreview(preview: string): void;\n}\nexport declare function evaluate(context: ExecutionContext, returnByValue: boolean, pageFunction: Function | string, ...args: any[]): Promise<any>;\nexport declare function evaluateExpression(context: ExecutionContext, expression: string, options: {\n    returnByValue?: boolean;\n    isFunction?: boolean;\n}, ...args: any[]): Promise<any>;\nexport declare function parseUnserializableValue(unserializableValue: string): any;\nexport declare function normalizeEvaluationExpression(expression: string, isFunction: boolean | undefined): string;\nexport declare class JavaScriptErrorInEvaluate extends Error {\n}\nexport declare function isJavaScriptErrorInEvaluate(error: Error): error is JavaScriptErrorInEvaluate;\nexport declare function sparseArrayToString(entries: {\n    name: string;\n    value?: any;\n}[]): string;\nexport {};\n//# sourceMappingURL=javascript.d.ts.map",
      "server/launchApp.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { BrowserType } from './browserType';\nimport type { Page } from './page';\nimport type * as types from './types';\nexport declare function launchApp(browserType: BrowserType, options: {\n    sdkLanguage: string;\n    windowSize: types.Size;\n    windowPosition?: types.Point;\n    persistentContextOptions?: Parameters<BrowserType['launchPersistentContext']>[2];\n}): Promise<{\n    context: any;\n    page: any;\n}>;\nexport declare function syncLocalStorageWithSettings(page: Page, appName: string): Promise<void>;\n//# sourceMappingURL=launchApp.d.ts.map",
      "server/localUtils.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { HarBackend } from './harBackend';\nimport type * as channels from '@protocol/channels';\nimport type { Progress } from '@protocol/progress';\nexport type StackSession = {\n    file: string;\n    writer: Promise<void>;\n    tmpDir: string | undefined;\n    callStacks: channels.ClientSideCallMetadata[];\n    live?: boolean;\n};\nexport declare function zip(progress: Progress, stackSessions: Map<string, StackSession>, params: channels.LocalUtilsZipParams): Promise<void>;\nexport declare function harOpen(progress: Progress, harBackends: Map<string, HarBackend>, params: channels.LocalUtilsHarOpenParams): Promise<channels.LocalUtilsHarOpenResult>;\nexport declare function harLookup(progress: Progress, harBackends: Map<string, HarBackend>, params: channels.LocalUtilsHarLookupParams): Promise<channels.LocalUtilsHarLookupResult>;\nexport declare function harClose(harBackends: Map<string, HarBackend>, params: channels.LocalUtilsHarCloseParams): void;\nexport declare function harUnzip(progress: Progress, params: channels.LocalUtilsHarUnzipParams): Promise<void>;\nexport declare function tracingStarted(progress: Progress, stackSessions: Map<string, StackSession>, params: channels.LocalUtilsTracingStartedParams): Promise<channels.LocalUtilsTracingStartedResult>;\nexport declare function traceDiscarded(progress: Progress, stackSessions: Map<string, StackSession>, params: channels.LocalUtilsTraceDiscardedParams): Promise<void>;\nexport declare function addStackToTracingNoReply(stackSessions: Map<string, StackSession>, params: channels.LocalUtilsAddStackToTracingNoReplyParams): void;\n//# sourceMappingURL=localUtils.d.ts.map",
      "server/macEditingCommands.d.ts": "/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport declare const macEditingCommands: {\n    [key: string]: string | string[];\n};\n//# sourceMappingURL=macEditingCommands.d.ts.map",
      "server/network.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SdkObject } from './instrumentation';\nimport { ManualPromise } from '../utils/isomorphic/manualPromise';\nimport type * as contexts from './browserContext';\nimport type * as frames from './frames';\nimport type * as pages from './page';\nimport type * as types from './types';\nimport type { HeadersArray, NameValue } from '../utils/isomorphic/types';\nimport type * as channels from '@protocol/channels';\nexport declare function filterCookies(cookies: channels.NetworkCookie[], urls: string[]): channels.NetworkCookie[];\nexport declare function isLocalHostname(hostname: string): boolean;\nexport declare const kMaxCookieExpiresDateInSeconds = 253402300799;\nexport declare function rewriteCookies(cookies: channels.SetNetworkCookie[]): channels.SetNetworkCookie[];\nexport declare function parseURL(url: string): URL | null;\nexport declare function stripFragmentFromUrl(url: string): string;\nexport declare class Request extends SdkObject {\n    private _response;\n    private _redirectedFrom;\n    _redirectedTo: Request | null;\n    readonly _documentId?: string;\n    readonly _isFavicon: boolean;\n    _failureText: string | null;\n    private _url;\n    private _resourceType;\n    private _method;\n    private _postData;\n    readonly _headers: HeadersArray;\n    private _headersMap;\n    readonly _frame: frames.Frame | null;\n    readonly _serviceWorker: pages.Worker | null;\n    readonly _context: contexts.BrowserContext;\n    private _rawRequestHeadersPromise;\n    private _waitForResponsePromise;\n    _responseEndTiming: number;\n    private _overrides;\n    private _bodySize;\n    _responseBodyOverride: {\n        body: string;\n        isBase64: boolean;\n    } | undefined;\n    static Events: {\n        Response: string;\n    };\n    constructor(context: contexts.BrowserContext, frame: frames.Frame | null, serviceWorker: pages.Worker | null, redirectedFrom: Request | null, documentId: string | undefined, url: string, resourceType: string, method: string, postData: Buffer | null, headers: HeadersArray);\n    _setFailureText(failureText: string): void;\n    _applyOverrides(overrides: types.NormalizedContinueOverrides): types.NormalizedContinueOverrides;\n    private _updateHeadersMap;\n    overrides(): types.NormalizedContinueOverrides;\n    url(): string;\n    resourceType(): string;\n    method(): string;\n    postDataBuffer(): Buffer | null;\n    headers(): HeadersArray;\n    headerValue(name: string): string | undefined;\n    setRawRequestHeaders(headers: HeadersArray | null): void;\n    rawRequestHeaders(): Promise<HeadersArray>;\n    response(): Promise<Response | null>;\n    _existingResponse(): Response | null;\n    _setResponse(response: Response): void;\n    _finalRequest(): Request;\n    frame(): frames.Frame | null;\n    serviceWorker(): pages.Worker | null;\n    isNavigationRequest(): boolean;\n    redirectedFrom(): Request | null;\n    failure(): {\n        errorText: string;\n    } | null;\n    _setBodySize(size: number): void;\n    bodySize(): number;\n    requestHeadersSize(): Promise<number>;\n}\nexport declare class Route extends SdkObject {\n    private readonly _request;\n    private readonly _delegate;\n    private _handled;\n    private _currentHandler;\n    private _futureHandlers;\n    constructor(request: Request, delegate: RouteDelegate);\n    handle(handlers: RouteHandler[]): void;\n    removeHandler(handler: RouteHandler): Promise<void>;\n    request(): Request;\n    abort(errorCode?: string): Promise<void>;\n    redirectNavigationRequest(url: string): void;\n    fulfill(overrides: channels.RouteFulfillParams): Promise<void>;\n    private _maybeAddCorsHeaders;\n    continue(overrides: types.NormalizedContinueOverrides): Promise<void>;\n    private _startHandling;\n    private _endHandling;\n}\nexport type RouteHandler = (route: Route, request: Request) => void;\ntype GetResponseBodyCallback = () => Promise<Buffer>;\nexport type ResourceTiming = {\n    startTime: number;\n    domainLookupStart: number;\n    domainLookupEnd: number;\n    connectStart: number;\n    secureConnectionStart: number;\n    connectEnd: number;\n    requestStart: number;\n    responseStart: number;\n};\nexport type ResourceSizes = {\n    requestBodySize: number;\n    requestHeadersSize: number;\n    responseBodySize: number;\n    responseHeadersSize: number;\n    transferSize: number;\n};\nexport type RemoteAddr = {\n    ipAddress: string;\n    port: number;\n};\nexport type SecurityDetails = {\n    protocol?: string;\n    subjectName?: string;\n    issuer?: string;\n    validFrom?: number;\n    validTo?: number;\n};\nexport declare class Response extends SdkObject {\n    private _request;\n    private _contentPromise;\n    _finishedPromise: ManualPromise<void>;\n    private _status;\n    private _statusText;\n    private _url;\n    private _headers;\n    private _headersMap;\n    private _getResponseBodyCallback;\n    private _timing;\n    private _serverAddrPromise;\n    private _securityDetailsPromise;\n    private _rawResponseHeadersPromise;\n    private _httpVersion;\n    private _fromServiceWorker;\n    private _encodedBodySizePromise;\n    private _transferSizePromise;\n    private _responseHeadersSizePromise;\n    constructor(request: Request, status: number, statusText: string, headers: HeadersArray, timing: ResourceTiming, getResponseBodyCallback: GetResponseBodyCallback, fromServiceWorker: boolean, httpVersion?: string);\n    _serverAddrFinished(addr?: RemoteAddr): void;\n    _securityDetailsFinished(securityDetails?: SecurityDetails): void;\n    _requestFinished(responseEndTiming: number): void;\n    _setHttpVersion(httpVersion: string): void;\n    url(): string;\n    status(): number;\n    statusText(): string;\n    headers(): HeadersArray;\n    headerValue(name: string): string | undefined;\n    rawResponseHeaders(): Promise<NameValue[]>;\n    setRawResponseHeaders(headers: HeadersArray | null): void;\n    setTransferSize(size: number | null): void;\n    setEncodedBodySize(size: number | null): void;\n    setResponseHeadersSize(size: number | null): void;\n    timing(): ResourceTiming;\n    serverAddr(): Promise<RemoteAddr | null>;\n    securityDetails(): Promise<SecurityDetails | null>;\n    body(): Promise<Buffer>;\n    request(): Request;\n    frame(): frames.Frame | null;\n    httpVersion(): string;\n    fromServiceWorker(): boolean;\n    responseHeadersSize(): Promise<number>;\n    sizes(): Promise<ResourceSizes>;\n}\nexport declare class WebSocket extends SdkObject {\n    private _url;\n    private _notified;\n    static Events: {\n        Close: string;\n        SocketError: string;\n        FrameReceived: string;\n        FrameSent: string;\n    };\n    constructor(parent: SdkObject, url: string);\n    markAsNotified(): boolean;\n    url(): string;\n    frameSent(opcode: number, data: string): void;\n    frameReceived(opcode: number, data: string): void;\n    error(errorMessage: string): void;\n    closed(): void;\n}\nexport interface RouteDelegate {\n    abort(errorCode: string): Promise<void>;\n    fulfill(response: types.NormalizedFulfillResponse): Promise<void>;\n    continue(overrides: types.NormalizedContinueOverrides): Promise<void>;\n}\nexport declare function statusText(status: number): string;\nexport declare function singleHeader(name: string, value: string): HeadersArray;\nexport declare function mergeHeaders(headers: (HeadersArray | undefined | null)[]): HeadersArray;\nexport {};\n//# sourceMappingURL=network.d.ts.map",
      "server/page.d.ts": "/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { BrowserContext } from './browserContext';\nimport { ConsoleMessage } from './console';\nimport * as frames from './frames';\nimport * as input from './input';\nimport { SdkObject } from './instrumentation';\nimport * as js from './javascript';\nimport { Screenshotter } from './screenshotter';\nimport { LongStandingScope } from '../utils';\nimport type { Artifact } from './artifact';\nimport type * as dom from './dom';\nimport type * as network from './network';\nimport type { Progress } from './progress';\nimport type { ScreenshotOptions } from './screenshotter';\nimport type * as types from './types';\nimport type { ImageComparatorOptions } from './utils/comparators';\nimport type * as channels from '@protocol/channels';\nexport interface PageDelegate {\n    readonly rawMouse: input.RawMouse;\n    readonly rawKeyboard: input.RawKeyboard;\n    readonly rawTouchscreen: input.RawTouchscreen;\n    reload(): Promise<void>;\n    goBack(): Promise<boolean>;\n    goForward(): Promise<boolean>;\n    requestGC(): Promise<void>;\n    addInitScript(initScript: InitScript): Promise<void>;\n    removeInitScripts(initScripts: InitScript[]): Promise<void>;\n    closePage(runBeforeUnload: boolean): Promise<void>;\n    navigateFrame(frame: frames.Frame, url: string, referrer: string | undefined): Promise<frames.GotoResult>;\n    updateExtraHTTPHeaders(): Promise<void>;\n    updateEmulatedViewportSize(preserveWindowBoundaries?: boolean): Promise<void>;\n    updateEmulateMedia(): Promise<void>;\n    updateRequestInterception(): Promise<void>;\n    updateFileChooserInterception(): Promise<void>;\n    bringToFront(): Promise<void>;\n    setBackgroundColor(color?: {\n        r: number;\n        g: number;\n        b: number;\n        a: number;\n    }): Promise<void>;\n    takeScreenshot(progress: Progress, format: string, documentRect: types.Rect | undefined, viewportRect: types.Rect | undefined, quality: number | undefined, fitsViewport: boolean, scale: 'css' | 'device'): Promise<Buffer>;\n    adoptElementHandle<T extends Node>(handle: dom.ElementHandle<T>, to: dom.FrameExecutionContext): Promise<dom.ElementHandle<T>>;\n    getContentFrame(handle: dom.ElementHandle): Promise<frames.Frame | null>;\n    getOwnerFrame(handle: dom.ElementHandle): Promise<string | null>;\n    getContentQuads(handle: dom.ElementHandle): Promise<types.Quad[] | null | 'error:notconnected'>;\n    setInputFilePaths(handle: dom.ElementHandle<HTMLInputElement>, files: string[]): Promise<void>;\n    getBoundingBox(handle: dom.ElementHandle): Promise<types.Rect | null>;\n    getFrameElement(frame: frames.Frame): Promise<dom.ElementHandle>;\n    scrollRectIntoViewIfNeeded(handle: dom.ElementHandle, rect?: types.Rect): Promise<'error:notvisible' | 'error:notconnected' | 'done'>;\n    setScreencastOptions(options: {\n        width: number;\n        height: number;\n        quality: number;\n    } | null): Promise<void>;\n    pdf?: (options: channels.PagePdfParams) => Promise<Buffer>;\n    coverage?: () => any;\n    rafCountForStablePosition(): number;\n    inputActionEpilogue(): Promise<void>;\n    readonly cspErrorsAsynchronousForInlineScripts?: boolean;\n    resetForReuse(progress: Progress): Promise<void>;\n    shouldToggleStyleSheetToSyncAnimations(): boolean;\n}\ntype EmulatedSize = {\n    screen: types.Size;\n    viewport: types.Size;\n};\ntype EmulatedMedia = {\n    media: types.MediaType;\n    colorScheme: types.ColorScheme;\n    reducedMotion: types.ReducedMotion;\n    forcedColors: types.ForcedColors;\n    contrast: types.Contrast;\n};\ntype ExpectScreenshotOptions = ImageComparatorOptions & ScreenshotOptions & {\n    timeout: number;\n    expected?: Buffer;\n    isNot?: boolean;\n    locator?: {\n        frame: frames.Frame;\n        selector: string;\n    };\n};\nexport declare class Page extends SdkObject {\n    static Events: {\n        Close: string;\n        Crash: string;\n        Download: string;\n        EmulatedSizeChanged: string;\n        FileChooser: string;\n        FrameAttached: string;\n        FrameDetached: string;\n        InternalFrameNavigatedToNewDocument: string;\n        LocatorHandlerTriggered: string;\n        ScreencastFrame: string;\n        Video: string;\n        WebSocket: string;\n        Worker: string;\n    };\n    private _closedState;\n    private _closedPromise;\n    private _initialized;\n    private _initializedPromise;\n    private _consoleMessages;\n    private _pageErrors;\n    private _crashed;\n    readonly openScope: LongStandingScope;\n    readonly browserContext: BrowserContext;\n    readonly keyboard: input.Keyboard;\n    readonly mouse: input.Mouse;\n    readonly touchscreen: input.Touchscreen;\n    readonly delegate: PageDelegate;\n    private _emulatedSize;\n    private _extraHTTPHeaders;\n    private _emulatedMedia;\n    private _fileChooserInterceptedBy;\n    private readonly _pageBindings;\n    initScripts: InitScript[];\n    readonly screenshotter: Screenshotter;\n    readonly frameManager: frames.FrameManager;\n    private _workers;\n    readonly pdf: ((options: channels.PagePdfParams) => Promise<Buffer>) | undefined;\n    readonly coverage: any;\n    readonly requestInterceptors: network.RouteHandler[];\n    video: Artifact | null;\n    private _opener;\n    readonly isStorageStatePage: boolean;\n    private _locatorHandlers;\n    private _lastLocatorHandlerUid;\n    private _locatorHandlerRunningCounter;\n    private _networkRequests;\n    private _frameThrottler;\n    closeReason: string | undefined;\n    constructor(delegate: PageDelegate, browserContext: BrowserContext);\n    reportAsNew(opener: Page | undefined, error?: Error): Promise<void>;\n    private _markInitialized;\n    initializedOrUndefined(): Page | undefined;\n    waitForInitializedOrError(): Promise<Page | Error>;\n    emitOnContext(event: string | symbol, ...args: any[]): void;\n    resetForReuse(progress: Progress): Promise<void>;\n    _didClose(): void;\n    _didCrash(): void;\n    _onFileChooserOpened(handle: dom.ElementHandle): Promise<void>;\n    opener(): Page | undefined;\n    mainFrame(): frames.Frame;\n    frames(): frames.Frame[];\n    exposeBinding(progress: Progress, name: string, needsHandle: boolean, playwrightBinding: frames.FunctionWithSource): Promise<PageBinding>;\n    removeExposedBindings(bindings: PageBinding[]): Promise<void>;\n    setExtraHTTPHeaders(progress: Progress, headers: types.HeadersArray): Promise<void>;\n    extraHTTPHeaders(): types.HeadersArray | undefined;\n    addNetworkRequest(request: network.Request): void;\n    networkRequests(): network.Request[];\n    onBindingCalled(payload: string, context: dom.FrameExecutionContext): Promise<void>;\n    addConsoleMessage(worker: Worker | null, type: string, args: js.JSHandle[], location: types.ConsoleMessageLocation, text?: string): void;\n    consoleMessages(): ConsoleMessage[];\n    addPageError(pageError: Error): void;\n    pageErrors(): Error[];\n    reload(progress: Progress, options: types.NavigateOptions): Promise<network.Response | null>;\n    goBack(progress: Progress, options: types.NavigateOptions): Promise<network.Response | null>;\n    goForward(progress: Progress, options: types.NavigateOptions): Promise<network.Response | null>;\n    requestGC(): Promise<void>;\n    registerLocatorHandler(selector: string, noWaitAfter: boolean | undefined): number;\n    resolveLocatorHandler(uid: number, remove: boolean | undefined): void;\n    unregisterLocatorHandler(uid: number): void;\n    performActionPreChecks(progress: Progress): Promise<void>;\n    private _performWaitForNavigationCheck;\n    private _performLocatorHandlersCheckpoint;\n    emulateMedia(progress: Progress, options: Partial<EmulatedMedia>): Promise<void>;\n    emulatedMedia(): EmulatedMedia;\n    setViewportSize(progress: Progress, viewportSize: types.Size): Promise<void>;\n    setEmulatedSizeFromWindowOpen(emulatedSize: EmulatedSize): void;\n    private _setEmulatedSize;\n    emulatedSize(): EmulatedSize | undefined;\n    bringToFront(): Promise<void>;\n    addInitScript(progress: Progress, source: string): Promise<InitScript>;\n    removeInitScripts(initScripts: InitScript[]): Promise<void>;\n    needsRequestInterception(): boolean;\n    addRequestInterceptor(progress: Progress, handler: network.RouteHandler, prepend?: 'prepend'): Promise<void>;\n    removeRequestInterceptor(handler: network.RouteHandler): Promise<void>;\n    expectScreenshot(progress: Progress, options: ExpectScreenshotOptions): Promise<{\n        actual?: Buffer;\n        previous?: Buffer;\n        diff?: Buffer;\n        errorMessage?: string;\n        log?: string[];\n        timedOut?: boolean;\n    }>;\n    screenshot(progress: Progress, options: ScreenshotOptions): Promise<Buffer>;\n    close(options?: {\n        runBeforeUnload?: boolean;\n        reason?: string;\n    }): Promise<void>;\n    isClosed(): boolean;\n    hasCrashed(): boolean;\n    isClosedOrClosingOrCrashed(): boolean;\n    addWorker(workerId: string, worker: Worker): void;\n    removeWorker(workerId: string): void;\n    clearWorkers(): void;\n    setFileChooserInterceptedBy(enabled: boolean, by: any): Promise<void>;\n    fileChooserIntercepted(): boolean;\n    frameNavigatedToNewDocument(frame: frames.Frame): void;\n    allInitScripts(): InitScript[];\n    getBinding(name: string): PageBinding;\n    setScreencastOptions(options: {\n        width: number;\n        height: number;\n        quality: number;\n    } | null): void;\n    throttleScreencastFrameAck(ack: () => void): void;\n    temporarilyDisableTracingScreencastThrottling(): void;\n    safeNonStallingEvaluateInAllFrames(expression: string, world: types.World, options?: {\n        throwOnJSErrors?: boolean;\n    }): Promise<void>;\n    hideHighlight(): Promise<void>;\n    snapshotForAI(progress: Progress, options: {\n        track?: string;\n    }): Promise<{\n        full: string;\n        incremental?: string;\n    }>;\n}\nexport declare class Worker extends SdkObject {\n    static Events: {\n        Close: string;\n    };\n    readonly url: string;\n    private _executionContextPromise;\n    private _workerScriptLoaded;\n    existingExecutionContext: js.ExecutionContext | null;\n    readonly openScope: LongStandingScope;\n    constructor(parent: SdkObject, url: string);\n    createExecutionContext(delegate: js.ExecutionContextDelegate): js.ExecutionContext;\n    workerScriptLoaded(): void;\n    didClose(): void;\n    evaluateExpression(expression: string, isFunction: boolean | undefined, arg: any): Promise<any>;\n    evaluateExpressionHandle(expression: string, isFunction: boolean | undefined, arg: any): Promise<any>;\n}\nexport declare class PageBinding {\n    private static kController;\n    static kBindingName: string;\n    static createInitScript(): InitScript;\n    readonly name: string;\n    readonly playwrightFunction: frames.FunctionWithSource;\n    readonly initScript: InitScript;\n    readonly needsHandle: boolean;\n    readonly cleanupScript: string;\n    forClient?: unknown;\n    constructor(name: string, playwrightFunction: frames.FunctionWithSource, needsHandle: boolean);\n    static dispatch(page: Page, payload: string, context: dom.FrameExecutionContext): Promise<void>;\n}\nexport declare class InitScript {\n    readonly source: string;\n    constructor(source: string);\n}\nexport {};\n//# sourceMappingURL=page.d.ts.map",
      "server/pipeTransport.d.ts": "/**\n * Copyright 2018 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { ConnectionTransport, ProtocolRequest, ProtocolResponse } from './transport';\nexport declare class PipeTransport implements ConnectionTransport {\n    private _pipeRead;\n    private _pipeWrite;\n    private _pendingBuffers;\n    private _waitForNextTask;\n    private _closed;\n    private _onclose?;\n    onmessage?: (message: ProtocolResponse) => void;\n    constructor(pipeWrite: NodeJS.WritableStream, pipeRead: NodeJS.ReadableStream);\n    get onclose(): undefined | ((reason?: string) => void);\n    set onclose(onclose: undefined | ((reason?: string) => void));\n    send(message: ProtocolRequest): void;\n    close(): void;\n    _dispatch(buffer: Buffer): void;\n}\n//# sourceMappingURL=pipeTransport.d.ts.map",
      "server/playwright.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Android } from './android/android';\nimport { DebugController } from './debugController';\nimport { Electron } from './electron/electron';\nimport { SdkObject } from './instrumentation';\nimport type { BrowserType } from './browserType';\nimport type { Language } from '../utils';\nimport type { Browser } from './browser';\nimport type { Page } from './page';\ntype PlaywrightOptions = {\n    sdkLanguage: Language;\n    isInternalPlaywright?: boolean;\n    isServer?: boolean;\n};\nexport declare class Playwright extends SdkObject {\n    readonly chromium: BrowserType;\n    readonly android: Android;\n    readonly electron: Electron;\n    readonly firefox: BrowserType;\n    readonly webkit: BrowserType;\n    readonly options: PlaywrightOptions;\n    readonly debugController: DebugController;\n    private _allPages;\n    private _allBrowsers;\n    constructor(options: PlaywrightOptions);\n    allBrowsers(): Browser[];\n    allPages(): Page[];\n}\nexport declare function createPlaywright(options: PlaywrightOptions): Playwright;\nexport {};\n//# sourceMappingURL=playwright.d.ts.map",
      "server/progress.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { Progress } from '@protocol/progress';\nimport type { CallMetadata } from './instrumentation';\nexport type { Progress } from '@protocol/progress';\nexport declare class ProgressController {\n    private _forceAbortPromise;\n    private _donePromise;\n    private _state;\n    private _onCallLog?;\n    readonly metadata: CallMetadata;\n    constructor(metadata?: CallMetadata, onCallLog?: (message: string) => void);\n    abort(error: Error): Promise<void>;\n    run<T>(task: (progress: Progress) => Promise<T>, timeout?: number): Promise<T>;\n}\nexport declare function isAbortError(error: Error): boolean;\nexport declare function raceUncancellableOperationWithCleanup<T>(progress: Progress, run: () => Promise<T>, cleanup: (t: T) => void | Promise<unknown>): Promise<T>;\n//# sourceMappingURL=progress.d.ts.map",
      "server/protocolError.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport declare class ProtocolError extends Error {\n    type: 'error' | 'closed' | 'crashed';\n    method: string | undefined;\n    logs: string | undefined;\n    constructor(type: 'error' | 'closed' | 'crashed', method?: string, logs?: string);\n    setMessage(message: string): void;\n    browserLogMessage(): string;\n}\nexport declare function isProtocolError(e: Error): e is ProtocolError;\nexport declare function isSessionClosedError(e: Error): e is ProtocolError;\n//# sourceMappingURL=protocolError.d.ts.map",
      "server/recorder/chat.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport type ChatMessage = {\n    content: string;\n    user: 'user' | 'assistant';\n};\nexport declare class Chat {\n    private _history;\n    private _connectionPromise;\n    private _chatSinks;\n    private _wsEndpoint;\n    constructor(wsEndpoint: string);\n    clearHistory(): void;\n    post<T>(prompt: string): Promise<T | null>;\n    private _append;\n    private _connection;\n    private _dispatchEvent;\n    private _post;\n}\nexport declare function asString(stream: AsyncIterable<string>): Promise<string>;\n//# sourceMappingURL=chat.d.ts.map",
      "server/recorder/recorderApp.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Recorder } from '../recorder';\nimport { BrowserContext } from '../browserContext';\nimport type { Language } from '../codegen/types';\nimport type * as channels from '@protocol/channels';\nexport type RecorderAppParams = channels.BrowserContextEnableRecorderParams & {\n    browserName: string;\n    sdkLanguage: Language;\n    headed: boolean;\n    executablePath?: string;\n    channel?: string;\n};\nexport declare class RecorderApp {\n    private _recorder;\n    private _page;\n    readonly wsEndpointForTest: string | undefined;\n    private _languageGeneratorOptions;\n    private _throttledOutputFile;\n    private _actions;\n    private _userSources;\n    private _recorderSources;\n    private _primaryGeneratorId;\n    private _selectedGeneratorId;\n    private constructor();\n    private _init;\n    private _handleUIEvent;\n    static show(context: BrowserContext, params: channels.BrowserContextEnableRecorderParams): Promise<void>;\n    close(): Promise<void>;\n    static showInspectorNoReply(context: BrowserContext): void;\n    private static _show;\n    private _wireListeners;\n    private _onActionAdded;\n    private _onSignalAdded;\n    private _onPageNavigated;\n    private _onContextClosed;\n    private _onModeChanged;\n    private _onPausedStateChanged;\n    private _onUserSourcesChanged;\n    private _onElementPicked;\n    private _onCallLogsUpdated;\n    private _pushAllSources;\n    private _revealSource;\n    private _updateActions;\n}\nexport declare class ProgrammaticRecorderApp {\n    static run(inspectedContext: BrowserContext, recorder: Recorder, browserName: string, params: channels.BrowserContextEnableRecorderParams): Promise<void>;\n}\n//# sourceMappingURL=recorderApp.d.ts.map",
      "server/recorder/recorderRunner.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { Page } from '../page';\nimport type * as types from '../types';\nimport type * as actions from '@recorder/actions';\nexport declare function performAction(pageAliases: Map<Page, string>, actionInContext: actions.ActionInContext): Promise<void>;\nexport declare function toClickOptions(action: actions.ClickAction): types.MouseClickOptions;\n//# sourceMappingURL=recorderRunner.d.ts.map",
      "server/recorder/recorderSignalProcessor.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { Signal } from '../../../../recorder/src/actions';\nimport type { Frame } from '../frames';\nimport type * as actions from '@recorder/actions';\nexport interface ProcessorDelegate {\n    addAction(actionInContext: actions.ActionInContext): void;\n    addSignal(signalInContext: actions.SignalInContext): void;\n}\nexport declare class RecorderSignalProcessor {\n    private _delegate;\n    private _lastAction;\n    constructor(actionSink: ProcessorDelegate);\n    addAction(actionInContext: actions.ActionInContext): void;\n    signal(pageAlias: string, frame: Frame, signal: Signal): void;\n}\n//# sourceMappingURL=recorderSignalProcessor.d.ts.map",
      "server/recorder/recorderUtils.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Frame } from '../frames';\nimport type { CallMetadata } from '../instrumentation';\nimport type { Page } from '../page';\nimport type * as actions from '@recorder/actions';\nimport type { CallLog, CallLogStatus } from '@recorder/recorderTypes';\nexport declare function buildFullSelector(framePath: string[], selector: string): string;\nexport declare function metadataToCallLog(metadata: CallMetadata, status: CallLogStatus): CallLog;\nexport declare function mainFrameForAction(pageAliases: Map<Page, string>, actionInContext: actions.ActionInContext): Frame;\nexport declare function frameForAction(pageAliases: Map<Page, string>, actionInContext: actions.ActionInContext, action: actions.ActionWithSelector): Promise<Frame>;\nexport declare function shouldMergeAction(action: actions.ActionInContext, lastAction: actions.ActionInContext | undefined): boolean;\nexport declare function collapseActions(actions: actions.ActionInContext[]): actions.ActionInContext[];\nexport declare function generateFrameSelector(frame: Frame): Promise<string[]>;\n//# sourceMappingURL=recorderUtils.d.ts.map",
      "server/recorder/throttledFile.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport declare class ThrottledFile {\n    private _file;\n    private _timer;\n    private _text;\n    constructor(file: string);\n    setContent(text: string): void;\n    flush(): void;\n}\n//# sourceMappingURL=throttledFile.d.ts.map",
      "server/recorder.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport EventEmitter from 'events';\nimport { BrowserContext } from './browserContext';\nimport type { Language } from './codegen/types';\nimport type { CallMetadata, InstrumentationListener, SdkObject } from './instrumentation';\nimport type { AriaTemplateNode } from '@isomorphic/ariaSnapshot';\nimport type * as channels from '@protocol/channels';\nimport type * as actions from '@recorder/actions';\nimport type { CallLog, ElementInfo, Mode, Source } from '@recorder/recorderTypes';\nexport declare const RecorderEvent: {\n    readonly PausedStateChanged: \"pausedStateChanged\";\n    readonly ModeChanged: \"modeChanged\";\n    readonly ElementPicked: \"elementPicked\";\n    readonly CallLogsUpdated: \"callLogsUpdated\";\n    readonly UserSourcesChanged: \"userSourcesChanged\";\n    readonly ActionAdded: \"actionAdded\";\n    readonly SignalAdded: \"signalAdded\";\n    readonly PageNavigated: \"pageNavigated\";\n    readonly ContextClosed: \"contextClosed\";\n};\nexport type RecorderEventMap = {\n    [RecorderEvent.PausedStateChanged]: [paused: boolean];\n    [RecorderEvent.ModeChanged]: [mode: Mode];\n    [RecorderEvent.ElementPicked]: [elementInfo: ElementInfo, userGesture?: boolean];\n    [RecorderEvent.CallLogsUpdated]: [callLogs: CallLog[]];\n    [RecorderEvent.UserSourcesChanged]: [sources: Source[], pausedSourceId?: string];\n    [RecorderEvent.ActionAdded]: [action: actions.ActionInContext];\n    [RecorderEvent.SignalAdded]: [signal: actions.SignalInContext];\n    [RecorderEvent.PageNavigated]: [url: string];\n    [RecorderEvent.ContextClosed]: [];\n};\nexport declare class Recorder extends EventEmitter<RecorderEventMap> implements InstrumentationListener {\n    readonly handleSIGINT: boolean | undefined;\n    private _context;\n    private _params;\n    private _mode;\n    private _highlightedElement;\n    private _overlayState;\n    private _currentCallsMetadata;\n    private _userSources;\n    private _debugger;\n    private _omitCallTracking;\n    private _currentLanguage;\n    private _recorderMode;\n    private _signalProcessor;\n    private _pageAliases;\n    private _lastPopupOrdinal;\n    private _lastDialogOrdinal;\n    private _lastDownloadOrdinal;\n    private _listeners;\n    private _enabled;\n    private _callLogs;\n    static forContext(context: BrowserContext, params: channels.BrowserContextEnableRecorderParams): Promise<Recorder>;\n    static existingForContext(context: BrowserContext): Promise<Recorder | undefined>;\n    private static _create;\n    constructor(context: BrowserContext, params: channels.BrowserContextEnableRecorderParams);\n    private _install;\n    private _pausedStateChanged;\n    mode(): Mode;\n    setMode(mode: Mode): void;\n    url(): string | undefined;\n    setHighlightedSelector(selector: string): void;\n    setHighlightedAriaTemplate(ariaTemplate: AriaTemplateNode): void;\n    step(): void;\n    setLanguage(language: Language): void;\n    resume(): void;\n    pause(): void;\n    paused(): boolean;\n    close(): void;\n    hideHighlightedSelector(): void;\n    pausedSourceId(): any;\n    userSources(): Source[];\n    callLog(): CallLog[];\n    private _scopeHighlightedSelectorToFrame;\n    private _refreshOverlay;\n    onBeforeCall(sdkObject: SdkObject, metadata: CallMetadata): Promise<void>;\n    onAfterCall(sdkObject: SdkObject, metadata: CallMetadata): Promise<void>;\n    private _updateUserSources;\n    onBeforeInputAction(sdkObject: SdkObject, metadata: CallMetadata): Promise<void>;\n    onCallLog(sdkObject: SdkObject, metadata: CallMetadata, logName: string, message: string): Promise<void>;\n    updateCallLog(metadatas: CallMetadata[]): void;\n    private _isRecording;\n    private _readSource;\n    private _setEnabled;\n    private _onPage;\n    private _filePrimaryURLChanged;\n    clear(): void;\n    private _describeMainFrame;\n    private _describeFrame;\n    private _testIdAttributeName;\n    private _createActionInContext;\n    private _performAction;\n    private _recordAction;\n    private _onFrameNavigated;\n    private _onPopup;\n    private _onDownload;\n    private _onDialog;\n}\n//# sourceMappingURL=recorder.d.ts.map",
      "server/registry/browserFetcher.d.ts": "/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport declare function downloadBrowserWithProgressBar(title: string, browserDirectory: string, executablePath: string | undefined, downloadURLs: string[], downloadFileName: string, downloadSocketTimeout: number): Promise<boolean>;\nexport declare function logPolitely(toBeLogged: string): void;\n//# sourceMappingURL=browserFetcher.d.ts.map",
      "server/registry/dependencies.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport declare function writeDockerVersion(dockerImageNameTemplate: string): Promise<void>;\nexport declare function dockerVersion(dockerImageNameTemplate: string): {\n    driverVersion: string;\n    dockerImageName: string;\n};\nexport declare function readDockerVersionSync(): null | {\n    driverVersion: string;\n    dockerImageName: string;\n    dockerImageNameTemplate: string;\n};\nexport type DependencyGroup = 'chromium' | 'firefox' | 'webkit' | 'tools';\nexport declare function installDependenciesWindows(targets: Set<DependencyGroup>, dryRun: boolean): Promise<void>;\nexport declare function installDependenciesLinux(targets: Set<DependencyGroup>, dryRun: boolean): Promise<void>;\nexport declare function validateDependenciesWindows(sdkLanguage: string, windowsExeAndDllDirectories: string[]): Promise<void>;\nexport declare function validateDependenciesLinux(sdkLanguage: string, linuxLddDirectories: string[], dlOpenLibraries: string[]): Promise<void>;\nexport declare function transformCommandsForRoot(commands: string[]): Promise<{\n    command: string;\n    args: string[];\n    elevatedPermissions: boolean;\n}>;\n//# sourceMappingURL=dependencies.d.ts.map",
      "server/registry/index.d.ts": "/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport { writeDockerVersion } from './dependencies';\nexport declare const registryDirectory: string;\ntype BrowsersJSON = {\n    comment: string;\n    browsers: {\n        name: string;\n        revision: string;\n        browserVersion?: string;\n        installByDefault: boolean;\n        revisionOverrides?: {\n            [os: string]: string;\n        };\n    }[];\n};\nexport type BrowserInfo = {\n    browserName: string;\n    browserVersion: number;\n    browserPath: string;\n    referenceDir: string;\n};\nexport type BrowserName = 'chromium' | 'firefox' | 'webkit';\ntype InternalTool = 'ffmpeg' | 'winldd' | 'firefox-beta' | 'chromium-tip-of-tree' | 'chromium-headless-shell' | 'chromium-tip-of-tree-headless-shell' | 'android';\ntype BidiChannel = 'moz-firefox' | 'moz-firefox-beta' | 'moz-firefox-nightly' | 'bidi-chrome-canary' | 'bidi-chrome-stable' | 'bidi-chromium';\ntype ChromiumChannel = 'chrome' | 'chrome-beta' | 'chrome-dev' | 'chrome-canary' | 'msedge' | 'msedge-beta' | 'msedge-dev' | 'msedge-canary';\nexport interface Executable {\n    type: 'browser' | 'tool' | 'channel';\n    name: BrowserName | InternalTool | ChromiumChannel | BidiChannel | 'webkit-wsl';\n    browserName: BrowserName | undefined;\n    installType: 'download-by-default' | 'download-on-demand' | 'install-script' | 'none';\n    directory: string | undefined;\n    downloadURLs?: string[];\n    browserVersion?: string;\n    executablePathOrDie(sdkLanguage: string): string;\n    executablePath(sdkLanguage: string): string | undefined;\n    _validateHostRequirements(sdkLanguage: string): Promise<void>;\n    wslExecutablePath?: string;\n}\nexport declare class Registry {\n    private _executables;\n    constructor(browsersJSON: BrowsersJSON);\n    private _createChromiumChannel;\n    private _createBidiFirefoxChannel;\n    private _createBidiChromiumChannel;\n    executables(): Executable[];\n    findExecutable(name: BrowserName): Executable;\n    findExecutable(name: string): Executable | undefined;\n    defaultExecutables(): Executable[];\n    private _dedupe;\n    private _validateHostRequirements;\n    installDeps(executablesToInstallDeps: Executable[], dryRun: boolean): Promise<void>;\n    install(executablesToInstall: Executable[], options?: {\n        force?: boolean;\n    }): Promise<void>;\n    uninstall(all: boolean): Promise<{\n        numberOfBrowsersLeft: number;\n    }>;\n    validateHostRequirementsForExecutablesIfNeeded(executables: Executable[], sdkLanguage: string): Promise<void>;\n    private _validateHostRequirementsForExecutableIfNeeded;\n    private _downloadURLs;\n    private _downloadExecutable;\n    private _installMSEdgeChannel;\n    private _installChromiumChannel;\n    listInstalledBrowsers(): Promise<BrowserInfo[]>;\n    private _validateInstallationCache;\n    private _traverseBrowserInstallations;\n    private _deleteStaleBrowsers;\n    private _deleteBrokenInstallations;\n    private _defaultBrowsersToInstall;\n    suggestedBrowsersToInstall(): string;\n    resolveBrowsers(aliases: string[], options: {\n        shell?: 'no' | 'only';\n    }): Executable[];\n}\nexport declare function browserDirectoryToMarkerFilePath(browserDirectory: string): string;\nexport declare function buildPlaywrightCLICommand(sdkLanguage: string, parameters: string): string;\nexport declare function installBrowsersForNpmInstall(browsers: string[]): Promise<boolean>;\nexport declare function findChromiumChannelBestEffort(sdkLanguage: string): string | undefined;\nexport declare const registry: Registry;\n//# sourceMappingURL=index.d.ts.map",
      "server/registry/nativeDeps.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport declare const deps: any;\n//# sourceMappingURL=nativeDeps.d.ts.map",
      "server/registry/oopDownloadBrowserMain.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport type DownloadParams = {\n    title: string;\n    browserDirectory: string;\n    url: string;\n    zipPath: string;\n    executablePath: string | undefined;\n    socketTimeout: number;\n    userAgent: string;\n};\n//# sourceMappingURL=oopDownloadBrowserMain.d.ts.map",
      "server/screenshotter.d.ts": "/**\n * Copyright 2019 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type * as dom from './dom';\nimport type { Frame } from './frames';\nimport type { Page } from './page';\nimport type { Progress } from './progress';\nimport type { Rect } from '../utils/isomorphic/types';\ndeclare global {\n    interface Window {\n        __pwCleanupScreenshot?: () => void;\n    }\n}\nexport type ScreenshotOptions = {\n    type?: 'png' | 'jpeg';\n    quality?: number;\n    omitBackground?: boolean;\n    animations?: 'disabled' | 'allow';\n    mask?: {\n        frame: Frame;\n        selector: string;\n    }[];\n    maskColor?: string;\n    fullPage?: boolean;\n    clip?: Rect;\n    scale?: 'css' | 'device';\n    caret?: 'hide' | 'initial';\n    style?: string;\n};\nexport declare class Screenshotter {\n    private _queue;\n    private _page;\n    constructor(page: Page);\n    private _originalViewportSize;\n    private _fullPageSize;\n    screenshotPage(progress: Progress, options: ScreenshotOptions): Promise<Buffer>;\n    screenshotElement(progress: Progress, handle: dom.ElementHandle, options: ScreenshotOptions): Promise<Buffer>;\n    _preparePageForScreenshot(progress: Progress, frame: Frame, screenshotStyle: string | undefined, hideCaret: boolean, disableAnimations: boolean): Promise<void>;\n    _restorePageAfterScreenshot(): Promise<void>;\n    _maskElements(progress: Progress, options: ScreenshotOptions): Promise<() => Promise<void>>;\n    private _screenshot;\n}\nexport declare function validateScreenshotOptions(options: ScreenshotOptions): 'png' | 'jpeg';\n//# sourceMappingURL=screenshotter.d.ts.map",
      "server/selectors.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { ParsedSelector } from '../utils/isomorphic/selectorParser';\nimport type * as channels from '@protocol/channels';\nexport declare class Selectors {\n    private readonly _builtinEngines;\n    private readonly _builtinEnginesInMainWorld;\n    readonly _engines: Map<string, channels.SelectorEngine>;\n    readonly guid: string;\n    private _testIdAttributeName;\n    constructor(engines: channels.SelectorEngine[], testIdAttributeName: string | undefined);\n    register(engine: channels.SelectorEngine): void;\n    testIdAttributeName(): string;\n    setTestIdAttributeName(testIdAttributeName: string): void;\n    parseSelector(selector: string | ParsedSelector, strict: boolean): {\n        parsed: ParsedSelector;\n        world: \"main\" | \"utility\";\n        strict: boolean;\n    };\n}\n//# sourceMappingURL=selectors.d.ts.map",
      "server/socksClientCertificatesInterceptor.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport tls from 'tls';\nimport { SocksProxy } from './utils/socksProxy';\nimport type * as types from './types';\nimport type https from 'https';\nimport type { Progress } from '@protocol/progress';\nexport declare class ClientCertificatesProxy {\n    _socksProxy: SocksProxy;\n    private _connections;\n    ignoreHTTPSErrors: boolean | undefined;\n    secureContextMap: Map<string, tls.SecureContext>;\n    private _proxy;\n    private constructor();\n    getProxyAgent(host: string, port: number): any;\n    _initSecureContexts(clientCertificates: types.BrowserContextOptions['clientCertificates']): void;\n    static create(progress: Progress, contextOptions: Pick<types.BrowserContextOptions, 'clientCertificates' | 'ignoreHTTPSErrors' | 'proxy'>): Promise<ClientCertificatesProxy>;\n    proxySettings(): types.ProxySettings;\n    close(): Promise<void>;\n}\nexport declare function getMatchingTLSOptionsForOrigin(clientCertificates: types.BrowserContextOptions['clientCertificates'], origin: string): Pick<https.RequestOptions, 'pfx' | 'key' | 'cert'> | undefined;\nexport declare function rewriteOpenSSLErrorIfNeeded(error: Error): Error;\n//# sourceMappingURL=socksClientCertificatesInterceptor.d.ts.map",
      "server/socksInterceptor.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { WebSocketTransport } from './transport';\nexport declare class SocksInterceptor {\n    private _handler;\n    private _channel;\n    private _socksSupportObjectGuid?;\n    private _ids;\n    constructor(transport: WebSocketTransport, pattern: string | undefined, redirectPortForTest: number | undefined);\n    cleanup(): void;\n    interceptMessage(message: any): boolean;\n}\n//# sourceMappingURL=socksInterceptor.d.ts.map",
      "server/trace/recorder/snapshotter.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { BrowserContext } from '../../browserContext';\nimport { Page } from '../../page';\nimport type { FrameSnapshot } from '@trace/snapshot';\nexport type SnapshotterBlob = {\n    buffer: Buffer;\n    sha1: string;\n};\nexport interface SnapshotterDelegate {\n    onSnapshotterBlob(blob: SnapshotterBlob): void;\n    onFrameSnapshot(snapshot: FrameSnapshot): void;\n}\nexport declare class Snapshotter {\n    private _context;\n    private _delegate;\n    private _eventListeners;\n    private _snapshotStreamer;\n    private _initScript;\n    private _started;\n    constructor(context: BrowserContext, delegate: SnapshotterDelegate);\n    started(): boolean;\n    start(): Promise<void>;\n    reset(): Promise<void>;\n    stop(): void;\n    resetForReuse(): Promise<void>;\n    _initialize(): Promise<void>;\n    dispose(): void;\n    private _captureFrameSnapshot;\n    captureSnapshot(page: Page, callId: string, snapshotName: string): Promise<void>;\n    private _onPage;\n    private _annotateFrameHierarchy;\n}\n//# sourceMappingURL=snapshotter.d.ts.map",
      "server/trace/recorder/snapshotterInjected.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { NodeSnapshot } from '@trace/snapshot';\nexport type SnapshotData = {\n    doctype?: string;\n    html: NodeSnapshot;\n    resourceOverrides: {\n        url: string;\n        content: string | number;\n        contentType: 'text/css';\n    }[];\n    viewport: {\n        width: number;\n        height: number;\n    };\n    url: string;\n    wallTime: number;\n    collectionTime: number;\n};\nexport declare function frameSnapshotStreamer(snapshotStreamer: string, removeNoScript: boolean): void;\n//# sourceMappingURL=snapshotterInjected.d.ts.map",
      "server/trace/recorder/tracing.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Artifact } from '../../artifact';\nimport { BrowserContext } from '../../browserContext';\nimport { SdkObject } from '../../instrumentation';\nimport { Page } from '../../page';\nimport type { SnapshotterBlob, SnapshotterDelegate } from './snapshotter';\nimport type { NameValue } from '../../../utils/isomorphic/types';\nimport type { Dialog } from '../../dialog';\nimport type { Download } from '../../download';\nimport type { APIRequestContext } from '../../fetch';\nimport type { HarTracerDelegate } from '../../har/harTracer';\nimport type { CallMetadata, InstrumentationListener } from '../../instrumentation';\nimport type { TracingTracingStopChunkParams } from '@protocol/channels';\nimport type * as har from '@trace/har';\nimport type { FrameSnapshot } from '@trace/snapshot';\nimport type { Progress } from '@protocol/progress';\nexport type TracerOptions = {\n    name?: string;\n    snapshots?: boolean;\n    screenshots?: boolean;\n    live?: boolean;\n};\nexport declare class Tracing extends SdkObject implements InstrumentationListener, SnapshotterDelegate, HarTracerDelegate {\n    private _fs;\n    private _snapshotter?;\n    private _harTracer;\n    private _screencastListeners;\n    private _eventListeners;\n    private _context;\n    private _state;\n    private _isStopping;\n    private _precreatedTracesDir;\n    private _tracesTmpDir;\n    private _allResources;\n    private _contextCreatedEvent;\n    private _pendingHarEntries;\n    constructor(context: BrowserContext | APIRequestContext, tracesDir: string | undefined);\n    private _sdkLanguage;\n    resetForReuse(progress: Progress): Promise<void>;\n    start(options: TracerOptions): void;\n    startChunk(progress: Progress, options?: {\n        name?: string;\n        title?: string;\n    }): Promise<{\n        traceName: string;\n    }>;\n    private _currentGroupId;\n    group(name: string, location: {\n        file: string;\n        line?: number;\n        column?: number;\n    } | undefined, metadata: CallMetadata): void;\n    groupEnd(): void;\n    private _startScreencast;\n    private _stopScreencast;\n    private _allocateNewTraceFile;\n    private _changeTraceName;\n    stop(progress: Progress | undefined): Promise<void>;\n    deleteTmpTracesDir(): Promise<void>;\n    private _createTracesDirIfNeeded;\n    abort(): void;\n    flush(): Promise<void>;\n    private _closeAllGroups;\n    stopChunk(progress: Progress | undefined, params: TracingTracingStopChunkParams): Promise<{\n        artifact?: Artifact;\n        entries?: NameValue[];\n    }>;\n    _captureSnapshot(snapshotName: string, sdkObject: SdkObject, metadata: CallMetadata): Promise<void>;\n    onBeforeCall(sdkObject: SdkObject, metadata: CallMetadata): Promise<void>;\n    onBeforeInputAction(sdkObject: SdkObject, metadata: CallMetadata): Promise<void>;\n    onCallLog(sdkObject: SdkObject, metadata: CallMetadata, logName: string, message: string): void;\n    onAfterCall(sdkObject: SdkObject, metadata: CallMetadata): Promise<void>;\n    onEntryStarted(entry: har.Entry): void;\n    onEntryFinished(entry: har.Entry): void;\n    flushHarEntries(): void;\n    onContentBlob(sha1: string, buffer: Buffer): void;\n    onSnapshotterBlob(blob: SnapshotterBlob): void;\n    onFrameSnapshot(snapshot: FrameSnapshot): void;\n    private _onConsoleMessage;\n    onDialog(dialog: Dialog): void;\n    onDownload(page: Page, download: Download): void;\n    onPageOpen(page: Page): void;\n    onPageClose(page: Page): void;\n    private _onPageError;\n    private _startScreencastInPage;\n    private _appendTraceEvent;\n    private _appendResource;\n}\n//# sourceMappingURL=tracing.d.ts.map",
      "server/trace/test/inMemorySnapshotter.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { SnapshotRenderer } from '../../../../../trace-viewer/src/sw/snapshotRenderer';\nimport type { BrowserContext } from '../../browserContext';\nimport type { HarTracerDelegate } from '../../har/harTracer';\nimport type { Page } from '../../page';\nimport type { SnapshotterBlob, SnapshotterDelegate } from '../recorder/snapshotter';\nimport type * as har from '@trace/har';\nimport type { FrameSnapshot } from '@trace/snapshot';\nexport declare class InMemorySnapshotter implements SnapshotterDelegate, HarTracerDelegate {\n    private _blobs;\n    private _snapshotter;\n    private _harTracer;\n    private _snapshotReadyPromises;\n    private _storage;\n    private _snapshotCount;\n    constructor(context: BrowserContext);\n    initialize(): Promise<void>;\n    reset(): Promise<void>;\n    dispose(): Promise<void>;\n    captureSnapshot(page: Page, callId: string, snapshotName: string): Promise<SnapshotRenderer>;\n    onEntryStarted(entry: har.Entry): void;\n    onEntryFinished(entry: har.Entry): void;\n    onContentBlob(sha1: string, buffer: Buffer): void;\n    onSnapshotterBlob(blob: SnapshotterBlob): void;\n    onFrameSnapshot(snapshot: FrameSnapshot): void;\n    resourceContentForTest(sha1: string): Promise<Buffer | undefined>;\n    snapshotCount(): number;\n}\n//# sourceMappingURL=inMemorySnapshotter.d.ts.map",
      "server/trace/viewer/traceViewer.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { HttpServer } from '../../utils/httpServer';\nimport type { Transport } from '../../utils/httpServer';\nimport type { BrowserType } from '../../browserType';\nimport type { Page } from '../../page';\nexport type TraceViewerServerOptions = {\n    host?: string;\n    port?: number;\n    isServer?: boolean;\n    transport?: Transport;\n};\nexport type TraceViewerRedirectOptions = {\n    args?: string[];\n    grep?: string;\n    grepInvert?: string;\n    project?: string[];\n    reporter?: string[];\n    webApp?: string;\n    isServer?: boolean;\n};\nexport type TraceViewerAppOptions = {\n    headless?: boolean;\n    persistentContextOptions?: Parameters<BrowserType['launchPersistentContext']>[2];\n};\nexport declare function startTraceViewerServer(options?: TraceViewerServerOptions): Promise<HttpServer>;\nexport declare function installRootRedirect(server: HttpServer, traceUrl: string | undefined, options: TraceViewerRedirectOptions): Promise<void>;\nexport declare function runTraceViewerApp(traceUrl: string | undefined, browserName: string, options: TraceViewerServerOptions & {\n    headless?: boolean;\n}, exitOnClose?: boolean): Promise<Page>;\nexport declare function runTraceInBrowser(traceUrl: string | undefined, options: TraceViewerServerOptions): Promise<void>;\nexport declare function openTraceViewerApp(url: string, browserName: string, options?: TraceViewerAppOptions): Promise<Page>;\nexport declare function openTraceInBrowser(url: string): Promise<void>;\n//# sourceMappingURL=traceViewer.d.ts.map",
      "server/transport.d.ts": "/**\n * Copyright 2018 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { Progress } from './progress';\nimport type { HeadersArray } from './types';\nexport declare const perMessageDeflate: {\n    clientNoContextTakeover: boolean;\n    zlibDeflateOptions: {\n        level: number;\n    };\n    zlibInflateOptions: {\n        chunkSize: number;\n    };\n    threshold: number;\n};\nexport type ProtocolRequest = {\n    id: number;\n    method: string;\n    params: any;\n    sessionId?: string;\n};\nexport type ProtocolResponse = {\n    id?: number;\n    method?: string;\n    sessionId?: string;\n    error?: {\n        message: string;\n        data: any;\n        code?: number;\n    };\n    params?: any;\n    result?: any;\n    pageProxyId?: string;\n    browserContextId?: string;\n};\nexport interface ConnectionTransport {\n    send(s: ProtocolRequest): void;\n    close(): void;\n    onmessage?: (message: ProtocolResponse) => void;\n    onclose?: (reason?: string) => void;\n}\ntype WebSocketTransportOptions = {\n    headers?: {\n        [key: string]: string;\n    };\n    followRedirects?: boolean;\n    debugLogHeader?: string;\n};\nexport declare class WebSocketTransport implements ConnectionTransport {\n    private _ws;\n    private _progress?;\n    private _logUrl;\n    onmessage?: (message: ProtocolResponse) => void;\n    onclose?: (reason?: string) => void;\n    readonly wsEndpoint: string;\n    readonly headers: HeadersArray;\n    static connect(progress: (Progress | undefined), url: string, options?: WebSocketTransportOptions): Promise<WebSocketTransport>;\n    static _connect(progress: (Progress | undefined), url: string, options: WebSocketTransportOptions, hadRedirects: boolean): Promise<WebSocketTransport>;\n    constructor(progress: Progress | undefined, url: string, logUrl: string, options: WebSocketTransportOptions);\n    send(message: ProtocolRequest): void;\n    close(): void;\n    closeAndWait(): Promise<void>;\n}\nexport {};\n//# sourceMappingURL=transport.d.ts.map",
      "server/types.d.ts": "/**\n * Copyright 2018 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { HeadersArray, Point, Size } from '../utils/isomorphic/types';\nexport type { HeadersArray, Point, Quad, Rect, Size } from '../utils/isomorphic/types';\nimport type * as channels from '@protocol/channels';\nexport type StrictOptions = {\n    strict?: boolean;\n};\nexport type QueryOnSelectorOptions = StrictOptions;\nexport type WaitForElementOptions = StrictOptions & {\n    state?: 'attached' | 'detached' | 'visible' | 'hidden';\n} & {\n    omitReturnValue?: boolean;\n};\nexport type LifecycleEvent = 'load' | 'domcontentloaded' | 'networkidle' | 'commit';\nexport declare const kLifecycleEvents: Set<LifecycleEvent>;\nexport type NavigateOptions = {\n    waitUntil?: LifecycleEvent;\n};\nexport type CommonActionOptions = StrictOptions & {\n    force?: boolean;\n};\nexport type PointerActionWaitOptions = CommonActionOptions & {\n    trial?: boolean;\n};\nexport type PageScreencastOptions = {\n    width: number;\n    height: number;\n    outputFile: string;\n};\nexport type Credentials = {\n    username: string;\n    password: string;\n    origin?: string;\n    sendImmediately?: boolean;\n};\nexport type Geolocation = {\n    longitude: number;\n    latitude: number;\n    accuracy?: number;\n};\nexport type SelectOption = {\n    value?: string;\n    label?: string;\n    index?: number;\n};\nexport type FilePayload = {\n    name: string;\n    mimeType: string;\n    buffer: string;\n    lastModifiedMs?: number;\n};\nexport type MediaType = 'screen' | 'print' | 'no-override';\nexport type ColorScheme = 'dark' | 'light' | 'no-preference' | 'no-override';\nexport type ReducedMotion = 'no-preference' | 'reduce' | 'no-override';\nexport type ForcedColors = 'active' | 'none' | 'no-override';\nexport type Contrast = 'no-preference' | 'more' | 'no-override';\nexport type DeviceDescriptor = {\n    userAgent: string;\n    viewport: Size;\n    deviceScaleFactor: number;\n    isMobile: boolean;\n    hasTouch: boolean;\n    defaultBrowserType: 'chromium' | 'firefox' | 'webkit';\n};\nexport type Devices = {\n    [name: string]: DeviceDescriptor;\n};\nexport type ProxySettings = {\n    server: string;\n    bypass?: string;\n    username?: string;\n    password?: string;\n};\nexport type KeyboardModifier = 'Alt' | 'Control' | 'Meta' | 'Shift';\nexport type SmartKeyboardModifier = KeyboardModifier | 'ControlOrMeta';\nexport type MouseButton = 'left' | 'right' | 'middle';\nexport type PointerActionOptions = {\n    modifiers?: SmartKeyboardModifier[];\n    position?: Point;\n};\nexport type DragActionOptions = {\n    sourcePosition?: Point;\n    targetPosition?: Point;\n    steps?: number;\n};\nexport type MouseClickOptions = PointerActionOptions & {\n    delay?: number;\n    button?: MouseButton;\n    clickCount?: number;\n};\nexport type MouseMultiClickOptions = PointerActionOptions & {\n    delay?: number;\n    button?: MouseButton;\n};\nexport type World = 'main' | 'utility';\nexport type GotoOptions = NavigateOptions & {\n    referer?: string;\n};\nexport type NormalizedFulfillResponse = {\n    status: number;\n    headers: HeadersArray;\n    body: string;\n    isBase64: boolean;\n};\nexport type NormalizedContinueOverrides = {\n    url?: string;\n    method?: string;\n    headers?: HeadersArray;\n    postData?: Buffer;\n    isFallback: boolean;\n};\nexport type EmulatedSize = {\n    viewport: Size;\n    screen: Size;\n};\nexport type LaunchOptions = Omit<channels.BrowserTypeLaunchParams, 'timeout'> & {\n    cdpPort?: number;\n    proxyOverride?: ProxySettings;\n    assistantMode?: boolean;\n    socksProxyPort?: number;\n};\nexport type BrowserContextOptions = channels.BrowserNewContextOptions & {\n    proxyOverride?: ProxySettings;\n    internalIgnoreHTTPSErrors?: boolean;\n};\nexport type ProtocolLogger = (direction: 'send' | 'receive', message: object) => void;\nexport type ConsoleMessageLocation = {\n    url: string;\n    lineNumber: number;\n    columnNumber: number;\n};\n//# sourceMappingURL=types.d.ts.map",
      "server/usKeyboardLayout.d.ts": "/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport type KeyDefinition = {\n    key: string;\n    keyCode: number;\n    keyCodeWithoutLocation?: number;\n    shiftKey?: string;\n    shiftKeyCode?: number;\n    text?: string;\n    location?: number;\n};\nexport type KeyboardLayout = {\n    [s: string]: KeyDefinition;\n};\nexport declare const keypadLocation = 3;\nexport declare const USKeyboardLayout: KeyboardLayout;\n//# sourceMappingURL=usKeyboardLayout.d.ts.map",
      "server/utils/ascii.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport declare function wrapInASCIIBox(text: string, padding?: number): string;\nexport declare function jsonStringifyForceASCII(object: any): string;\n//# sourceMappingURL=ascii.d.ts.map",
      "server/utils/comparators.d.ts": "/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport type ImageComparatorOptions = {\n    threshold?: number;\n    maxDiffPixels?: number;\n    maxDiffPixelRatio?: number;\n    comparator?: string;\n};\nexport type ComparatorResult = {\n    diff?: Buffer;\n    errorMessage: string;\n} | null;\nexport type Comparator = (actualBuffer: Buffer | string, expectedBuffer: Buffer, options?: any) => ComparatorResult;\nexport declare function getComparator(mimeType: string): Comparator;\nexport declare function compareBuffersOrStrings(actualBuffer: Buffer | string, expectedBuffer: Buffer): ComparatorResult;\n//# sourceMappingURL=comparators.d.ts.map",
      "server/utils/crypto.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport declare function createGuid(): string;\nexport declare function calculateSha1(buffer: Buffer | string): string;\nexport declare function generateSelfSignedCertificate(): {\n    cert: string;\n    key: string | NonSharedBuffer;\n};\n//# sourceMappingURL=crypto.d.ts.map",
      "server/utils/debug.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport declare function debugMode(): \"\" | \"console\" | \"inspector\";\nexport declare function isUnderTest(): boolean;\n//# sourceMappingURL=debug.d.ts.map",
      "server/utils/debugLogger.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\ndeclare const debugLoggerColorMap: {\n    api: number;\n    protocol: number;\n    install: number;\n    download: number;\n    browser: number;\n    socks: number;\n    'client-certificates': number;\n    error: number;\n    channel: number;\n    server: number;\n    'server:channel': number;\n    'server:metadata': number;\n    recorder: number;\n};\nexport type LogName = keyof typeof debugLoggerColorMap;\ndeclare class DebugLogger {\n    log(name: LogName, message: string | Error | object): void;\n    isEnabled(name: LogName): boolean;\n}\nexport declare const debugLogger: DebugLogger;\nexport declare class RecentLogsCollector {\n    private _logs;\n    private _listeners;\n    log(message: string): void;\n    recentLogs(): string[];\n    onMessage(listener: (message: string) => void): void;\n}\nexport {};\n//# sourceMappingURL=debugLogger.d.ts.map",
      "server/utils/env.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport declare function getFromENV(name: string): string | undefined;\nexport declare function getAsBooleanFromENV(name: string, defaultValue?: boolean | undefined): boolean;\nexport declare function getPackageManager(): \"yarn\" | \"pnpm\" | \"npm\";\nexport declare function getPackageManagerExecCommand(): \"yarn\" | \"pnpm exec\" | \"npx\";\nexport declare function isLikelyNpxGlobal(): boolean;\nexport declare function setPlaywrightTestProcessEnv(): string;\n//# sourceMappingURL=env.d.ts.map",
      "server/utils/eventsHelper.d.ts": "/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { EventEmitter } from 'events';\nexport type RegisteredListener = {\n    emitter: EventEmitter;\n    eventName: (string | symbol);\n    handler: (...args: any[]) => void;\n};\ndeclare class EventsHelper {\n    static addEventListener(emitter: EventEmitter, eventName: (string | symbol), handler: (...args: any[]) => void): RegisteredListener;\n    static removeEventListeners(listeners: Array<{\n        emitter: EventEmitter;\n        eventName: (string | symbol);\n        handler: (...args: any[]) => void;\n    }>): void;\n}\nexport declare const eventsHelper: typeof EventsHelper;\nexport {};\n//# sourceMappingURL=eventsHelper.d.ts.map",
      "server/utils/expectUtils.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { ExpectedTextValue } from '@protocol/channels';\nexport declare function serializeExpectedTextValues(items: (string | RegExp)[], options?: {\n    matchSubstring?: boolean;\n    normalizeWhiteSpace?: boolean;\n    ignoreCase?: boolean;\n}): ExpectedTextValue[];\n//# sourceMappingURL=expectUtils.d.ts.map",
      "server/utils/fileUtils.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport declare const existsAsync: (path: string) => Promise<boolean>;\nexport declare function mkdirIfNeeded(filePath: string): Promise<void>;\nexport declare function removeFolders(dirs: string[]): Promise<(Error | undefined)[]>;\nexport declare function canAccessFile(file: string): boolean;\nexport declare function copyFileAndMakeWritable(from: string, to: string): Promise<void>;\nexport declare function sanitizeForFilePath(s: string): string;\nexport declare function toPosixPath(aPath: string): string;\ntype NameValue = {\n    name: string;\n    value: string;\n};\nexport declare class SerializedFS {\n    private _buffers;\n    private _error;\n    private _operations;\n    private _operationsDone;\n    constructor();\n    mkdir(dir: string): void;\n    writeFile(file: string, content: string | Buffer, skipIfExists?: boolean): void;\n    appendFile(file: string, text: string, flush?: boolean): void;\n    private _flushFile;\n    copyFile(from: string, to: string): void;\n    syncAndGetError(): Promise<Error>;\n    zip(entries: NameValue[], zipFileName: string): void;\n    private _appendOperation;\n    private _performOperations;\n    private _performOperation;\n}\nexport {};\n//# sourceMappingURL=fileUtils.d.ts.map",
      "server/utils/happyEyeballs.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport http from 'http';\nimport https from 'https';\nimport net from 'net';\nimport tls from 'tls';\ndeclare class HttpHappyEyeballsAgent extends http.Agent {\n    createConnection(options: http.ClientRequestArgs, oncreate?: (err: Error | null, socket?: net.Socket) => void): net.Socket | undefined;\n}\ndeclare class HttpsHappyEyeballsAgent extends https.Agent {\n    createConnection(options: http.ClientRequestArgs, oncreate?: (err: Error | null, socket?: net.Socket) => void): net.Socket | undefined;\n}\nexport declare const httpsHappyEyeballsAgent: HttpsHappyEyeballsAgent;\nexport declare const httpHappyEyeballsAgent: HttpHappyEyeballsAgent;\nexport declare function createSocket(host: string, port: number): Promise<net.Socket>;\nexport declare function createTLSSocket(options: tls.ConnectionOptions): Promise<tls.TLSSocket>;\nexport declare function createConnectionAsync(options: http.ClientRequestArgs, oncreate: ((err: Error | null, socket?: tls.TLSSocket) => void) | undefined, useTLS: true): Promise<void>;\nexport declare function createConnectionAsync(options: http.ClientRequestArgs, oncreate: ((err: Error | null, socket?: net.Socket) => void) | undefined, useTLS: false): Promise<void>;\nexport declare function timingForSocket(socket: net.Socket | tls.TLSSocket): {\n    dnsLookupAt: number | undefined;\n    tcpConnectionAt: number | undefined;\n};\nexport {};\n//# sourceMappingURL=happyEyeballs.d.ts.map",
      "server/utils/hostPlatform.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport type HostPlatform = 'win64' | 'mac10.13' | 'mac10.14' | 'mac10.15' | 'mac11' | 'mac11-arm64' | 'mac12' | 'mac12-arm64' | 'mac13' | 'mac13-arm64' | 'mac14' | 'mac14-arm64' | 'mac15' | 'mac15-arm64' | 'ubuntu18.04-x64' | 'ubuntu18.04-arm64' | 'ubuntu20.04-x64' | 'ubuntu20.04-arm64' | 'ubuntu22.04-x64' | 'ubuntu22.04-arm64' | 'ubuntu24.04-x64' | 'ubuntu24.04-arm64' | 'debian11-x64' | 'debian11-arm64' | 'debian12-x64' | 'debian12-arm64' | 'debian13-x64' | 'debian13-arm64' | '<unknown>';\nexport declare const hostPlatform: HostPlatform, isOfficiallySupportedPlatform: boolean;\nexport type ShortPlatform = 'mac-x64' | 'mac-arm64' | 'linux-x64' | 'linux-arm64' | 'win-x64' | '<unknown>';\nexport declare const shortPlatform: ShortPlatform;\n//# sourceMappingURL=hostPlatform.d.ts.map",
      "server/utils/httpServer.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type http from 'http';\nexport type ServerRouteHandler = (request: http.IncomingMessage, response: http.ServerResponse) => boolean;\nexport type Transport = {\n    sendEvent?: (method: string, params: any) => void;\n    close?: () => void;\n    onconnect: () => void;\n    dispatch: (method: string, params: any) => Promise<any>;\n    onclose: () => void;\n};\nexport declare class HttpServer {\n    private _server;\n    private _urlPrefixPrecise;\n    private _urlPrefixHumanReadable;\n    private _port;\n    private _started;\n    private _routes;\n    private _wsGuid;\n    constructor();\n    server(): http.Server<typeof http.IncomingMessage, typeof http.ServerResponse>;\n    routePrefix(prefix: string, handler: ServerRouteHandler): void;\n    routePath(path: string, handler: ServerRouteHandler): void;\n    port(): number;\n    private _tryStart;\n    createWebSocket(transport: Transport, guid?: string): void;\n    wsGuid(): string | undefined;\n    start(options?: {\n        port?: number;\n        preferredPort?: number;\n        host?: string;\n    }): Promise<void>;\n    stop(): Promise<void>;\n    urlPrefix(purpose: 'human-readable' | 'precise'): string;\n    serveFile(request: http.IncomingMessage, response: http.ServerResponse, absoluteFilePath: string, headers?: {\n        [name: string]: string;\n    }): boolean;\n    _serveFile(response: http.ServerResponse, absoluteFilePath: string): void;\n    _serveRangeFile(request: http.IncomingMessage, response: http.ServerResponse, absoluteFilePath: string): http.ServerResponse<http.IncomingMessage>;\n    private _onRequest;\n}\n//# sourceMappingURL=httpServer.d.ts.map",
      "server/utils/imageUtils.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport type ImageData = {\n    width: number;\n    height: number;\n    data: Buffer;\n};\nexport declare function padImageToSize(image: ImageData, size: {\n    width: number;\n    height: number;\n}): ImageData;\nexport declare function scaleImageToSize(image: ImageData, size: {\n    width: number;\n    height: number;\n}): ImageData;\n//# sourceMappingURL=imageUtils.d.ts.map",
      "server/utils/image_tools/colorUtils.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport declare function blendWithWhite(c: number, a: number): number;\nexport declare function rgb2gray(r: number, g: number, b: number): number;\nexport declare function colorDeltaE94(rgb1: number[], rgb2: number[]): number;\nexport declare function srgb2xyz(rgb: number[]): number[];\nexport declare function xyz2lab(xyz: number[]): number[];\n//# sourceMappingURL=colorUtils.d.ts.map",
      "server/utils/image_tools/compare.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\ntype CompareOptions = {\n    maxColorDeltaE94?: number;\n};\nexport declare function compare(actual: Buffer, expected: Buffer, diff: Buffer | null, width: number, height: number, options?: CompareOptions): number;\nexport {};\n//# sourceMappingURL=compare.d.ts.map",
      "server/utils/image_tools/imageChannel.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport type PaddingOptions = {\n    paddingSize?: number;\n    paddingColorOdd?: number[];\n    paddingColorEven?: number[];\n};\nexport declare class ImageChannel {\n    data: Uint8Array;\n    width: number;\n    height: number;\n    static intoRGB(width: number, height: number, data: Buffer, options?: PaddingOptions): ImageChannel[];\n    constructor(width: number, height: number, data: Uint8Array);\n    get(x: number, y: number): number;\n    boundXY(x: number, y: number): number[];\n}\n//# sourceMappingURL=imageChannel.d.ts.map",
      "server/utils/image_tools/stats.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { ImageChannel } from './imageChannel';\nexport interface Stats {\n    c1: ImageChannel;\n    c2: ImageChannel;\n    meanC1(x1: number, y1: number, x2: number, y2: number): number;\n    meanC2(x1: number, y1: number, x2: number, y2: number): number;\n    varianceC1(x1: number, y1: number, x2: number, y2: number): number;\n    varianceC2(x1: number, y1: number, x2: number, y2: number): number;\n    covariance(x1: number, y1: number, x2: number, y2: number): number;\n}\nexport declare function ssim(stats: Stats, x1: number, y1: number, x2: number, y2: number): number;\nexport declare class FastStats implements Stats {\n    c1: ImageChannel;\n    c2: ImageChannel;\n    private _partialSumC1;\n    private _partialSumC2;\n    private _partialSumMult;\n    private _partialSumSq1;\n    private _partialSumSq2;\n    constructor(c1: ImageChannel, c2: ImageChannel);\n    _sum(partialSum: number[], x1: number, y1: number, x2: number, y2: number): number;\n    meanC1(x1: number, y1: number, x2: number, y2: number): number;\n    meanC2(x1: number, y1: number, x2: number, y2: number): number;\n    varianceC1(x1: number, y1: number, x2: number, y2: number): number;\n    varianceC2(x1: number, y1: number, x2: number, y2: number): number;\n    covariance(x1: number, y1: number, x2: number, y2: number): number;\n}\n//# sourceMappingURL=stats.d.ts.map",
      "server/utils/linuxUtils.d.ts": "/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport declare function getLinuxDistributionInfoSync(): {\n    id: string;\n    version: string;\n} | undefined;\n//# sourceMappingURL=linuxUtils.d.ts.map",
      "server/utils/network.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport http from 'http';\nimport http2 from 'http2';\nimport https from 'https';\nimport type { ProxySettings } from '../types';\nimport type { Progress } from '../progress';\nexport type HTTPRequestParams = {\n    url: string;\n    method?: string;\n    headers?: http.OutgoingHttpHeaders;\n    data?: string | Buffer;\n    rejectUnauthorized?: boolean;\n    socketTimeout?: number;\n};\nexport declare const NET_DEFAULT_TIMEOUT = 30000;\nexport declare function httpRequest(params: HTTPRequestParams, onResponse: (r: http.IncomingMessage) => void, onError: (error: Error) => void): {\n    cancel(error: Error | undefined): void;\n};\nexport declare function fetchData(progress: Progress | undefined, params: HTTPRequestParams, onError?: (params: HTTPRequestParams, response: http.IncomingMessage) => Promise<Error>): Promise<string>;\nexport declare function createProxyAgent(proxy?: ProxySettings, forUrl?: URL): any;\nexport declare function createHttpServer(requestListener?: (req: http.IncomingMessage, res: http.ServerResponse) => void): http.Server;\nexport declare function createHttpServer(options: http.ServerOptions, requestListener?: (req: http.IncomingMessage, res: http.ServerResponse) => void): http.Server;\nexport declare function createHttpsServer(requestListener?: (req: http.IncomingMessage, res: http.ServerResponse) => void): https.Server;\nexport declare function createHttpsServer(options: https.ServerOptions, requestListener?: (req: http.IncomingMessage, res: http.ServerResponse) => void): https.Server;\nexport declare function createHttp2Server(onRequestHandler?: (request: http2.Http2ServerRequest, response: http2.Http2ServerResponse) => void): http2.Http2SecureServer;\nexport declare function createHttp2Server(options: http2.SecureServerOptions, onRequestHandler?: (request: http2.Http2ServerRequest, response: http2.Http2ServerResponse) => void): http2.Http2SecureServer;\nexport declare function isURLAvailable(url: URL, ignoreHTTPSErrors: boolean, onLog?: (data: string) => void, onStdErr?: (data: string) => void): Promise<boolean>;\n//# sourceMappingURL=network.d.ts.map",
      "server/utils/nodePlatform.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { Platform } from '../../client/platform';\nexport declare function setBoxedStackPrefixes(prefixes: string[]): void;\nexport declare const nodePlatform: Platform;\n//# sourceMappingURL=nodePlatform.d.ts.map",
      "server/utils/pipeTransport.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\ninterface WritableStream {\n    write(data: Buffer): void;\n}\ninterface ReadableStream {\n    on(event: 'data', callback: (b: Buffer) => void): void;\n    on(event: 'close', callback: () => void): void;\n}\ninterface ClosableStream {\n    close(): void;\n}\nexport declare class PipeTransport {\n    private _pipeWrite;\n    private _data;\n    private _waitForNextTask;\n    private _closed;\n    private _bytesLeft;\n    onmessage?: (message: string) => void;\n    onclose?: () => void;\n    private _endian;\n    private _closeableStream;\n    constructor(pipeWrite: WritableStream, pipeRead: ReadableStream, closeable?: ClosableStream, endian?: 'be' | 'le');\n    send(message: string): void;\n    close(): void;\n    _dispatch(buffer: Buffer): void;\n}\nexport {};\n//# sourceMappingURL=pipeTransport.d.ts.map",
      "server/utils/processLauncher.d.ts": "/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as childProcess from 'child_process';\nexport type LaunchProcessOptions = {\n    command: string;\n    args?: string[];\n    env?: NodeJS.ProcessEnv;\n    shell?: boolean;\n    handleSIGINT?: boolean;\n    handleSIGTERM?: boolean;\n    handleSIGHUP?: boolean;\n    stdio: 'pipe' | 'stdin';\n    tempDirectories: string[];\n    cwd?: string;\n    attemptToGracefullyClose: () => Promise<any>;\n    onExit: (exitCode: number | null, signal: string | null) => void;\n    log: (message: string) => void;\n};\ntype LaunchResult = {\n    launchedProcess: childProcess.ChildProcess;\n    gracefullyClose: () => Promise<void>;\n    kill: () => Promise<void>;\n};\nexport declare const gracefullyCloseSet: Set<() => Promise<void>>;\nexport declare function gracefullyCloseAll(): Promise<void>;\nexport declare function gracefullyProcessExitDoNotHang(code: number): void;\nexport declare function launchProcess(options: LaunchProcessOptions): Promise<LaunchResult>;\nexport declare function envArrayToObject(env: {\n    name: string;\n    value: string;\n}[]): NodeJS.ProcessEnv;\nexport {};\n//# sourceMappingURL=processLauncher.d.ts.map",
      "server/utils/profiler.d.ts": "/**\n * Copyright Microsoft Corporation. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport declare function startProfiling(): Promise<void>;\nexport declare function stopProfiling(profileName: string): Promise<void>;\n//# sourceMappingURL=profiler.d.ts.map",
      "server/utils/socksProxy.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport EventEmitter from 'events';\nexport type SocksSocketRequestedPayload = {\n    uid: string;\n    host: string;\n    port: number;\n};\nexport type SocksSocketConnectedPayload = {\n    uid: string;\n    host: string;\n    port: number;\n};\nexport type SocksSocketDataPayload = {\n    uid: string;\n    data: Buffer;\n};\nexport type SocksSocketErrorPayload = {\n    uid: string;\n    error: string;\n};\nexport type SocksSocketFailedPayload = {\n    uid: string;\n    errorCode: string;\n};\nexport type SocksSocketClosedPayload = {\n    uid: string;\n};\nexport type SocksSocketEndPayload = {\n    uid: string;\n};\ninterface SocksConnectionClient {\n    onSocketRequested(payload: SocksSocketRequestedPayload): void;\n    onSocketData(payload: SocksSocketDataPayload): void;\n    onSocketClosed(payload: SocksSocketClosedPayload): void;\n}\ntype PatternMatcher = (host: string, port: number) => boolean;\nexport declare function parsePattern(pattern: string | undefined): PatternMatcher;\nexport declare class SocksProxy extends EventEmitter implements SocksConnectionClient {\n    static Events: {\n        SocksRequested: string;\n        SocksData: string;\n        SocksClosed: string;\n    };\n    private _server;\n    private _connections;\n    private _sockets;\n    private _closed;\n    private _port;\n    private _patternMatcher;\n    private _directSockets;\n    constructor();\n    setPattern(pattern: string | undefined): void;\n    private _handleDirect;\n    port(): number;\n    listen(port: number, hostname?: string): Promise<number>;\n    close(): Promise<void>;\n    onSocketRequested(payload: SocksSocketRequestedPayload): void;\n    onSocketData(payload: SocksSocketDataPayload): void;\n    onSocketClosed(payload: SocksSocketClosedPayload): void;\n    socketConnected({ uid, host, port }: SocksSocketConnectedPayload): void;\n    socketFailed({ uid, errorCode }: SocksSocketFailedPayload): void;\n    sendSocketData({ uid, data }: SocksSocketDataPayload): void;\n    sendSocketEnd({ uid }: SocksSocketEndPayload): void;\n    sendSocketError({ uid, error }: SocksSocketErrorPayload): void;\n}\nexport declare class SocksProxyHandler extends EventEmitter {\n    static Events: {\n        SocksConnected: string;\n        SocksData: string;\n        SocksError: string;\n        SocksFailed: string;\n        SocksEnd: string;\n    };\n    private _sockets;\n    private _patternMatcher;\n    private _redirectPortForTest;\n    constructor(pattern: string | undefined, redirectPortForTest?: number);\n    cleanup(): void;\n    socketRequested({ uid, host, port }: SocksSocketRequestedPayload): Promise<void>;\n    sendSocketData({ uid, data }: SocksSocketDataPayload): void;\n    socketClosed({ uid }: SocksSocketClosedPayload): void;\n}\nexport {};\n//# sourceMappingURL=socksProxy.d.ts.map",
      "server/utils/spawnAsync.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { SpawnOptions } from 'child_process';\nexport declare function spawnAsync(cmd: string, args: string[], options?: SpawnOptions): Promise<{\n    stdout: string;\n    stderr: string;\n    code: number | null;\n    error?: Error;\n}>;\n//# sourceMappingURL=spawnAsync.d.ts.map",
      "server/utils/task.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport declare function makeWaitForNextTask(): (callback: () => void) => void;\n//# sourceMappingURL=task.d.ts.map",
      "server/utils/userAgent.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport declare function getUserAgent(): string;\nexport declare function getEmbedderName(): {\n    embedderName: string;\n    embedderVersion: string;\n};\nexport declare function getPlaywrightVersion(majorMinorOnly?: boolean): string;\n//# sourceMappingURL=userAgent.d.ts.map",
      "server/utils/wsServer.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { WebSocket } from '../../utilsBundle';\nimport type http from 'http';\nimport type stream from 'stream';\nexport declare const perMessageDeflate: {\n    serverNoContextTakeover: boolean;\n    zlibDeflateOptions: {\n        level: number;\n    };\n    zlibInflateOptions: {\n        chunkSize: number;\n    };\n    threshold: number;\n};\nexport type WSConnection = {\n    close: () => Promise<void>;\n};\nexport type WSServerDelegate = {\n    onRequest: (request: http.IncomingMessage, response: http.ServerResponse) => void;\n    onHeaders: (headers: string[]) => void;\n    onUpgrade: (request: http.IncomingMessage, socket: stream.Duplex) => {\n        error: string;\n    } | undefined;\n    onConnection: (request: http.IncomingMessage, url: URL, ws: WebSocket, id: string) => WSConnection;\n};\nexport declare class WSServer {\n    private _wsServer;\n    server: http.Server | undefined;\n    private _delegate;\n    constructor(delegate: WSServerDelegate);\n    listen(port: number, hostname: string | undefined, path: string): Promise<string>;\n    close(): Promise<void>;\n}\n//# sourceMappingURL=wsServer.d.ts.map",
      "server/utils/zipFile.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport declare class ZipFile {\n    private _fileName;\n    private _zipFile;\n    private _entries;\n    private _openedPromise;\n    constructor(fileName: string);\n    private _open;\n    entries(): Promise<string[]>;\n    read(entryPath: string): Promise<Buffer>;\n    close(): void;\n}\n//# sourceMappingURL=zipFile.d.ts.map",
      "server/utils/zones.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { AsyncLocalStorage } from 'async_hooks';\nexport type ZoneType = 'apiZone' | 'stepZone';\nexport declare class Zone {\n    private readonly _asyncLocalStorage;\n    private readonly _data;\n    constructor(asyncLocalStorage: AsyncLocalStorage<Zone | undefined>, store: Map<ZoneType, unknown>);\n    with(type: ZoneType, data: unknown): Zone;\n    without(type?: ZoneType): Zone;\n    run<R>(func: () => R): R;\n    data<T>(type: ZoneType): T | undefined;\n}\nexport declare const emptyZone: Zone;\nexport declare function currentZone(): Zone;\n//# sourceMappingURL=zones.d.ts.map",
      "server/webkit/webkit.d.ts": "/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { BrowserType } from '../browserType';\nimport { WKBrowser } from '../webkit/wkBrowser';\nimport type { BrowserOptions } from '../browser';\nimport type { SdkObject } from '../instrumentation';\nimport type { ProtocolError } from '../protocolError';\nimport type { ConnectionTransport } from '../transport';\nimport type * as types from '../types';\nexport declare class WebKit extends BrowserType {\n    constructor(parent: SdkObject);\n    connectToTransport(transport: ConnectionTransport, options: BrowserOptions): Promise<WKBrowser>;\n    amendEnvironment(env: NodeJS.ProcessEnv, userDataDir: string, isPersistent: boolean, options: types.LaunchOptions): NodeJS.ProcessEnv;\n    doRewriteStartupLog(error: ProtocolError): ProtocolError;\n    attemptToGracefullyCloseBrowser(transport: ConnectionTransport): void;\n    defaultArgs(options: types.LaunchOptions, isPersistent: boolean, userDataDir: string): Promise<string[]>;\n}\nexport declare function translatePathToWSL(path: string): Promise<string>;\n//# sourceMappingURL=webkit.d.ts.map",
      "server/webkit/wkBrowser.d.ts": "/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Browser } from '../browser';\nimport { BrowserContext } from '../browserContext';\nimport { WKSession } from './wkConnection';\nimport { WKPage } from './wkPage';\nimport type { BrowserOptions } from '../browser';\nimport type { SdkObject } from '../instrumentation';\nimport type { InitScript, Page } from '../page';\nimport type { ConnectionTransport } from '../transport';\nimport type * as types from '../types';\nimport type { Protocol } from './protocol';\nimport type { PageProxyMessageReceivedPayload } from './wkConnection';\nimport type * as channels from '@protocol/channels';\nexport declare class WKBrowser extends Browser {\n    private readonly _connection;\n    readonly _browserSession: WKSession;\n    readonly _contexts: Map<string, WKBrowserContext>;\n    readonly _wkPages: Map<string, WKPage>;\n    static connect(parent: SdkObject, transport: ConnectionTransport, options: BrowserOptions): Promise<WKBrowser>;\n    constructor(parent: SdkObject, transport: ConnectionTransport, options: BrowserOptions);\n    _onDisconnect(): void;\n    doCreateNewContext(options: types.BrowserContextOptions): Promise<BrowserContext>;\n    contexts(): BrowserContext[];\n    version(): string;\n    userAgent(): string;\n    _onDownloadCreated(payload: Protocol.Playwright.downloadCreatedPayload): void;\n    _onDownloadFilenameSuggested(payload: Protocol.Playwright.downloadFilenameSuggestedPayload): void;\n    _onDownloadFinished(payload: Protocol.Playwright.downloadFinishedPayload): void;\n    _onScreencastFinished(payload: Protocol.Playwright.screencastFinishedPayload): void;\n    _onPageProxyCreated(event: Protocol.Playwright.pageProxyCreatedPayload): void;\n    _onPageProxyDestroyed(event: Protocol.Playwright.pageProxyDestroyedPayload): void;\n    _onPageProxyMessageReceived(event: PageProxyMessageReceivedPayload): void;\n    _onProvisionalLoadFailed(event: Protocol.Playwright.provisionalLoadFailedPayload): void;\n    _onWindowOpen(event: Protocol.Playwright.windowOpenPayload): void;\n    isConnected(): boolean;\n}\nexport declare class WKBrowserContext extends BrowserContext {\n    readonly _browser: WKBrowser;\n    constructor(browser: WKBrowser, browserContextId: string | undefined, options: types.BrowserContextOptions);\n    _initialize(): Promise<void>;\n    _wkPages(): WKPage[];\n    possiblyUninitializedPages(): Page[];\n    doCreateNewPage(): Promise<Page>;\n    doGetCookies(urls: string[]): Promise<channels.NetworkCookie[]>;\n    addCookies(cookies: channels.SetNetworkCookie[]): Promise<void>;\n    doClearCookies(): Promise<void>;\n    doGrantPermissions(origin: string, permissions: string[]): Promise<void>;\n    doClearPermissions(): Promise<void>;\n    setGeolocation(geolocation?: types.Geolocation): Promise<void>;\n    doUpdateExtraHTTPHeaders(): Promise<void>;\n    setUserAgent(userAgent: string | undefined): Promise<void>;\n    doUpdateOffline(): Promise<void>;\n    doSetHTTPCredentials(httpCredentials?: types.Credentials): Promise<void>;\n    doAddInitScript(initScript: InitScript): Promise<void>;\n    doRemoveInitScripts(initScripts: InitScript[]): Promise<void>;\n    doUpdateRequestInterception(): Promise<void>;\n    doUpdateDefaultViewport(): Promise<void>;\n    doUpdateDefaultEmulatedMedia(): Promise<void>;\n    doExposePlaywrightBinding(): Promise<void>;\n    onClosePersistent(): void;\n    clearCache(): Promise<void>;\n    doClose(reason: string | undefined): Promise<void>;\n    cancelDownload(uuid: string): Promise<void>;\n    _validateEmulatedViewport(viewportSize: types.Size | undefined): void;\n}\n//# sourceMappingURL=wkBrowser.d.ts.map",
      "server/webkit/wkConnection.d.ts": "/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { EventEmitter } from 'events';\nimport type { ConnectionTransport, ProtocolRequest } from '../transport';\nimport type { Protocol } from './protocol';\nimport type { RecentLogsCollector } from '../utils/debugLogger';\nimport type { ProtocolLogger } from '../types';\nexport declare const kBrowserCloseMessageId = -9999;\nexport declare const kPageProxyMessageReceived: unique symbol;\nexport type PageProxyMessageReceivedPayload = {\n    pageProxyId: string;\n    message: any;\n};\nexport declare class WKConnection {\n    private readonly _transport;\n    private readonly _onDisconnect;\n    private readonly _protocolLogger;\n    private readonly _browserLogsCollector;\n    _browserDisconnectedLogs: string | undefined;\n    private _lastId;\n    private _closed;\n    readonly browserSession: WKSession;\n    constructor(transport: ConnectionTransport, onDisconnect: () => void, protocolLogger: ProtocolLogger, browserLogsCollector: RecentLogsCollector);\n    nextMessageId(): number;\n    rawSend(message: ProtocolRequest): void;\n    private _dispatchMessage;\n    _onClose(reason?: string): void;\n    isClosed(): boolean;\n    close(): void;\n}\nexport declare class WKSession extends EventEmitter {\n    connection: WKConnection;\n    readonly sessionId: string;\n    private _disposed;\n    private readonly _rawSend;\n    private readonly _callbacks;\n    private _crashed;\n    on: <T extends keyof Protocol.Events | symbol>(event: T, listener: (payload: T extends symbol ? any : Protocol.Events[T extends keyof Protocol.Events ? T : never]) => void) => this;\n    addListener: <T extends keyof Protocol.Events | symbol>(event: T, listener: (payload: T extends symbol ? any : Protocol.Events[T extends keyof Protocol.Events ? T : never]) => void) => this;\n    off: <T extends keyof Protocol.Events | symbol>(event: T, listener: (payload: T extends symbol ? any : Protocol.Events[T extends keyof Protocol.Events ? T : never]) => void) => this;\n    removeListener: <T extends keyof Protocol.Events | symbol>(event: T, listener: (payload: T extends symbol ? any : Protocol.Events[T extends keyof Protocol.Events ? T : never]) => void) => this;\n    once: <T extends keyof Protocol.Events | symbol>(event: T, listener: (payload: T extends symbol ? any : Protocol.Events[T extends keyof Protocol.Events ? T : never]) => void) => this;\n    constructor(connection: WKConnection, sessionId: string, rawSend: (message: any) => void);\n    send<T extends keyof Protocol.CommandParameters>(method: T, params?: Protocol.CommandParameters[T]): Promise<Protocol.CommandReturnValues[T]>;\n    sendMayFail<T extends keyof Protocol.CommandParameters>(method: T, params?: Protocol.CommandParameters[T]): Promise<Protocol.CommandReturnValues[T] | void>;\n    markAsCrashed(): void;\n    isDisposed(): boolean;\n    dispose(): void;\n    dispatchMessage(object: any): void;\n}\n//# sourceMappingURL=wkConnection.d.ts.map",
      "server/webkit/wkExecutionContext.d.ts": "/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as js from '../javascript';\nimport type { Protocol } from './protocol';\nimport type { WKSession } from './wkConnection';\nexport declare class WKExecutionContext implements js.ExecutionContextDelegate {\n    private readonly _session;\n    readonly _contextId: number | undefined;\n    constructor(session: WKSession, contextId: number | undefined);\n    rawEvaluateJSON(expression: string): Promise<any>;\n    rawEvaluateHandle(context: js.ExecutionContext, expression: string): Promise<js.JSHandle>;\n    evaluateWithArguments(expression: string, returnByValue: boolean, utilityScript: js.JSHandle<any>, values: any[], handles: js.JSHandle[]): Promise<any>;\n    getProperties(object: js.JSHandle): Promise<Map<string, js.JSHandle>>;\n    releaseHandle(handle: js.JSHandle): Promise<void>;\n}\nexport declare function createHandle(context: js.ExecutionContext, remoteObject: Protocol.Runtime.RemoteObject): js.JSHandle;\n//# sourceMappingURL=wkExecutionContext.d.ts.map",
      "server/webkit/wkInput.d.ts": "/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as input from '../input';\nimport type * as types from '../types';\nimport type { WKSession } from './wkConnection';\nimport type { Page } from '../page';\nimport type { Progress } from '../progress';\nexport declare class RawKeyboardImpl implements input.RawKeyboard {\n    private readonly _pageProxySession;\n    private _session?;\n    constructor(session: WKSession);\n    setSession(session: WKSession): void;\n    keydown(progress: Progress, modifiers: Set<types.KeyboardModifier>, keyName: string, description: input.KeyDescription, autoRepeat: boolean): Promise<void>;\n    keyup(progress: Progress, modifiers: Set<types.KeyboardModifier>, keyName: string, description: input.KeyDescription): Promise<void>;\n    sendText(progress: Progress, text: string): Promise<void>;\n}\nexport declare class RawMouseImpl implements input.RawMouse {\n    private readonly _pageProxySession;\n    private _session?;\n    private _page?;\n    constructor(session: WKSession);\n    setSession(session: WKSession): void;\n    move(progress: Progress, x: number, y: number, button: types.MouseButton | 'none', buttons: Set<types.MouseButton>, modifiers: Set<types.KeyboardModifier>, forClick: boolean): Promise<void>;\n    down(progress: Progress, x: number, y: number, button: types.MouseButton, buttons: Set<types.MouseButton>, modifiers: Set<types.KeyboardModifier>, clickCount: number): Promise<void>;\n    up(progress: Progress, x: number, y: number, button: types.MouseButton, buttons: Set<types.MouseButton>, modifiers: Set<types.KeyboardModifier>, clickCount: number): Promise<void>;\n    wheel(progress: Progress, x: number, y: number, buttons: Set<types.MouseButton>, modifiers: Set<types.KeyboardModifier>, deltaX: number, deltaY: number): Promise<void>;\n    setPage(page: Page): void;\n}\nexport declare class RawTouchscreenImpl implements input.RawTouchscreen {\n    private readonly _pageProxySession;\n    constructor(session: WKSession);\n    tap(progress: Progress, x: number, y: number, modifiers: Set<types.KeyboardModifier>): Promise<void>;\n}\n//# sourceMappingURL=wkInput.d.ts.map",
      "server/webkit/wkInterceptableRequest.d.ts": "/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as network from '../network';\nimport type * as frames from '../frames';\nimport type * as types from '../types';\nimport type { Protocol } from './protocol';\nimport type { WKSession } from './wkConnection';\nexport declare class WKInterceptableRequest {\n    private _session;\n    private _requestId;\n    readonly request: network.Request;\n    _timestamp: number;\n    _wallTime: number;\n    constructor(session: WKSession, frame: frames.Frame, event: Protocol.Network.requestWillBeSentPayload, redirectedFrom: WKInterceptableRequest | null, documentId: string | undefined);\n    adoptRequestFromNewProcess(newSession: WKSession, requestId: string): void;\n    createResponse(responsePayload: Protocol.Network.Response): network.Response;\n}\nexport declare class WKRouteImpl implements network.RouteDelegate {\n    private readonly _session;\n    private readonly _requestId;\n    constructor(session: WKSession, requestId: string);\n    abort(errorCode: string): Promise<void>;\n    fulfill(response: types.NormalizedFulfillResponse): Promise<void>;\n    continue(overrides: types.NormalizedContinueOverrides): Promise<void>;\n}\n//# sourceMappingURL=wkInterceptableRequest.d.ts.map",
      "server/webkit/wkPage.d.ts": "/**\n * Copyright 2017 Google Inc. All rights reserved.\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as dom from '../dom';\nimport * as network from '../network';\nimport { Page } from '../page';\nimport { WKSession } from './wkConnection';\nimport { RawKeyboardImpl, RawMouseImpl, RawTouchscreenImpl } from './wkInput';\nimport type { Protocol } from './protocol';\nimport type { WKBrowserContext } from './wkBrowser';\nimport type * as frames from '../frames';\nimport type { InitScript, PageDelegate } from '../page';\nimport type { Progress } from '../progress';\nimport type * as types from '../types';\nexport declare class WKPage implements PageDelegate {\n    readonly rawMouse: RawMouseImpl;\n    readonly rawKeyboard: RawKeyboardImpl;\n    readonly rawTouchscreen: RawTouchscreenImpl;\n    _session: WKSession;\n    private _provisionalPage;\n    readonly _page: Page;\n    private readonly _pageProxySession;\n    readonly _opener: WKPage | null;\n    private readonly _requestIdToRequest;\n    private readonly _requestIdToRequestWillBeSentEvent;\n    private readonly _workers;\n    private readonly _contextIdToContext;\n    private _sessionListeners;\n    private _eventListeners;\n    readonly _browserContext: WKBrowserContext;\n    private _firstNonInitialNavigationCommittedPromise;\n    private _firstNonInitialNavigationCommittedFulfill;\n    _firstNonInitialNavigationCommittedReject: (e: Error) => void;\n    private _lastConsoleMessage;\n    private readonly _requestIdToResponseReceivedPayloadEvent;\n    private _nextWindowOpenPopupFeatures?;\n    private _recordingVideoFile;\n    private _screencastGeneration;\n    constructor(browserContext: WKBrowserContext, pageProxySession: WKSession, opener: WKPage | null);\n    private _initializePageProxySession;\n    private _setSession;\n    _initializeSession(session: WKSession, provisional: boolean, resourceTreeHandler: (r: Protocol.Page.getResourceTreeReturnValue) => void): Promise<void>;\n    private _initializeSessionMayThrow;\n    private _onDidCommitProvisionalTarget;\n    private _onTargetDestroyed;\n    didClose(): void;\n    dispatchMessageToSession(message: any): void;\n    handleProvisionalLoadFailed(event: Protocol.Playwright.provisionalLoadFailedPayload): void;\n    handleWindowOpen(event: Protocol.Playwright.windowOpenPayload): void;\n    private _onTargetCreated;\n    private _onDispatchMessageFromTarget;\n    private _addSessionListeners;\n    private _updateState;\n    private _forAllSessions;\n    private _onWillCheckNavigationPolicy;\n    private _onDidCheckNavigationPolicy;\n    private _handleFrameTree;\n    _onFrameAttached(frameId: string, parentFrameId: string | null): frames.Frame;\n    private _onFrameNavigated;\n    private _onFrameNavigatedWithinDocument;\n    private _onFrameDetached;\n    private _removeContextsForFrame;\n    private _onExecutionContextCreated;\n    private _onBindingCalled;\n    navigateFrame(frame: frames.Frame, url: string, referrer: string | undefined): Promise<frames.GotoResult>;\n    private _onConsoleMessage;\n    _onConsoleRepeatCountUpdated(event: Protocol.Console.messageRepeatCountUpdatedPayload): void;\n    _onDialog(event: Protocol.Dialog.javascriptDialogOpeningPayload): void;\n    private _onFileChooserOpened;\n    private static _setEmulateMedia;\n    updateExtraHTTPHeaders(): Promise<void>;\n    _calculateExtraHTTPHeaders(): types.HeadersArray;\n    updateEmulateMedia(): Promise<void>;\n    updateEmulatedViewportSize(): Promise<void>;\n    updateUserAgent(): Promise<void>;\n    bringToFront(): Promise<void>;\n    _updateViewport(): Promise<void>;\n    updateRequestInterception(): Promise<void>;\n    updateOffline(): Promise<void>;\n    updateHttpCredentials(): Promise<void>;\n    updateFileChooserInterception(): Promise<void>;\n    reload(): Promise<void>;\n    goBack(): Promise<boolean>;\n    goForward(): Promise<boolean>;\n    requestGC(): Promise<void>;\n    addInitScript(initScript: InitScript): Promise<void>;\n    removeInitScripts(initScripts: InitScript[]): Promise<void>;\n    exposePlaywrightBinding(): Promise<void>;\n    private _calculateBootstrapScript;\n    private _publicKeyCredentialScript;\n    _updateBootstrapScript(): Promise<void>;\n    closePage(runBeforeUnload: boolean): Promise<void>;\n    setBackgroundColor(color?: {\n        r: number;\n        g: number;\n        b: number;\n        a: number;\n    }): Promise<void>;\n    private _toolbarHeight;\n    private _startVideo;\n    _stopVideo(): Promise<void>;\n    private validateScreenshotDimension;\n    takeScreenshot(progress: Progress, format: string, documentRect: types.Rect | undefined, viewportRect: types.Rect | undefined, quality: number | undefined, fitsViewport: boolean, scale: 'css' | 'device'): Promise<Buffer>;\n    getContentFrame(handle: dom.ElementHandle): Promise<frames.Frame | null>;\n    getOwnerFrame(handle: dom.ElementHandle): Promise<string | null>;\n    getBoundingBox(handle: dom.ElementHandle): Promise<types.Rect | null>;\n    scrollRectIntoViewIfNeeded(handle: dom.ElementHandle, rect?: types.Rect): Promise<'error:notvisible' | 'error:notconnected' | 'done'>;\n    setScreencastOptions(options: {\n        width: number;\n        height: number;\n        quality: number;\n    } | null): Promise<void>;\n    private _onScreencastFrame;\n    rafCountForStablePosition(): number;\n    getContentQuads(handle: dom.ElementHandle): Promise<types.Quad[] | null>;\n    setInputFilePaths(handle: dom.ElementHandle<HTMLInputElement>, paths: string[]): Promise<void>;\n    adoptElementHandle<T extends Node>(handle: dom.ElementHandle<T>, to: dom.FrameExecutionContext): Promise<dom.ElementHandle<T>>;\n    inputActionEpilogue(): Promise<void>;\n    resetForReuse(progress: Progress): Promise<void>;\n    getFrameElement(frame: frames.Frame): Promise<dom.ElementHandle>;\n    private _maybeCancelCoopNavigationRequest;\n    _adoptRequestFromNewProcess(navigationRequest: network.Request, newSession: WKSession, newRequestId: string): void;\n    _onRequestWillBeSent(session: WKSession, event: Protocol.Network.requestWillBeSentPayload): void;\n    private _onRequest;\n    private _handleRequestRedirect;\n    _onRequestIntercepted(session: WKSession, event: Protocol.Network.requestInterceptedPayload): void;\n    _onResponseReceived(session: WKSession, event: Protocol.Network.responseReceivedPayload): void;\n    _onLoadingFinished(event: Protocol.Network.loadingFinishedPayload): void;\n    _onLoadingFailed(session: WKSession, event: Protocol.Network.loadingFailedPayload): void;\n    _grantPermissions(origin: string, permissions: string[]): Promise<void>;\n    _clearPermissions(): Promise<void>;\n    shouldToggleStyleSheetToSyncAnimations(): boolean;\n}\n//# sourceMappingURL=wkPage.d.ts.map",
      "server/webkit/wkProvisionalPage.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { WKSession } from './wkConnection';\nimport type { WKPage } from './wkPage';\nimport type * as network from '../network';\nexport declare class WKProvisionalPage {\n    readonly _session: WKSession;\n    private readonly _wkPage;\n    private _coopNavigationRequest;\n    private _sessionListeners;\n    private _mainFrameId;\n    readonly initializationPromise: Promise<void>;\n    constructor(session: WKSession, page: WKPage);\n    coopNavigationRequest(): network.Request | undefined;\n    dispose(): void;\n    commit(): void;\n    private _onRequestWillBeSent;\n    private _onLoadingFinished;\n    private _onLoadingFailed;\n    private _handleFrameTree;\n}\n//# sourceMappingURL=wkProvisionalPage.d.ts.map",
      "server/webkit/wkWorkers.d.ts": "/**\n * Copyright 2019 Microsoft Corporation All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Worker } from '../page';\nimport { WKSession } from './wkConnection';\nimport type { Protocol } from './protocol';\nimport type { Page } from '../page';\nexport declare class WKWorkers {\n    private _sessionListeners;\n    private _page;\n    private _workerSessions;\n    constructor(page: Page);\n    setSession(session: WKSession): void;\n    clear(): void;\n    initializeSession(session: WKSession): Promise<void>;\n    _onConsoleMessage(worker: Worker, event: Protocol.Console.messageAddedPayload): Promise<void>;\n}\n//# sourceMappingURL=wkWorkers.d.ts.map",
      "utils/isomorphic/ariaSnapshot.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport type AriaRole = 'alert' | 'alertdialog' | 'application' | 'article' | 'banner' | 'blockquote' | 'button' | 'caption' | 'cell' | 'checkbox' | 'code' | 'columnheader' | 'combobox' | 'complementary' | 'contentinfo' | 'definition' | 'deletion' | 'dialog' | 'directory' | 'document' | 'emphasis' | 'feed' | 'figure' | 'form' | 'generic' | 'grid' | 'gridcell' | 'group' | 'heading' | 'img' | 'insertion' | 'link' | 'list' | 'listbox' | 'listitem' | 'log' | 'main' | 'mark' | 'marquee' | 'math' | 'meter' | 'menu' | 'menubar' | 'menuitem' | 'menuitemcheckbox' | 'menuitemradio' | 'navigation' | 'none' | 'note' | 'option' | 'paragraph' | 'presentation' | 'progressbar' | 'radio' | 'radiogroup' | 'region' | 'row' | 'rowgroup' | 'rowheader' | 'scrollbar' | 'search' | 'searchbox' | 'separator' | 'slider' | 'spinbutton' | 'status' | 'strong' | 'subscript' | 'superscript' | 'switch' | 'tab' | 'table' | 'tablist' | 'tabpanel' | 'term' | 'textbox' | 'time' | 'timer' | 'toolbar' | 'tooltip' | 'tree' | 'treegrid' | 'treeitem';\nexport type AriaProps = {\n    checked?: boolean | 'mixed';\n    disabled?: boolean;\n    expanded?: boolean;\n    active?: boolean;\n    level?: number;\n    pressed?: boolean | 'mixed';\n    selected?: boolean;\n};\nexport declare function ariaPropsEqual(a: AriaProps, b: AriaProps): boolean;\nexport type AriaRegex = {\n    pattern: string;\n};\nexport type AriaTextValue = {\n    raw: string;\n    normalized: string;\n};\nexport type AriaTemplateTextNode = {\n    kind: 'text';\n    text: AriaTextValue;\n};\nexport type AriaTemplateRoleNode = AriaProps & {\n    kind: 'role';\n    role: AriaRole | 'fragment';\n    name?: AriaRegex | string;\n    children?: AriaTemplateNode[];\n    props?: Record<string, AriaTextValue>;\n    containerMode?: 'contain' | 'equal' | 'deep-equal';\n};\nexport type AriaTemplateNode = AriaTemplateRoleNode | AriaTemplateTextNode;\nimport type * as yamlTypes from 'yaml';\ntype YamlLibrary = {\n    parseDocument: typeof yamlTypes.parseDocument;\n    Scalar: typeof yamlTypes.Scalar;\n    YAMLMap: typeof yamlTypes.YAMLMap;\n    YAMLSeq: typeof yamlTypes.YAMLSeq;\n    LineCounter: typeof yamlTypes.LineCounter;\n};\ntype ParsedYamlPosition = {\n    line: number;\n    col: number;\n};\ntype ParsingOptions = yamlTypes.ParseOptions;\nexport type ParsedYamlError = {\n    message: string;\n    range: [ParsedYamlPosition, ParsedYamlPosition];\n};\nexport declare function parseAriaSnapshotUnsafe(yaml: YamlLibrary, text: string, options?: ParsingOptions): AriaTemplateNode;\nexport declare function parseAriaSnapshot(yaml: YamlLibrary, text: string, options?: ParsingOptions): {\n    fragment: AriaTemplateNode;\n    errors: ParsedYamlError[];\n};\nexport declare function textValue(value: string): AriaTextValue;\nexport declare class KeyParser {\n    private _input;\n    private _pos;\n    private _length;\n    static parse(text: yamlTypes.Scalar<string>, options: ParsingOptions, errors: ParsedYamlError[]): AriaTemplateRoleNode | null;\n    constructor(input: string);\n    private _peek;\n    private _next;\n    private _eof;\n    private _isWhitespace;\n    private _skipWhitespace;\n    private _readIdentifier;\n    private _readString;\n    private _throwError;\n    private _readRegex;\n    private _readStringOrRegex;\n    private _readAttributes;\n    _parse(): AriaTemplateRoleNode;\n    private _applyAttribute;\n    private _assert;\n}\nexport declare class ParserError extends Error {\n    readonly pos: number;\n    constructor(message: string, pos: number);\n}\nexport {};\n//# sourceMappingURL=ariaSnapshot.d.ts.map",
      "utils/isomorphic/assert.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport declare function assert(value: any, message?: string): asserts value;\n//# sourceMappingURL=assert.d.ts.map",
      "utils/isomorphic/colors.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport declare const webColors: {\n    enabled: boolean;\n    reset: (text: string) => string;\n    bold: (text: string) => string;\n    dim: (text: string) => string;\n    italic: (text: string) => string;\n    underline: (text: string) => string;\n    inverse: (text: string) => string;\n    hidden: (text: string) => string;\n    strikethrough: (text: string) => string;\n    black: (text: string) => string;\n    red: (text: string) => string;\n    green: (text: string) => string;\n    yellow: (text: string) => string;\n    blue: (text: string) => string;\n    magenta: (text: string) => string;\n    cyan: (text: string) => string;\n    white: (text: string) => string;\n    gray: (text: string) => string;\n    grey: (text: string) => string;\n};\nexport type Colors = typeof webColors;\nexport declare const noColors: Colors;\n//# sourceMappingURL=colors.d.ts.map",
      "utils/isomorphic/cssParser.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport declare class InvalidSelectorError extends Error {\n}\nexport declare function isInvalidSelectorError(error: Error): error is InvalidSelectorError;\ntype ClauseCombinator = '' | '>' | '+' | '~' | '>=';\nexport type CSSFunctionArgument = CSSComplexSelector | number | string;\nexport type CSSFunction = {\n    name: string;\n    args: CSSFunctionArgument[];\n};\nexport type CSSSimpleSelector = {\n    css?: string;\n    functions: CSSFunction[];\n};\nexport type CSSComplexSelector = {\n    simples: {\n        selector: CSSSimpleSelector;\n        combinator: ClauseCombinator;\n    }[];\n};\nexport type CSSComplexSelectorList = CSSComplexSelector[];\nexport declare function parseCSS(selector: string, customNames: Set<string>): {\n    selector: CSSComplexSelectorList;\n    names: string[];\n};\nexport declare function serializeSelector(args: CSSFunctionArgument[]): string;\nexport {};\n//# sourceMappingURL=cssParser.d.ts.map",
      "utils/isomorphic/cssTokenizer.d.ts": "export interface CSSTokenInterface {\n    toSource(): string;\n    value: string | number | undefined;\n}\nexport declare class InvalidCharacterError extends Error {\n    constructor(message: string);\n}\nexport declare function tokenize(str1: string): CSSTokenInterface[];\nexport declare class CSSParserToken implements CSSTokenInterface {\n    tokenType: string;\n    value: string | number | undefined;\n    toJSON(): any;\n    toString(): string;\n    toSource(): string;\n}\nexport declare class BadStringToken extends CSSParserToken {\n    tokenType: string;\n}\nexport declare class BadURLToken extends CSSParserToken {\n    tokenType: string;\n}\nexport declare class WhitespaceToken extends CSSParserToken {\n    tokenType: string;\n    toString(): string;\n    toSource(): string;\n}\nexport declare class CDOToken extends CSSParserToken {\n    tokenType: string;\n    toSource(): string;\n}\nexport declare class CDCToken extends CSSParserToken {\n    tokenType: string;\n    toSource(): string;\n}\nexport declare class ColonToken extends CSSParserToken {\n    tokenType: string;\n}\nexport declare class SemicolonToken extends CSSParserToken {\n    tokenType: string;\n}\nexport declare class CommaToken extends CSSParserToken {\n    tokenType: string;\n}\nexport declare class GroupingToken extends CSSParserToken {\n    value: string;\n    mirror: string;\n}\nexport declare class OpenCurlyToken extends GroupingToken {\n    tokenType: string;\n    constructor();\n}\nexport declare class CloseCurlyToken extends GroupingToken {\n    tokenType: string;\n    constructor();\n}\nexport declare class OpenSquareToken extends GroupingToken {\n    tokenType: string;\n    constructor();\n}\nexport declare class CloseSquareToken extends GroupingToken {\n    tokenType: string;\n    constructor();\n}\nexport declare class OpenParenToken extends GroupingToken {\n    tokenType: string;\n    constructor();\n}\nexport declare class CloseParenToken extends GroupingToken {\n    tokenType: string;\n    constructor();\n}\nexport declare class IncludeMatchToken extends CSSParserToken {\n    tokenType: string;\n}\nexport declare class DashMatchToken extends CSSParserToken {\n    tokenType: string;\n}\nexport declare class PrefixMatchToken extends CSSParserToken {\n    tokenType: string;\n}\nexport declare class SuffixMatchToken extends CSSParserToken {\n    tokenType: string;\n}\nexport declare class SubstringMatchToken extends CSSParserToken {\n    tokenType: string;\n}\nexport declare class ColumnToken extends CSSParserToken {\n    tokenType: string;\n}\nexport declare class EOFToken extends CSSParserToken {\n    tokenType: string;\n    toSource(): string;\n}\nexport declare class DelimToken extends CSSParserToken {\n    tokenType: string;\n    value: string;\n    constructor(code: number);\n    toString(): string;\n    toJSON(): any;\n    toSource(): string;\n}\nexport declare abstract class StringValuedToken extends CSSParserToken {\n    value: string;\n    ASCIIMatch(str: string): boolean;\n    toJSON(): any;\n}\nexport declare class IdentToken extends StringValuedToken {\n    constructor(val: string);\n    tokenType: string;\n    toString(): string;\n    toSource(): string;\n}\nexport declare class FunctionToken extends StringValuedToken {\n    tokenType: string;\n    mirror: string;\n    constructor(val: string);\n    toString(): string;\n    toSource(): string;\n}\nexport declare class AtKeywordToken extends StringValuedToken {\n    tokenType: string;\n    constructor(val: string);\n    toString(): string;\n    toSource(): string;\n}\nexport declare class HashToken extends StringValuedToken {\n    tokenType: string;\n    type: string;\n    constructor(val: string);\n    toString(): string;\n    toJSON(): any;\n    toSource(): string;\n}\nexport declare class StringToken extends StringValuedToken {\n    tokenType: string;\n    constructor(val: string);\n    toString(): string;\n}\nexport declare class URLToken extends StringValuedToken {\n    tokenType: string;\n    constructor(val: string);\n    toString(): string;\n    toSource(): string;\n}\nexport declare class NumberToken extends CSSParserToken {\n    tokenType: string;\n    type: string;\n    repr: string;\n    constructor();\n    toString(): string;\n    toJSON(): any;\n    toSource(): string;\n}\nexport declare class PercentageToken extends CSSParserToken {\n    tokenType: string;\n    repr: string;\n    constructor();\n    toString(): string;\n    toJSON(): any;\n    toSource(): string;\n}\nexport declare class DimensionToken extends CSSParserToken {\n    tokenType: string;\n    type: string;\n    repr: string;\n    unit: string;\n    constructor();\n    toString(): string;\n    toJSON(): any;\n    toSource(): string;\n}\n//# sourceMappingURL=cssTokenizer.d.ts.map",
      "utils/isomorphic/headers.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\ntype HeadersArray = {\n    name: string;\n    value: string;\n}[];\ntype HeadersObject = {\n    [key: string]: string;\n};\nexport declare function headersObjectToArray(headers: HeadersObject, separator?: string, setCookieSeparator?: string): HeadersArray;\nexport declare function headersArrayToObject(headers: HeadersArray, lowerCase: boolean): HeadersObject;\nexport {};\n//# sourceMappingURL=headers.d.ts.map",
      "utils/isomorphic/locatorGenerators.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport type Language = 'javascript' | 'python' | 'java' | 'csharp' | 'jsonl';\nexport type LocatorType = 'default' | 'role' | 'text' | 'label' | 'placeholder' | 'alt' | 'title' | 'test-id' | 'nth' | 'first' | 'last' | 'visible' | 'has-text' | 'has-not-text' | 'has' | 'hasNot' | 'frame' | 'frame-locator' | 'and' | 'or' | 'chain';\nexport type LocatorBase = 'page' | 'locator' | 'frame-locator';\nexport type Quote = '\\'' | '\"' | '`';\ntype LocatorOptions = {\n    attrs?: {\n        name: string;\n        value: string | boolean | number;\n    }[];\n    exact?: boolean;\n    name?: string | RegExp;\n    hasText?: string | RegExp;\n    hasNotText?: string | RegExp;\n};\nexport interface LocatorFactory {\n    generateLocator(base: LocatorBase, kind: LocatorType, body: string | RegExp, options?: LocatorOptions): string;\n    chainLocators(locators: string[]): string;\n}\nexport declare function asLocatorDescription(lang: Language, selector: string): string | undefined;\nexport declare function locatorCustomDescription(selector: string): string | undefined;\nexport declare function asLocator(lang: Language, selector: string, isFrameLocator?: boolean): string;\nexport declare function asLocators(lang: Language, selector: string, isFrameLocator?: boolean, maxOutputSize?: number, preferredQuote?: Quote): string[];\nexport declare class JavaScriptLocatorFactory implements LocatorFactory {\n    private preferredQuote?;\n    constructor(preferredQuote?: Quote);\n    generateLocator(base: LocatorBase, kind: LocatorType, body: string | RegExp, options?: LocatorOptions): string;\n    chainLocators(locators: string[]): string;\n    private regexToSourceString;\n    private toCallWithExact;\n    private toHasText;\n    private toTestIdValue;\n    private quote;\n}\nexport declare class PythonLocatorFactory implements LocatorFactory {\n    generateLocator(base: LocatorBase, kind: LocatorType, body: string | RegExp, options?: LocatorOptions): string;\n    chainLocators(locators: string[]): string;\n    private regexToString;\n    private toCallWithExact;\n    private toHasText;\n    private toTestIdValue;\n    private quote;\n}\nexport declare class JavaLocatorFactory implements LocatorFactory {\n    generateLocator(base: LocatorBase, kind: LocatorType, body: string | RegExp, options?: LocatorOptions): string;\n    chainLocators(locators: string[]): string;\n    private regexToString;\n    private toCallWithExact;\n    private toHasText;\n    private toTestIdValue;\n    private quote;\n}\nexport declare class CSharpLocatorFactory implements LocatorFactory {\n    generateLocator(base: LocatorBase, kind: LocatorType, body: string | RegExp, options?: LocatorOptions): string;\n    chainLocators(locators: string[]): string;\n    private regexToString;\n    private toCallWithExact;\n    private toHasText;\n    private toTestIdValue;\n    private toHasNotText;\n    private quote;\n}\nexport declare class JsonlLocatorFactory implements LocatorFactory {\n    generateLocator(base: LocatorBase, kind: LocatorType, body: string | RegExp, options?: LocatorOptions): string;\n    chainLocators(locators: string[]): string;\n}\nexport {};\n//# sourceMappingURL=locatorGenerators.d.ts.map",
      "utils/isomorphic/locatorParser.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { Language } from './locatorGenerators';\nexport declare function locatorOrSelectorAsSelector(language: Language, locator: string, testIdAttributeName: string): string;\nexport declare function unsafeLocatorOrSelectorAsSelector(language: Language, locator: string, testIdAttributeName: string): string;\n//# sourceMappingURL=locatorParser.d.ts.map",
      "utils/isomorphic/locatorUtils.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport type ByRoleOptions = {\n    checked?: boolean;\n    disabled?: boolean;\n    exact?: boolean;\n    expanded?: boolean;\n    includeHidden?: boolean;\n    level?: number;\n    name?: string | RegExp;\n    pressed?: boolean;\n    selected?: boolean;\n};\nexport declare function getByTestIdSelector(testIdAttributeName: string, testId: string | RegExp): string;\nexport declare function getByLabelSelector(text: string | RegExp, options?: {\n    exact?: boolean;\n}): string;\nexport declare function getByAltTextSelector(text: string | RegExp, options?: {\n    exact?: boolean;\n}): string;\nexport declare function getByTitleSelector(text: string | RegExp, options?: {\n    exact?: boolean;\n}): string;\nexport declare function getByPlaceholderSelector(text: string | RegExp, options?: {\n    exact?: boolean;\n}): string;\nexport declare function getByTextSelector(text: string | RegExp, options?: {\n    exact?: boolean;\n}): string;\nexport declare function getByRoleSelector(role: string, options?: ByRoleOptions): string;\n//# sourceMappingURL=locatorUtils.d.ts.map",
      "utils/isomorphic/manualPromise.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport declare class ManualPromise<T = void> extends Promise<T> {\n    private _resolve;\n    private _reject;\n    private _isDone;\n    constructor();\n    isDone(): boolean;\n    resolve(t: T): void;\n    reject(e: Error): void;\n    static get [Symbol.species](): PromiseConstructor;\n    get [Symbol.toStringTag](): string;\n}\nexport declare class LongStandingScope {\n    private _terminateError;\n    private _closeError;\n    private _terminatePromises;\n    private _isClosed;\n    reject(error: Error): void;\n    close(error: Error): void;\n    isClosed(): boolean;\n    static raceMultiple<T>(scopes: LongStandingScope[], promise: Promise<T>): Promise<T>;\n    race<T>(promise: Promise<T> | Promise<T>[]): Promise<T>;\n    safeRace<T>(promise: Promise<T>, defaultValue?: T): Promise<T>;\n    private _race;\n}\n//# sourceMappingURL=manualPromise.d.ts.map",
      "utils/isomorphic/mimeType.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport declare function isJsonMimeType(mimeType: string): boolean;\nexport declare function isTextualMimeType(mimeType: string): boolean;\nexport declare function getMimeTypeForPath(path: string): string | null;\n//# sourceMappingURL=mimeType.d.ts.map",
      "utils/isomorphic/multimap.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport declare class MultiMap<K, V> {\n    private _map;\n    constructor();\n    set(key: K, value: V): void;\n    get(key: K): V[];\n    has(key: K): boolean;\n    delete(key: K, value: V): void;\n    deleteAll(key: K): void;\n    hasValue(key: K, value: V): boolean;\n    get size(): number;\n    [Symbol.iterator](): Iterator<[K, V[]]>;\n    keys(): IterableIterator<K>;\n    values(): Iterable<V>;\n    clear(): void;\n}\n//# sourceMappingURL=multimap.d.ts.map",
      "utils/isomorphic/protocolFormatter.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport declare function formatProtocolParam(params: Record<string, string> | undefined, alternatives: string): string | undefined;\nexport declare function renderTitleForCall(metadata: {\n    title?: string;\n    type: string;\n    method: string;\n    params: Record<string, string> | undefined;\n}): string;\nexport type ActionGroup = 'configuration' | 'route' | 'getter';\nexport declare function getActionGroup(metadata: {\n    type: string;\n    method: string;\n}): undefined | ActionGroup;\n//# sourceMappingURL=protocolFormatter.d.ts.map",
      "utils/isomorphic/protocolMetainfo.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport declare const methodMetainfo: Map<string, {\n    internal?: boolean;\n    title?: string;\n    slowMo?: boolean;\n    snapshot?: boolean;\n    pausesBeforeInput?: boolean;\n    pausesBeforeAction?: boolean;\n    group?: string;\n}>;\n//# sourceMappingURL=protocolMetainfo.d.ts.map",
      "utils/isomorphic/rtti.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport { isString } from './stringUtils';\nexport declare function isRegExp(obj: any): obj is RegExp;\nexport declare function isObject(obj: any): obj is NonNullable<object>;\nexport declare function isError(obj: any): obj is Error;\n//# sourceMappingURL=rtti.d.ts.map",
      "utils/isomorphic/selectorParser.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { CSSComplexSelectorList } from './cssParser';\nexport { InvalidSelectorError, isInvalidSelectorError } from './cssParser';\nexport type NestedSelectorBody = {\n    parsed: ParsedSelector;\n    distance?: number;\n};\nexport type ParsedSelectorPart = {\n    name: string;\n    body: string | CSSComplexSelectorList | NestedSelectorBody;\n    source: string;\n};\nexport type ParsedSelector = {\n    parts: ParsedSelectorPart[];\n    capture?: number;\n};\nexport declare const customCSSNames: Set<string>;\nexport declare function parseSelector(selector: string): ParsedSelector;\nexport declare function splitSelectorByFrame(selectorText: string): ParsedSelector[];\nexport declare function stringifySelector(selector: string | ParsedSelector, forceEngineName?: boolean): string;\nexport declare function visitAllSelectorParts(selector: ParsedSelector, visitor: (part: ParsedSelectorPart, nested: boolean) => void): void;\nexport type AttributeSelectorOperator = '<truthy>' | '=' | '*=' | '|=' | '^=' | '$=' | '~=';\nexport type AttributeSelectorPart = {\n    name: string;\n    jsonPath: string[];\n    op: AttributeSelectorOperator;\n    value: any;\n    caseSensitive: boolean;\n};\nexport type AttributeSelector = {\n    name: string;\n    attributes: AttributeSelectorPart[];\n};\nexport declare function parseAttributeSelector(selector: string, allowUnquotedStrings: boolean): AttributeSelector;\n//# sourceMappingURL=selectorParser.d.ts.map",
      "utils/isomorphic/semaphore.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport declare class Semaphore {\n    private _max;\n    private _acquired;\n    private _queue;\n    constructor(max: number);\n    setMax(max: number): void;\n    acquire(): Promise<void>;\n    release(): void;\n    private _flush;\n}\n//# sourceMappingURL=semaphore.d.ts.map",
      "utils/isomorphic/stackTrace.d.ts": "/**\n * The MIT License (MIT)\n * Modifications copyright (c) Microsoft Corporation.\n *\n * Copyright (c) 2016-2023 Isaac Z. Schlueter i@izs.me, James Talmage james@talmage.io (github.com/jamestalmage), and\n * Contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n * documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the\n * Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\n * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\nexport type RawStack = string[];\nexport type StackFrame = {\n    file: string;\n    line: number;\n    column: number;\n    function?: string;\n};\nexport declare function captureRawStack(): RawStack;\nexport declare function parseStackFrame(text: string, pathSeparator: string, showInternalStackFrames: boolean): StackFrame | null;\nexport declare function rewriteErrorMessage<E extends Error>(e: E, newMessage: string): E;\nexport declare function stringifyStackFrames(frames: StackFrame[]): string[];\nexport declare function splitErrorMessage(message: string): {\n    name: string;\n    message: string;\n};\nexport declare function parseErrorStack(stack: string, pathSeparator: string, showInternalStackFrames?: boolean): {\n    message: string;\n    stackLines: string[];\n    location?: StackFrame;\n};\n//# sourceMappingURL=stackTrace.d.ts.map",
      "utils/isomorphic/stringUtils.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport declare function escapeWithQuotes(text: string, char?: string): string;\nexport declare function escapeTemplateString(text: string): string;\nexport declare function isString(obj: any): obj is string;\nexport declare function toTitleCase(name: string): string;\nexport declare function toSnakeCase(name: string): string;\nexport declare function quoteCSSAttributeValue(text: string): string;\nexport declare function cacheNormalizedWhitespaces(): void;\nexport declare function normalizeWhiteSpace(text: string): string;\nexport declare function normalizeEscapedRegexQuotes(source: string): string;\nexport declare function escapeForTextSelector(text: string | RegExp, exact: boolean): string;\nexport declare function escapeForAttributeSelector(value: string | RegExp, exact: boolean): string;\nexport declare function trimString(input: string, cap: number, suffix?: string): string;\nexport declare function trimStringWithEllipsis(input: string, cap: number): string;\nexport declare function escapeRegExp(s: string): string;\nexport declare function escapeHTMLAttribute(s: string): string;\nexport declare function escapeHTML(s: string): string;\nexport declare function longestCommonSubstring(s1: string, s2: string): string;\n//# sourceMappingURL=stringUtils.d.ts.map",
      "utils/isomorphic/time.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport declare function setTimeOrigin(origin: number): void;\nexport declare function timeOrigin(): number;\nexport declare function monotonicTime(): number;\nexport declare const DEFAULT_PLAYWRIGHT_TIMEOUT = 30000;\nexport declare const DEFAULT_PLAYWRIGHT_LAUNCH_TIMEOUT: number;\n//# sourceMappingURL=time.d.ts.map",
      "utils/isomorphic/timeoutRunner.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport declare function raceAgainstDeadline<T>(cb: () => Promise<T>, deadline: number): Promise<{\n    result: T;\n    timedOut: false;\n} | {\n    timedOut: true;\n}>;\nexport declare function pollAgainstDeadline<T>(callback: () => Promise<{\n    continuePolling: boolean;\n    result: T;\n}>, deadline: number, pollIntervals?: number[]): Promise<{\n    result?: T;\n    timedOut: boolean;\n}>;\n//# sourceMappingURL=timeoutRunner.d.ts.map",
      "utils/isomorphic/traceUtils.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { ClientSideCallMetadata, StackFrame } from '@protocol/channels';\nexport type SerializedStackFrame = [number, number, number, string];\nexport type SerializedStack = [number, SerializedStackFrame[]];\nexport type SerializedClientSideCallMetadata = {\n    files: string[];\n    stacks: SerializedStack[];\n};\nexport declare function parseClientSideCallMetadata(data: SerializedClientSideCallMetadata): Map<string, StackFrame[]>;\nexport declare function serializeClientSideCallMetadata(metadatas: ClientSideCallMetadata[]): SerializedClientSideCallMetadata;\n//# sourceMappingURL=traceUtils.d.ts.map",
      "utils/isomorphic/types.d.ts": "/**\n * Copyright (c) Microsoft Corporation. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport type Size = {\n    width: number;\n    height: number;\n};\nexport type Point = {\n    x: number;\n    y: number;\n};\nexport type Rect = Size & Point;\nexport type Quad = [Point, Point, Point, Point];\nexport type NameValue = {\n    name: string;\n    value: string;\n};\nexport type HeadersArray = NameValue[];\n//# sourceMappingURL=types.d.ts.map",
      "utils/isomorphic/urlMatch.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport declare function globToRegexPattern(glob: string): string;\nexport type URLMatch = string | RegExp | ((url: URL) => boolean);\nexport declare function urlMatchesEqual(match1: URLMatch, match2: URLMatch): boolean;\nexport declare function urlMatches(baseURL: string | undefined, urlString: string, match: URLMatch | undefined, webSocketUrl?: boolean): boolean;\nexport declare function resolveGlobToRegexPattern(baseURL: string | undefined, glob: string, webSocketUrl?: boolean): string;\nexport declare function constructURLBasedOnBaseURL(baseURL: string | undefined, givenURL: string): string;\n//# sourceMappingURL=urlMatch.d.ts.map",
      "utils/isomorphic/utilityScriptSerializers.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\ntype TypedArrayKind = 'i8' | 'ui8' | 'ui8c' | 'i16' | 'ui16' | 'i32' | 'ui32' | 'f32' | 'f64' | 'bi64' | 'bui64';\nexport type SerializedValue = undefined | boolean | number | string | {\n    v: 'null' | 'undefined' | 'NaN' | 'Infinity' | '-Infinity' | '-0';\n} | {\n    d: string;\n} | {\n    u: string;\n} | {\n    bi: string;\n} | {\n    e: {\n        n: string;\n        m: string;\n        s: string;\n    };\n} | {\n    r: {\n        p: string;\n        f: string;\n    };\n} | {\n    a: SerializedValue[];\n    id: number;\n} | {\n    o: {\n        k: string;\n        v: SerializedValue;\n    }[];\n    id: number;\n} | {\n    ref: number;\n} | {\n    h: number;\n} | {\n    ta: {\n        b: string;\n        k: TypedArrayKind;\n    };\n};\ntype HandleOrValue = {\n    h: number;\n} | {\n    fallThrough: any;\n};\nexport declare function parseEvaluationResultValue(value: SerializedValue, handles?: any[], refs?: Map<number, object>): any;\nexport declare function serializeAsCallArgument(value: any, handleSerializer: (value: any) => HandleOrValue): SerializedValue;\nexport {};\n//# sourceMappingURL=utilityScriptSerializers.d.ts.map",
      "utils.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport * from './utils/isomorphic/ariaSnapshot';\nexport * from './utils/isomorphic/assert';\nexport * from './utils/isomorphic/colors';\nexport * from './utils/isomorphic/headers';\nexport * from './utils/isomorphic/locatorGenerators';\nexport * from './utils/isomorphic/manualPromise';\nexport * from './utils/isomorphic/mimeType';\nexport * from './utils/isomorphic/multimap';\nexport * from './utils/isomorphic/protocolFormatter';\nexport * from './utils/isomorphic/protocolMetainfo';\nexport * from './utils/isomorphic/rtti';\nexport * from './utils/isomorphic/semaphore';\nexport * from './utils/isomorphic/stackTrace';\nexport * from './utils/isomorphic/stringUtils';\nexport * from './utils/isomorphic/time';\nexport * from './utils/isomorphic/timeoutRunner';\nexport * from './utils/isomorphic/urlMatch';\nexport * from './server/utils/ascii';\nexport * from './server/utils/comparators';\nexport * from './server/utils/crypto';\nexport * from './server/utils/debug';\nexport * from './server/utils/debugLogger';\nexport * from './server/utils/env';\nexport * from './server/utils/eventsHelper';\nexport * from './server/utils/expectUtils';\nexport * from './server/utils/fileUtils';\nexport * from './server/utils/hostPlatform';\nexport * from './server/utils/httpServer';\nexport * from './server/utils/imageUtils';\nexport * from './server/utils/network';\nexport * from './server/utils/nodePlatform';\nexport * from './server/utils/processLauncher';\nexport * from './server/utils/profiler';\nexport * from './server/utils/socksProxy';\nexport * from './server/utils/spawnAsync';\nexport * from './server/utils/task';\nexport * from './server/utils/userAgent';\nexport * from './server/utils/wsServer';\nexport * from './server/utils/zipFile';\nexport * from './server/utils/zones';\nexport { colors } from './utilsBundle';\n//# sourceMappingURL=utils.d.ts.map",
      "utilsBundle.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport declare const colors: typeof import('../bundles/utils/node_modules/colors/safe');\nexport declare const debug: typeof import('../bundles/utils/node_modules/@types/debug');\nexport declare const diff: typeof import('../bundles/utils/node_modules/@types/diff');\nexport declare const dotenv: typeof import('../bundles/utils/node_modules/dotenv');\nexport declare const getProxyForUrl: typeof import('../bundles/utils/node_modules/@types/proxy-from-env').getProxyForUrl;\nexport declare const HttpsProxyAgent: typeof import('../bundles/utils/node_modules/https-proxy-agent').HttpsProxyAgent;\nexport declare const jpegjs: typeof import('../bundles/utils/node_modules/jpeg-js');\nexport declare const lockfile: typeof import('../bundles/utils/node_modules/@types/proper-lockfile');\nexport declare const mime: typeof import('../bundles/utils/node_modules/@types/mime');\nexport declare const minimatch: typeof import('../bundles/utils/node_modules/@types/minimatch');\nexport declare const open: typeof import('../bundles/utils/node_modules/open');\nexport declare const PNG: typeof import('../bundles/utils/node_modules/@types/pngjs').PNG;\nexport declare const program: typeof import('../bundles/utils/node_modules/commander').program;\nexport declare const ProgramOption: typeof import('../bundles/utils/node_modules/commander').Option;\nexport declare const progress: typeof import('../bundles/utils/node_modules/@types/progress');\nexport declare const SocksProxyAgent: typeof import('../bundles/utils/node_modules/socks-proxy-agent').SocksProxyAgent;\nexport declare const ws: typeof import('../bundles/utils/node_modules/@types/ws');\nexport declare const wsServer: typeof import('../bundles/utils/node_modules/@types/ws').WebSocketServer;\nexport declare const wsReceiver: any;\nexport declare const wsSender: any;\nexport declare const yaml: typeof import('../bundles/utils/node_modules/yaml');\nexport type { Range as YAMLRange, Scalar as YAMLScalar, YAMLError, YAMLMap, YAMLSeq } from '../bundles/utils/node_modules/yaml';\nexport declare const zod: typeof import('../bundles/utils/node_modules/zod');\nexport type { Command } from '../bundles/utils/node_modules/commander';\nexport type { EventEmitter as WebSocketEventEmitter, RawData as WebSocketRawData, WebSocket, WebSocketServer } from '../bundles/utils/node_modules/@types/ws';\nexport declare function ms(ms: number): string;\n//# sourceMappingURL=utilsBundle.d.ts.map",
      "utilsBundleImpl.d.ts": "export declare const colors: any;\nexport declare const debug: any;\nexport declare const diff: any;\nexport declare const dotenv: any;\nexport declare const getProxyForUrl: (_url: string) => any;\nexport declare const HttpsProxyAgent: any;\nexport declare const SocksProxyAgent: any;\nexport declare const jpegjs: any;\nexport declare const lockfile: any;\nexport declare const mime: any;\nexport declare const minimatch: any;\nexport declare const open: any;\nexport declare const PNG: any;\nexport declare const program: any;\nexport declare const ProgramOption: any;\nexport declare const progress: any;\nexport declare const ws: any;\nexport declare const wsServer: any;\nexport declare const wsReceiver: any;\nexport declare const wsSender: any;\nexport declare const yaml: any;\nexport declare const zod: any;\n//# sourceMappingURL=utilsBundleImpl.d.ts.map",
      "zipBundle.d.ts": "/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport declare const yazl: typeof import('../bundles/zip/node_modules/@types/yazl');\nexport type { ZipFile } from '../bundles/zip/node_modules/@types/yazl';\nexport declare const yauzl: typeof import('../bundles/zip/node_modules/@types/yauzl');\nexport type { Entry, ZipFile as UnzipFile } from '../bundles/zip/node_modules/@types/yauzl';\nexport declare const extract: typeof import('../bundles/zip/src/third_party/extract-zip.d.ts');\n//# sourceMappingURL=zipBundle.d.ts.map",
      "zipBundleImpl.d.ts": "export declare const yazl: any;\nexport declare const yauzl: any;\nexport declare const extract: any;\n//# sourceMappingURL=zipBundleImpl.d.ts.map"
    },
    "subpaths": {}
  },
  "@natstack/playwright-protocol": {
    "files": {
      "index.d.ts": "export {};\n//# sourceMappingURL=index.d.ts.map"
    },
    "subpaths": {}
  }
};
